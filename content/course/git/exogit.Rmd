---
title: "Un cadavre exquis pour découvrir Git"
date: 2020-09-30T13:00:00Z
draft: false
weight: 20
slug: exogit
tags:
  - Git
categories:
  - Exercice
type: book
summary: |
  Ce chapitre propose une mise en application de quelques principes
  centraux du langage Git vus précédemment
---

<!--- Inspirations
https://github.com/corent01/03-Swartz/blob/master/Parcours/01-La-prairie/git/exercice-git-cadavre-exquis.md
https://github.com/simplonco/cadavre-request
------>

```{r setup, include=FALSE}  
dir_path <- gsub(here::here(), "..", here::here("course","git"))
knitr::knit_hooks$set(
  plot = function(x, options) modif_plot(x, options, dir_path = dir_path)
)
```

```{r, echo = FALSE, results = 'asis', include = TRUE, eval = TRUE}
print_badges()
```

Les exercices suivants sont inspirés d'un cours de Git que j'ai construit
à l'Insee et dont les ressources sont disponibles
[ici](https://linogaliana.gitlab.io/collaboratif/git.html). L'idée
du cadavre exquis, qui m'a été inspirée par
[Romain Lesur](https://github.com/RLesur) est inspirée de
[cette ressource](https://github.com/corent01/03-Swartz/blob/master/Parcours/01-La-prairie/git/exercice-git-cadavre-exquis.md) et de [celle-ci](https://github.com/simplonco/cadavre-request)

Cette partie part du principe que les concepts généraux de Git sont
maîtrisés. Outre le [chapitre précédent](#introgit), il existe de
nombreuses ressources sur internet sur le sujet, notamment
[le cours de Git déjà cité](https://linogaliana.gitlab.io/collaboratif/git.html)
et des ressources `utilitR`
([des éléments sur la configuration](https://www.book.utilitr.org/git-config.html)
et [pratique sur RStudio](https://www.book.utilitr.org/git.html)).

L'idée de ce chapitre est d'amener, progressivement, à la mise en oeuvre
de pratiques collaboratives devenues standards dans le domaine de l'open-source
mais également de plus en plus communes dans les administrations et entreprises
de la data-science. 

Ce chapitre propose d'utiliser l'extension Git de JupyterLab.
Un tutoriel présentant cette extension est disponible
[ici](https://annefou.github.io/jupyter_publish/02-git/index.html). 
Les principaux IDE disponibles (Visual Studio,
PyCharm, RStudio) présentent des fonctionalités similaires. Il est
tout à fait possible d'en utiliser un autre. VisualStudio propose
probablement, à l'heure actuelle, l'ensemble le plus complet. 

Certains passages de ce TD nécessitent d'utiliser la ligne de commande.
Il est tout à fait possible de réaliser ce TD entièrement avec celle-ci.
Cependant, pour une personne débutante en `Git`, l'utilisation d'une 
interface graphique peut constituer un élément important pour
la compréhension et l'adoption de `Git`. Une fois à l'aise avec
`Git`, on peut tout à fait se passer des interfaces graphiques
pour les routines quotidiennes et ne les utiliser que
pour certaines opérations où elles s'avèrent fort pratiques
(notamment la comparaison de deux fichiers avant de devoir fusionner).



# Première étape: configuration du compte Github

## Rappels sur la notion de dépôt distant

Pour rappel, comme expliqué précédemment, il convient de distinguer
le dépôt distant (*remote*) et la copie ou les copies locales (les *clones*)
d'un dépôt. Le dépôt distant est généralement stocké sur une forge 
logicielle (`Github` ou `Gitlab`) et sert à centraliser la version
collective d'un projet. Les copies locales sont des copies de travail
qu'on utilise pour faire évoluer un projet:

```{r}
knitr::include_graphics("https://www.book.utilitr.org/pics/git/gitlab.png")
```

`Git` est un système de contrôle de version asynchrone c'est-à-dire
qu'on n'interagit pas en continu avec le dépôt distant (comme c'est le
cas dans le système SVN) mais qu'il est possible d'avoir une version
locale qui se différencie du dépôt commun et qu'on rend cohérente
de temps en temps. 

Bien qu'il soit possible d'avoir une utilisation hors-ligne de `Git`, 
c'est-à-dire un pur contrôle de version local sans dépôt
distant, cela est une utilisation
rare et qui comporte un intérêt limite. L'intérêt de `Git` est
d'offrir une manière robuste et efficace d'interagir avec un 
dépôt distant facilitant ainsi la collaboration en équipe ou en
solitaire. 

Pour ces exercices, je propose d'utiliser `Github` dont les fonctionalités
nous suffiront amplement[^1]. Si, 
dans le futur, les fonctionnalités ne vous conviennent pas (sans l'apport de fonctionnalités
externes, `Github` propose moins de fonctionalités que `Gitlab`) ou si vous êtes
mal à l'aise concernant le possesseur de `Github` (Microsoft), vous pourrez utiliser
`Gitlab` <i class="fab fa-gitlab"></i>, son concurrent.
L'avantage de `Github` par rapport à `Gitlab` est que le premier est plus visible, car
mieux indexé par `Google` et concentre, en partie pour des raisons historiques, plus
de développeurs `Python` et `R` (ce qui est important dans des domaines comme
le code où les externalités de réseau jouent). Le débat `Github` vs `Gitlab` n'a
plus beaucoup de sens aujourd'hui car les fonctionnalités ont convergé (`Github` 
a rattrapé une partie de son retard sur l'intégration continue) et, de toute
manière, on peut tout à fait connecter des dépôts `Gitlab` et `Github`. 


[^1]: Dans sa version en ligne, `Github` (<https://github.com>)
dispose de plus de visibilité que `Gitlab` (<https://gitlab.com>). 
L'avantage que comportait Gitlab par rapport à Github 
à une époque, à savoir la possibilité de disposer gratuitement de ressources
pour faire de l'intégration continue, c'est résorbé depuis que Github
a lancé son service Github Actions. Cependant, être familiarisé à 
l'environnement Gitlab reste utile car beaucoup de forges logicielles
internes reposent sur les fonctionalités open-source (l'interface graphique
en faisant parti) de `Gitlab`. Il est donc fort utile de maîtriser 
les fonctionalités coeur de ces deux interfaces qui sont en fait quasi-identiques. 


## Première étape: avoir un compte `Github`

Les deux premières étapes se font sur `Github`

{{% panel status="exercise" title="Exercice" icon="fab fa-github" %}}

**Exercice 1: créer un compte Github**

1. Si vous n'en avez pas déjà un, créer un compte sur https://github.com
2. Créer un dépôt vide. Créez ce dépôt **privé**, cela permettra
dans l'exercice 2 d'activer notre jeton. Vous pourrez le rendre public
après l'exercice 2, c'est comme vous le souhaitez.

{{% /panel %}}

## Deuxième étape: créer un *token* (jeton) HTTPS

## Principe

`Git` est un système décentralisé de contrôle de version :
les codes sont modifiés par chaque personne sur son poste de travail,
puis sont mis en conformité avec la version collective disponible
sur le dépôt distant au moment où le contributeur le décide.

Il est donc nécessaire que la forge connaisse l’identité de chacun des
contributeurs, afin de déterminer qui est l’auteur d’une modification apportée
aux codes stockés dans le dépôt distant.
Pour que `Github` reconnaisse un utilisateur proposant des modifications,
il est nécessaire de s’authentifier (un dépôt distant, même public, ne peut pas être modifié par n’importe qui). L’authentification consiste ainsi à fournir un élément que seul vous et la forge sont censés connaître : un mot de passe, une clé compliquée, un jeton d’accès...

Plus précisément, il existe deux modalités pour faire connaître son identité à `Github` :

* une authentification HTTPS (décrite ici) : l’authentification se fait avec un login et un mot de passe (qu’il faut renseigner à chaque interaction avec le dépôt), ou avec un token (méthode à privilégier).
* une authentification SSH : l’authentification se fait par une clé cryptée disponible sur le poste de travail et que GitHub ou GitLab connaît. Une fois configurée, cette méthode ne nécessite plus de faire connaître son identité : l’empreinte digitale que constitue la clé suffit à reconnaître un utilisateur.

La [documentation collaborative `utilitR`](https://www.book.utilitr.org/git-config.html#interaction-avec-un-d%C3%A9p%C3%B4t-distant-principe) présente les raisons pour lesquelles il convient de favoriser
la méthode HTTPS sur la méthode SSH. 

Depuis août 2020, `Github` n'autorise plus l'authentification par mot de passe
lorsqu'on interagit (`pull`/`push`) avec un dépôt distant
([raisons ici](https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/)).
Il est nécessaire d'utiliser un *token* (jeton d'accès) qui présente l'avantage
d'être révoquable (on peut à tout moment supprimer un jeton si, par exemple,
on suspecte qu'il a été diffusé par erreur) et à droits limités 
(le jeton permet certaines opérations standards mais
n'autorise pas certaines opérations déterminantes comme la suppression
d'un dépôt)


{{% panel status="note" title="Note" icon="fa fa-comment" %}}
Il est important de ne jamais stocker un _token_, et encore moins son mot de passe, dans un projet.
Il est possible de stocker un mot de passe ou *token* de manière sécurisée et durable
avec le *credential helper* de `Git`. Celui-ci est présenté par la suite.

S'il n'est pas possible d'utiliser le *credential helper* de `Git`, un mot de passe 
ou _token_ peut être stocké de manière sécurisé dans
un système de gestion de mot de passe comme [Keepass](https://keepass.fr/).

Ne jamais stocker un jeton `Github`, ou pire un mot de passe, dans un fichier
texte non crypté. Les logiciels de gestion de mot de passe
(comme [Keepass](https://keepass.fr/), recommandé par l'Anssi)
sont simples
d'usage et permettent de ne conserver sur l'ordinateur qu'une version
hashée du mot de passe qui ne peut être décryptée qu'avec un mot de passe
connu de vous seuls. 
{{% /panel %}}


## Créer un jeton

La [documentation officielle](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) comporte un certain nombre de captures d'écran expliquant
comme procéder

Nous allons utiliser le `credential helper` associé à Git pour stocker
ce jeton. Ce credential helper permet de conserver de manière sécurisée
votre mot de passe en ne le stockant pas en clair mais de manière hashée.

Si vous désirez conserver de manière plus durable votre jeton, je vous 
recommande d'utiliser un gestionnaire de mot de passe comme 
[Keepass](https://keepass.fr/). 

{{% panel status="exercise" title="Exercise" icon="fas fa-pencil-alt" %}}
**Créer et stocker un token**

1. Suivre la
[documentation officielle](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) en ne donnant que les droits `repo` au jeton (ajouter les droits
`workflow` si vous désirez que votre jeton soit utilisable pour des projets
où l'intégration continue est nécessaire)
2. Ouvrir un terminal depuis `Jupyter` (par exemple `File > New > Terminal`).
3. Taper dans le terminal la commande 
qui convient selon votre système d'exploitation pour activer le
`credential helper`:

```{shell, eval = FALSE}
# Sous mac et linux
git config --global credential.helper 

# Sous windows
git config --global credential.helper manager-core
```

3. Récupérer, sur la page d'accueil de votre dépôt, l'url du dépôt distant.
Il prend la forme suivante

https://github.com/username/reponame.git

Vous pouvez utiliser l'icone à droite pour copier l'url.

4. Retournez dans le terminal `Jupyter`. Taper 

```{shell, eval = FALSE}
git clone repo_url
```

où `repo_url` est l'url du dépôt en question (vous pouvez utiliser
<kbd>MAJ</kbd>+<kbd>Inser</kbd> pour coller l'url précédemment copié)

Tapez <kbd>Entrée</kbd>. Si vous n'avez pas d'erreur, cela signifie
que l'authentification a bien fonctionné et donc que tout va
bien. Normalement, si vous avez créé un dépôt vide dans l'exercice 1,
vous avez un message de `Git`: 

> warning: You appear to have cloned an empty repository.

Ceci est normal, ce n'est pas une erreur. Le dossier de votre projet a bien
été créé.

Si vous avez une erreur, suivez la consigne ci-dessous pour réinitialiser
votre *credential helper*

{{% /panel %}}

{{% panel status="note" title="Note" icon="fa fa-comment" %}}
Si vous avez fait une faute de frappe dans le mot de passe ou dans le jeton, il est possible de vider la mémoire
de la manière suivante, sous Mac ou Linux :

~~~~shell
git config --global --unset credential.helper
~~~~

Sous Windows, si vous avez utilisé l'option `manager-core` évoquée ci-dessus, vous pouvez utiliser une interface graphique pour effacer le mot de passe ou jeton erroné. Pour cela, dans le menu démarrer, taper `Gestionnaire d'identification` (ou `Credential Manager` si Windows ne trouve pas). Dans l'interface graphique qui s'ouvre, il est possible de supprimer le mot de passe ou jeton en question. Après cela, vous devriez à nouveau avoir l'opportunité de taper un mot de passe ou jeton lors d'une authentification HTTPS.
{{% /panel %}}




# Git tout seul 


### Pratique en local avec `git bash`

Maintenant, en local. Il faut ouvrir une invite de commande `git bash` (ou une
interface graphique connectée à `git bash`)

{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercice 2: découvrir l'invite de commande**

1. Sur les postes ENSAE. Aller dans `Scientific Apps/Git`. Vous devriez voir
un raccourci `bash.exe`. Vous pouvez lancer l'application ; elle ouvre une 
invite de commande
2. Créer un dossier de travail, par exemple `Desktop/gitexo`. Dans `git bash`,
faire 

~~~shell
# remplacer par le dossier qui vous intéresse
cd 'Desktop/gitexo'
~~~

3. Initialiser le contrôle de version en tapant dans l'invite de commande

~~~shell
git init
~~~

{{% /panel %}}


Pour le moment, on a uniquement initialisé le contrôle de version avec `Git`. 
On n'a encore ajouté aucun fichier à `Git`. D'ailleurs, la première 
chose à faire est d'exclure un certain nombre de fichiers, afin de ne pas
faire une erreur pénible à réparer.


{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercise 3: le fichier .gitignore**


Lorsqu'on utilise `Git`, il y a des fichiers qu'on ne veut pas partager
ou dont on ne veut pas suivre les modifications (typiquement les grosses bases de données). C'est le fichier `.gitignore`
qui gère les fichiers exclus du contrôle de version.

1. Maintenant, créer un fichier nommé `.gitignore` (:warning: ne pas changer
ce nom, et s'assurer que celui-ci n'a pas d'extension) via le bloc note ou votre IDE. 
1. Aller sur le site <https://www.toptal.com/developers/gitignore>. Vous pouvez
dans la barre de recherche taper  `Python`, `Pycharm`, `JupyterNotebooks`. 
Copier-coller dans votre `.gitignore` le contenu de la page. 
1. Quand on crée de la documentation, on veut exclure les extensions `.pdf`
et `.html` qui sont des résultats à partager et non des fichiers source à
suivre. Pour cela, ajouter au début du fichier `.gitignore`, les extensions:

~~~markdown
.pdf
.html
~~~

{{% /panel %}}


On a créé un fichier `.gitignore` mais on n'a encore rien fait jusqu'à présent.
Il faut dire à `Git` de contrôler les évolutions de chaque fichier 
(passage dans l'index). On appelle cette étape `git add`. 


{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercice 4: pratique de git. Enfin...**

1. De temps en temps, il est bon de vérifier l'état d'un dépôt. Pour cela, faire

~~~shell
git status
~~~

1. Dans l'invite de commande, taper

~~~shell
git add .gitignore
~~~

2. Retaper `git status`. Observer le changement. Les nouvelles modifications (en
l'occurrence la création du fichier et la validation de son contenu actuel)
ne sont pas encore archivées. Pour cela, il faut faire

~~~shell
git commit -m "Initial commit"
~~~

{{% /panel %}}

L'option `m` permet de créer un message, qui sera disponible à l'ensemble
des contributeurs du projet. Avec la ligne de commande, ce n'est pas toujours
très pratique. Les interfaces graphiques permettent des messages plus
développés (la bonne pratique veut qu'on écrive un message de commit comme un
mail succinct: un titre et un peu d'explications, si besoin).

Le fait de nommer le premier commit *"Initial commit"* est une
habitude, vous
n'êtes pas obligé de suivre cette convention si elle ne vous plaît pas.

### Premières interactions avec `Github` depuis `git bash`

{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercise 5: interagir avec Github depuis git bash**

Depuis août 2021, l'authentification à un compte Github a été [renforcée](https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/) et nécessite désormais la création d'un nouveau mot de passe (*personal access token*)

1. Après vous êtes assuré d'avoir vérifié votre adresse e-mail (*Settings > Emails*), suivez donc [ces instructions](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) pour vous créer un *personal access token* 

*Settings > Developers Settings > Personal Access Token > Generate a new token > "My bash script" > Expiration "01/03/2022" > cocher juste "repo" > Generate token > Le copier*


Il convient maintenant d'envoyer les fichiers sur le dépôt distant. 

1. Récupérer l'url du dépôt. Dans `Github`, il faut cliquer sur
le bouton `Code` comme ci-dessous

![](gitclone.png)

2. Créer la connexion avec le dépôt distant (`remote`), qu'on va nommer `origin`,
en utilisant la commande suivante:

~~~~shell
git remote add origin ****
~~~~
Remplacer les astérisques par l'url du dépôt. 

3. Envoyez vos modifications vers `origin` en tapant 

~~~~shell
git push origin master
~~~~

`Git` va vous demander vos identifiants de connexion pour vérifier que vous
êtes bien autorisés à intéragir avec ce dépôt. Il faut taper votre identifiant github et **votre mot de passe correspond au personal access token nouvellement créé** ! 

<!-- (:warning: -->
<!-- comme le créateur de `Git` était un peu paranoiaque, c'est normal -->
<!-- de ne pas voir le curseur avancer quand on tape des caractères pour le mot de passe, -->
<!-- si quelqu'un regarde votre écran il ne pourra ainsi pas savoir combien de -->
<!-- caractères comporte votre mot de passe) -->

{{% /panel %}}

Retournez voir le dépôt sur `Github`, vous devriez maintenant voir le fichier
`.gitignore` s'afficher en page d'accueil. 

### Premières interactions avec `Github` depuis `jupyterlab-git`

{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercice 6: interagir avec Github depuis jupyterlab-git**

[jupyterlab-git](https://github.com/jupyterlab/jupyterlab-git) est une extension permettant de faire du git depuis Jupyter.

1. Ouvrez une nouvelle instance `Jupyter Notebook` sur la plateforme Onyxia. 

2. Clonez votre répertoire github

*Git > Clone a repository > Entrer l'ancien URL de Clone de la page github*

3. Créer un fichier nommé `README.md` et écrivez une phrase dedans du type : Projet Python de Jean Dupont.

*File > New > Markdown File > Clic droit sur untitled.md > Rename > README.md*

4. Faites un commit dont le message est *"j'écris comme un surréaliste*

*Dans la catégorie "Untracked", le README.md devrait s'afficher. Appuyez sur +, pour qu'il apparaisse dans "Changed" puis écrivez votre message de commit et appuyez sur "commit" puis sur "push" (flèche vers le haut avec une pastille orange) et retapez une fois de plus votre identifiant github et votre personal access token.*

{{% /panel %}}

### La fonctionnalité `pull`


{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercice 7: rapatrier des modifs en local**

Pour le moment, vous êtes tout seul sur le dépôt. Il n'y a donc pas de 
partenaire pour modifier un fichier dans le dépôt distant. Nous verrons cela
lors de l'exercice suivant. Néanmoins, nous allons

1. Modifier le `README` par l'interface de `Github` en cliquant
sur le crayon en haut à droite de l'affichage du `README`.
L'objectif est de lui
donner un titre suivant, en ajoutant, au début du document, la ligne suivante : 

~~~text
# Mon oeuvre d'art surréaliste 
~~~

Rédiger un titre et un message complémentaire pour faire le `commit`. Conserver
l'option par défaut `Commit directly to the master branch`

3. Editer à nouveau le `README`. Ajouter une deuxième phrase et corrigez la
ponctuation de la première. Ecrire un message de commit et valider.

4. Au dessus de l'aborescence des fichiers, vous devriez voir s'afficher le
titre du dernier commit. Vous pouvez cliquer dessus pour voir la modification
que vous avez faite.

5. Les résultats sont sur le dépôt distant mais ne sont pas sur votre ordinateur ni dans le Jupyter Lab d'Onyxia

* Pour les rapatrier en local sur votre PC, faire

~~~shell
git pull origin master
~~~

* Pour les rapatrier sur onyxia, appuyez tout simplement sur la petite flèche vers le bas, qui est celle qui a désormais la pastille orange.

{{% /panel %}}

L'opération `pull` permet: 

1. A votre système local de vérifier les modifications sur le dépôt distant
que vous n'auriez pas faites
2. De les fusionner s'il n'y a pas de conflit de version ou si les conflits de
version sont automatiquement fusionnable (deux modifications d'un fichier mais
qui ne portent pas sur le même emplacement)


### Même tout seul, ne pas se limiter à `master`


Au début d’une tâche particulière ou d’un projet, il est recommandé d’ouvrir des issues. Prenant la forme d’un espace de discussion, elles correpondront à la fin à des nouvelles fonctionnalités (en anglais, *features*). Les issues permettent également de signaler des bugs constatés, de se les répartir et d’indiquer s’ils sont réglés ou s’ils ont avancés. Une utilisation intensive des *issues*, avec des labels adéquats, peut
même amener à se passer d'outils de gestion de projets comme `Trello`. 


La branche `master` est la branche principale. Elle se doit d'être "propre". Si on veut être rigoureux, on ne pousse pas des travaux non aboutis sur `master`.  

Il est possible de pousser directement sur `master` dans le cas de petites corrections, de modifications mineures dont vous êtes certains qu'elles vont fonctionner. Mais sachez que dans le cadre de projets sensibles, c'est strictement interdit. N'ayez pas peur de fixer comme règle l'interdiction de pousser sur `master` (voir section précédente), cela obligera l'équipe projet à travailler professionnellement. 

Au moindre doute, créez une branche. Les branches sont utilisées pour des travaux significatifs :

- vous travaillez seul sur une tâche qui va vous prendre plusieurs heures ou jours de travail (vous ne devez pas pousser sur `master` des travaux non aboutis);
- vous travaillez sur une fonctionnalité nouvelle et vous souhaiterez recueillir l'avis de vos collègues avant de modifier `master`;
- vous n'êtes pas certain de réussir vos modifications du premier coup et préférez faire des tests en parallèle.


{{% panel status="warning" title="Warning" icon="fa fa-exclamation-triangle" %}}

Les branches ne sont pas personnelles : **Toutes les branches sont publiées, le `rebase` est interdit. Le push force est également interdit.**

Il faut **absolument** bannir les usages de `push force` qui peuvent déstabiliser les copies locales des collaborateurs. S'il est nécessaire de faire un `push force`, c'est qu'il y a un problème dans la branche, à identifier et régler **sans** faire `push force`.

![](https://miro.medium.com/max/400/0*XaLzNzYkA6PZjbl9.jpg)

**Tous les merges dans `master` doivent se faire par l'intermédiaire d'une merge request dans `GitLab`**. En effet, il est très déconseillé de merger une branche dans master localement.

{{% /panel %}}


{{% panel status="hint" title="Hint" icon="fa fa-lightbulb" %}}
Comment nommer les branches ? Là encore, il y a énormément de conventions différentes. Une fréquemment observée est :

- pour les nouvelles fonctionnalités : `feature/nouvelle-fonctionnalite` où `nouvelle-fontionnalite` est un nom court résumant la fonctionnalité
- pour les corrections de bug : `issue-num` où `num` est le numéro de l'issue

N'hésitez pas à aller encore plus loin dans la normalisation  !
{{% /panel %}}


{{% panel status="hint" title="Hint" icon="fa fa-lightbulb" %}}

`:XXXXXX:` permet, dans des systèmes qui reposent sur `Markdown`, d'afficher
des emojis. Vous pouvez [trouver une liste ici](https://gist.github.com/rxaviers/7360908)

{{% /panel %}}


{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercice 8: Créer une nouvelle branche et l'intégrer dans master**

1. Ouvrir une *issue* sur `Github`. Signaler qu'il serait bien d'ajouter un emoji chat dans le README. Dans la partie de droite, cliquer sur la petite roue à côté de `Label` et cliquer sur `Edit Labels`. Créer un label `Markdown`. Retourner sur la page de l'*issue* et ajouter ce label

2. Sur votre dépôt local, créer une branche `issue-1` en faisant 

~~~shell
git checkout -b issue-1
~~~~

3. Ajouter un emoji chat à la suite du titre. Valider avec

~~~shell
git add .
git commit -m "ajout emoji chat"
~~~

`git add .` signifie qu'on ajoute à l'*index* de `Git` toutes les modifications sur les fichiers déjà suivis. Faire un **deuxième commit** pour ajouter un emoji koala. Pousser les modifications locales:

~~~shell
git push origin issue-1
~~~~

4. Dans `Github`, devrait apparaître `issue-1 had recent pushes XX minutes ago`. 
Cliquer sur `Compare & Pull Request`. Donner un titre informatif à votre *pull request*. Dans le message en dessous, taper `Close #1` ce qui permettra de fermer automatiquement l'*issue 1* lorsque vous ferez le *merge* puis "Create a Pull Request". **Ne validez pas la fusion**, on le fera dans un second temps.

5. En local, retourner sur `master`:

~~~shell
git checkout master
~~~~

Et ajouter une phrase à la suite de votre texte dans le README.md. Faire un commit et un push. 

~~~shell
git add .
git commit -m "ajout emojis chat et koala"
git push origin issue-1
~~~


6. Cliquer sur `Insights` en haut du dépôt puis, à gauche sur `Network`. Vous devriez voir apparaître l'arborescence de votre dépôt. On peut voir `issue-1` comme une ramification et `master` comme le tronc.

L'objectif est maintenant de ramener les modifications faites dans `issue-1` dans la branche principale. Retournez dans l'onglet `Pull Requests`. Là, changer le type de `merge` pour `Squash and Merge`, comme ci-dessous. Une fois que cela est fait, vous pouvez retourner dans `Insights` puis `Network` pour vérifier que tout s'est bien passé comme prévu. 

<!-- Vous pouvez vous reporter là [**METTRE LIEN**] pour la justification. -->

![](squashmerge.png)


7. Supprimer la branche (*branch > delete this branch*). Puisqu'elle est mergée, elle ne servira plus. La conserver risque d'amener à des push involontaires dessus. 

{{% /panel %}}


{{% panel status="note" title="Note" icon="fa fa-comment" %}}
La commande `checkout` est un couteau-suisse de la gestion de branche en `Git`. Elle permet en effet de basculer d'une branche à l'autre, mais aussi d'en créer, etc. 
{{% /panel %}}


{{% panel status="note" title="Note" icon="fa fa-comment" %}}
L'option de fusion *Squash and Merge* permet de regrouper tous les commits d'une branche (potentiellement très nombreux) en un seul dans la branche de destination. Cela évite, sur les gros projets, des branches avec des milliers de *commits*.
{{% /panel %}}

## Cadavre exquis: découvrir le travail collaboratif

{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercice 9: interactions avec le dépôt distant**

Cet exercice se fait par groupe de trois ou quatre. Il y aura deux rôles dans ce scénario : un mainteneur et deux à trois développeurs. 

1. Le mainteneur crée un dépôt sur `Github`. Il/Elle donne des droits au(x) développeur(s) du projet (`Settings > Manage Access > Invite a collaborator`).
2. Chaque membre du projet, crée une copie locale du projet grâce à la commande `git clone`. Pour cela, récupérer l'url HTTPS du dépôt en copiant l'url du dépôt que vous pouvez trouver, par exemple, dans la page d'accueil du dépôt, en dessous de `Quick setup — if you’ve done this kind of thing before`

~~~shell
git clone https://XXXXXX
~~~

3. Chaque membre du projet crée un fichier avec son nom et son prenom, selon cette structure `nom-prenom.md` en évitant les caractères spéciaux. Il écrit dedans trois phrases de son choix **sans ponctuation ni majuscules** (pour pouvoir effectuer une correction ultérieurement. Enfin, il commit sur le projet.

~~~shell
git add nom-prenom.md
git commit -m "C'est l'histoire de XXXXX"
~~~

4. Chacun essaie d'envoyer (*push*) ses modifications locales sur le dépôt:

~~~shell
git push origin master
~~~


5. A ce stade, une seule personne (la plus rapide) devrait ne pas avoir rencontré de rejet du `push`. C'est normal, avant d'accepter une modification `Git` vérifie en premier lieu la cohérence de la branche avec le dépôt distant. Le premier ayant fait un `push` a modifié le dépôt commun ; les autres doivent intégrer ces modifications dans leur version locale (*pull*) avant d'avoir le droit de proposer un  changement.

Pour celui/celle/ceux dont le `push` a été refusé, faire

~~~shell
git pull origin master
~~~

pour ramener les modifications distantes en local. 

6. Taper `git log` et regarder la manière dont a été intégré la modification de votre camarade ayant pu faire son `push`

7. Faire à nouveau 

~~~shell
git pull origin master
~~~

Le dernier doit refaire, à nouveau, les étapes 5 à 7.

{{% /panel %}}


{{% panel status="warning" title="Warning à nouveau: ne JAMAIS FAIRE git push force" icon="fa fa-exclamation-triangle" %}}
Quand on fait face à un rejet du `push`, on est tenté de faire passer en force le `push` malgré la mise en garde précédente.

Il faut immédiatement oublier cette solution, elle crée de nombreux problèmes et, en fait, ne résout rien. L'un des risques est de réécrire entièrement l'historique rendant les copies locales, et donc les modifications de vos collaborateurs, caduques. Cela vous vaudra, à raison, des remontrances de vos partenaires qui perdent le bénéfice de leur historique `Git` qui, s'ils ont des versions sans `push` depuis longtemps peuvent avoir diverger fortement du dépôt maître. 

{{% /panel %}}



{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercice 10: gérer les conflits quand on travaille sur le même fichier**

Dans la continuité de l'exercice précédent, chaque personne va travailler sur les fichiers des autres membres de l'équipe.

1. Les deux ou trois développeurs ajoutent la ponctuation et les majuscules du fichier du premier développeur.
2. Ils sautent une ligne et ajoutent une phrase (pas tous la même).
3. Valider les résultats (`git add .` et `commit`) et faire un `push`
4. La personne la plus rapide n'a, normalement, rencontré aucune difficulté (elle peut s'arrêter temporairement pour regarder ce qui va se passer chez les voisins, en respectant la distanciation sociale :mask:). Les autres voient leur `push` refusé et doivent faire un `pull`. 

:boom: Il y a conflit, ce qui doit être signalé par un message du type:

~~~shell
Auto-merging XXXXXX
CONFLICT (content): Merge conflict in XXXXXX.md
Automatic merge failed; fix conflicts and then commit the result.
~~~

5. Etudier le résultat de `git status` 

6. Si vous ouvrez les fichiers incriminés, vous devriez voir des balises du type

~~~markdown
<<<<<<< HEAD
this is some content to mess with
content to append
=======
totally different content to merge later
>>>>>>> new_branch_to_merge_later
~~~

7. Corriger à la main les fichiers en choisissant, pour chaque ligne, la version qui vous convient et en retirant les balises. Valider en faisant: 

~~~shell
git add . && git commit -m "Résolution du conflit par XXXX"
~~~

Remplacer XXXX par votre nom. La balise `&&` permet d'enchaîner, en une seule ligne de code, les deux commandes.

8. Faire un push. Pour la dernière personne, refaire les opérations 4 à 8

{{% /panel %}}

`Git` permet donc de travailler, en même temps, sur le même fichier et de limiter le nombre de gestes manuels nécessaires pour faire la fusion. Lorsqu'on travaille sur des bouts différents du même fichier, on n'a même pas besoin de faire de modification manuelle, la fusion peut être automatique.

`Git` est un outil très puissant. Mais, il ne remplace pas une bonne organisation du travail. Vous l'avez vu, ce mode de travail uniquement sur `master` peut être pénible. Les branches prennent tout leur sens dans ce cas. 

{{% panel status="exercise" title="Exercice" icon="fas fa-pencil-alt" %}}

**Exercice 11: gestion des branches**

1. Le mainteneur va contribuer directement dans `master` et ne crée pas de branche. Chaque développeur crée une branche, en local nommée `contrib-XXXXX` où `XXXXX` est le prénom: 

~~~shell
git checkout -b contrib-XXXXX
~~~

2. Chaque membre du groupe crée un fichier `README.md` où il écrit une phrase sujet-verbe-complément. Le mainteneur est le seul à ajouter un titre dans le README (qu'il commit dans master).

3. Chacun push le produit de son subconscient sur le dépôt.

4. Les développeurs ouvrent, chacun, une `pull request` sur `Github` de leur branche vers `master`. Ils lui donnent un titre explicite. 

5. Dans la discussion de chaque `pull request`, le mainteneur demande au développeur d'intégrer le titre qu'il a écrit.  

6. Chaque développeur, en local, intègre cette modification en faisant

~~~shell
# Pour être sûr d'être sur sa propre branche
git checkout branche-XXXX
git merge master
~~~

Régler le conflit et valider (`add` et `commit`). Pousser le résultat. Le mainteneur choisit une des `pull request` et la valide avec l'option `squash commits`. Vérifier sur la page d'accueil le résultat.

7. L'auteur (si 2 développeurs)  ou les deux auteurs (si 3 développeurs) de la `pull request` non validée doivent à nouveau répéter l'opération 6. 

8. Une fois le conflit de version réglé et poussé, le mainteneur valide la `pull request` selon la même procédure que précedemment. 

9. Vérifier l'arborescence du dépôt dans `Insights > Network`. Votre arbre doit avoir une forme caractéristique de ce qu'on appelle le `Github flow`:

![](https://linogaliana.gitlab.io/collaboratif/pics/03_git/flow4_discuss.png)
{{% /panel %}}

{{% panel status="note" title="Note" icon="fa fa-comment" %}}
Les merges vers `master` doivent impérativement passer par `Github` (ou `Gitlab`). Cela permet de garder une trace explicite de ceux-ci (par exemple [ici](https://github.com/linogaliana/python-datascientist/pulls?q=is%3Apr+is%3Aclosed)), sans avoir à chercher dans l'arborescence, parfois complexe, d'un projet. La bonne pratique veut qu'on fasse un `squash commit` pour éviter une inflation du nombre de commits dans `master`: les branches ont vocation à proposer une multitude de petits commits, les modifications dans `master` doivent être simples à tracer d'où le fait de modifier des petits bouts de code. 

Le cas échéant, il est très pratique d’ajouter dans le corps du message  `close #xx` où `xx` est le numéro de l’issue décrivant la fonctionnalité que la MR implémente. Lorsque la MR sera fusionnée, l’issue sera automatiquement fermée et un lien sera créé entre l’issue et la MR. Cela vous permettra de comprendre, plusieurs mois ou années plus tard comment et pourquoi telle ou telle fonctionnalité a été implémentée.

L'intégration des dernières modifications de `master` vers une branche se fait en local. Si votre branche est en conflit, **le conflit doit être résolu dans la branche et pas dans master**. 
{{% /panel %}}

{{% panel status="hint" title="Hint" icon="fa fa-lightbulb" %}}
Vous devez savoir qu’il y a plusieurs méthodes de travail avec `Git` (*flow*, en anglais). Vous pourrez trouvez des dizaines d’articles et d’ouvrages sur ce sujet dont chacun prétend avoir trouvé la meilleure organisation du travail (`Git flow`, `GitHub flow`, `GitLab flow`…). Ne lisez pas trop ces livres et articles sinon vous serez perdus (un peu comme avec les magazines destinés aux jeunes parents...).

La méthode de travail la plus simple est le *Github flow* qu'on vous a proposé d'adopter. L'arborescence est reconnaissable: des branches divergent et reviennent systématiquement vers `master`. 

Pour des projets plus complexes dans des équipes développant des applications, on pourra utiliser d'autres méthodes de travail, notamment le `Git flow`. Il n'existe pas de règles universelles pour déterminer la méthode de travail ; l'important c'est, avant tout, de se mettre d'accord sur des règles communes de travail avec votre équipe.
{{% /panel %}}
