---
title: "Pratique de geopandas avec les donn√©es v√©lib"
date: 2020-07-09T13:00:00Z
draft: false
weight: 50
slug: geopandasTP
tags:
  - geopandas
  - Velib
  - Exercice
  - Cartographie
  - Manipulation
categories:
  - Manipulation
  - Exercice
type: book
summary: |
  Ce chapitre illustre les fonctionalit√©s de `GeoPandas` √† partir des
  d√©comptes de v√©lo fournis par la ville de Paris
  en [opendata](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/map/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name&basemap=jawg.dark&location=12,48.85855,2.33754).
  Il prolonge
  le chapitre pr√©c√©dent avec des donn√©es un petit peu plus complexes
  √† manipuler.
echo: false
---

::: {.cell .markdown}
```{python}
#| echo: false
#| output: 'asis'
#| include: true
#| eval: true

import sys
sys.path.insert(1, '../../../../') #insert the utils module
from utils import print_badges

#print_badges(__file__)
print_badges("content/course/manipulation/03_geopandas_TP.qmd")
```
:::

Installations pr√©alables : 

```{python}
#| echo: true
#| eval: false


!pip install pandas fiona shapely pyproj rtree # √† faire obligatoirement en premier pour utiliser rtree ou pygeos pour les jointures spatiales
!pip install contextily
!pip install geopandas
!pip install pygeos
```

Les instructions d'installation du package `cartiflette`
sont quant √† elles d√©taill√©es dans le chapitre
pr√©c√©dent.


```{python}
#| echo: true
#| output: false
import geopandas as gpd
```


# Lire et enrichir des donn√©es spatiales

Dans cette partie,
nous utiliserons
le package [`cartiflette`](https://github.com/InseeFrLab/cartiflette.git)
qui facilite la r√©cup√©ration de contours de cartes. 
Une version ant√©rieure de cet exercice, pr√©sent√©e sous forme
d'[exercice suppl√©mentaire üëáÔ∏è](#exo-supp), utilisait des fonds de carte issus
de `data.gouv`. 


```{python}
# 0) Chargement des packages utilis√©s dans la partie tutoriel
import geopandas as gpd
import contextily as ctx
import matplotlib.pyplot as plt
import cartiflette.s3
```

{{% box status="exercise" title="Exercice 1: lire et explorer la structure de fichiers g√©ographiques" icon="fas fa-pencil-alt" %}}
1. S'inspirer des exemples de code pr√©sents dans le chapitre pr√©c√©dent, mobilisant
le package `cartiflette`
pour t√©l√©charger les donn√©es communales des d√©partements 75, 92, 93 et 94.
Vous pouvez nommer l'objet `communes_borders`
2. Regarder les premi√®res lignes des donn√©es. Identifier la diff√©rence avec
un DataFrame standard. 
3. Afficher l'attribut `crs` de `communes_borders`. Ce dernier contr√¥le la
transformation de l'espace tridimensionnel terrestre en une surface plane.
Utiliser `to_crs` pour transformer les donn√©es en Lambert 93 (code EPSG 2154). 
4. Afficher les communes des Hauts de Seine (d√©partement 92) et utiliser la m√©thode
`plot`
5. R√©pr√©senter la carte de Paris : quel est le probl√®me ?
{{% /box %}}


```{python}
#1) Chargement des donn√©es de Cartiflette
communes_borders = cartiflette.s3.download_vectorfile_url_all(
    values = ["75", "92", "93", "94"],
    level="COMMUNE",
    vectorfile_format="geojson",
    decoupage="departement",
    year=2022)
```


```{python}
# 2) Regarder les premi√®res lignes
communes_borders.head()
# Il y a une colonne geometry qui contient les informations n√©cessaires pour conna√Ætre les contours communaux
```

```{python}
# 3) Afficher le crs
communes_borders.crs
# Les donn√©es sont en WGS84, on les reprojette en lambert 93
```

La carte du 92 est la suivante:

```{python}
# 4) afficher les communes du d√©partement 92
ax = communes_borders[communes_borders['INSEE_DEP'] == "92"].plot()
ax.set_axis_off()
```

Quant √† Paris, √† l'issue de la question 5, la carte
aura l'aspect suivant:

```{python}
# 5) Repr√©senter la carte de Paris. Quel est le probl√®me ?
ax = communes_borders[communes_borders['INSEE_DEP'] == "75"].plot()
ax.set_axis_off()
```


En effet, on ne dispose ainsi pas des limites des arrondissements parisiens, ce
qui appauvrit grandement la carte de Paris. 
On pourrait les r√©cup√©rer directement 
depuis le site d'_open-data_ du Grand Paris, ce qui est propos√©
en [exercice suppl√©mentaire üëáÔ∏è](#exo-supp).
On propose ici d'utiliser √† nouveau
`cartiflette` pour cela afin de disposer du fonds de carte officiel. 


{{% box status="exercise" title="Exercice 2: compl√©ter des donn√©es spatiales issues de sources diff√©rentes" icon="fas fa-pencil-alt" %}}


1. Importer les donn√©es de d√©coupage des arrondissements parisiens √† l'adresse √† l'aide de `cartiflette`.
2. V√©rifier sur une carte que les d√©coupages des arrondissements sont bien pr√©sents.
3. V√©rifier l'attribut `crs`. Est-il coh√©rent avec celui des donn√©es communales ?
Si non, transformer en Lambert 93 (code EPSG 2154).
4. Retirer Paris du jeu de donn√©es communales et utiliser les arrondissements
pour enrichir (nommer l'objet obtenu `data_borders`). 
5. Repr√©senter √† nouveau les communes de la petite couronne parisienne (75, 92, 93, 94)
{{% /box %}}

```{python}
#1) Importer arrondissements
arrondissements = cartiflette.s3.download_vectorfile_url_all(
    values = "75",
    level="ARRONDISSEMENT_MUNICIPAL",
    vectorfile_format="geojson",
    decoupage="departement",
    year=2022)
```

La carte de Paris intra-muros est, apr√®s la
r√©cup√©ration des arrondissements avec
`cartiflette` de ce type l√†:

```{python}
#2) V√©rifier pr√©sence arrondissements
ax = arrondissements.plot(alpha = 0.8, edgecolor = "k")
ax.set_axis_off()
```

```{python}
#3) V√©rifier l'attribut `crs`. Est-il coh√©rent ?
print(communes_borders.crs)
print(arrondissements.crs)
arrondissements = arrondissements.to_crs(2154)
print(communes_borders.crs == arrondissements.crs)
```

```{python}
#4) Retirer Paris et ajouter les arrondissements
import pandas as pd

data_paris = pd.concat(
  [
    communes_borders[communes_borders['INSEE_DEP'] != "75"].to_crs(2154),
    arrondissements.to_crs(2154)
  ])
```

La carte obtenue √† l'issue de la question 6, c'est-√†-dire apr√®s
avoir consolid√© les donn√©es, devrait avoir l'aspect suivant:

```{python}
#5) Repr√©senter les communes du 75, 92, 93, 94
ax = data_paris.plot(alpha = 0.3, edgecolor = "k")
ax.set_axis_off()
```

# Utiliser des donn√©es g√©ographiques comme des couches graphiques

Souvent, le d√©coupage communal ne sert qu'en fond de cartes, pour donner des
rep√®res. En compl√©ment de celui-ci, on peut d√©sirer exploiter
un autre jeu de donn√©es.

On va partir des donn√©es de localisation des
stations velib, 
disponibles [sur le site d'open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/table/) et 
requ√™tables directement par l'url
<https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr>

{{% box status="exercise" title="Exercice 3: importer et explorer les donn√©es velib" icon="fas fa-pencil-alt" %}}
1. Importer les donn√©es velib sous le nom `station`
2. V√©rifier la projection g√©ographique de `station` (attribut `crs`). Si celle-ci est diff√©rente des donn√©es communales, reprojeter ces
derni√®res dans le m√™me syst√®me de projection que les stations de v√©lib
3.  Repr√©senter sur une carte les 50 stations les plus importantes (variable `capacity`). Vous pouvez √©galement afficher le fonds de carte des arrondissements de Paris.
Cette [page](https://geopandas.org/mapping.html#maps-with-layers) peut vous aider pour comprendre comment afficher plusieurs couches √† la fois. Vous pouvez customiser la carte en retirant les axes gr√¢ce √† la m√©thode `set_axis_off` et mettre un titre tel que _"Les 50 principales stations de V√©lib"_ avec la m√©thode `set_title`. 
4. Afficher √©galement (trait bleu et √©pais) les r√©seaux de transport en communs, disponibles [ici](https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/map/?location=7,48.69717,2.33167&basemap=jawg.streets). L'url √† requ√™ter est
<https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/download/?format=geojson&timezone=Europe/Berlin&lang=fr>
{{% /box %}}



```{python}
# 1) Importer les donn√©es velib
url = "https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr"
stations = gpd.read_file(url)
stations.head()
```

```{python}
# 2) Reprojection
stations.crs
data_paris = data_paris.to_crs(stations.crs)
```

La carte attendu √† l'issue de la question 3 a l'aspect suivant:

```{python}
# 3) Carte des 50 stations les plus importantes. 
base = data_paris[data_paris['INSEE_DEP'] == '75'].plot(alpha = 0.2, edgecolor = 'black')
stations.sort_values('capacity', ascending = False).head(50).plot(ax = base, color = 'red', alpha = 0.6)
base.set_axis_off()
base.set_title("Les 50 principales stations de V√©lib")
```


```{python}
# 4) R√©seaux de transport en communs
url = "https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/download/?format=geojson&timezone=Europe/Berlin&lang=fr"
transports = gpd.read_file(url)
transports.head()
print(transports['mode'].unique())
```

L'ajout du r√©seau de m√©tro permet d'obtenir une carte ressemblant √† celle-ci:

```{python}
# 4) R√©seaux de transport en communs (suite)
base = data_paris[data_paris['INSEE_DEP'] == '75'].plot(alpha = 0.2, edgecolor = 'black')
stations.sort_values('capacity', ascending = False).head(50).plot(ax = base, color = 'red', alpha = 0.6)
transports[transports['mode'] == "METRO"].plot(ax=base, color = 'blue', alpha = 0.3,linewidth=3)
base.set_axis_off()
base.set_title("Les 50 principales stations de V√©lib")
```

Pour faire une belle carte, il faudrait couper les lignes de m√©tro via une jointure spatiale ou
utiliser un fonds de carte conceptuel. 
L'exercice suivant propose de mettre en oeuvre la deuxi√®me m√©thode. La premi√®re 
est propos√©e en [exercice suppl√©mentaire üëáÔ∏è](#exo-supp).


{{% box status="exercise" title="Exercice 4: ajouter un fond de carte" icon="fas fa-pencil-alt" %}}

1. Recr√©er par couche successive la carte pr√©c√©dente, que vous pouvez nommer `base`
2. Utiliser `add_basemap` du package [`contextily`](https://contextily.readthedocs.io/en/latest/)
pour ajouter, en arri√®re plan, un fonds de carte
3. Jouer avec les fonds disponibles en utilisant l'argument `source`
{{% /box  %}}

Par exemple, en utilisant le fond `Stamen.Watercolor`, on obtient la carte
suivante. Celle-ci permet d√©j√† de mieux localiser les stations.

```{python}
base = data_paris[data_paris['INSEE_DEP'] == '75'].to_crs(3857).plot(alpha = 0.2, edgecolor = 'black')
stations.sort_values('capacity', ascending = False).head(50).to_crs(3857).plot(ax = base, color = 'red', alpha = 0.6)
base.set_axis_off()
base.set_title("Les 50 principales stations de V√©lib")
ctx.add_basemap(base, source=ctx.providers.Stamen.Watercolor)
```



# Jointures spatiales

Les jointures attributaires fonctionnent comme avec un DataFrame `pandas`.
Pour conserver un objet spatial *in fine*, il faut faire attention √† utiliser en premier (base de gauche) l'objet `GeoPandas`.
En revanche, l'un des int√©r√™ts des objets geopandas est qu'on peut √©galement faire une jointure sur la dimension spatiale gr√¢ce √† `sjoin`.

La documentation √† laquelle se r√©f√©rer est [ici](https://geopandas.org/mergingdata.html#spatial-joins). 

{{% box status="exercise" title="Exercice 5 : Associer les stations aux communes et arrondissements auxquels elles appartiennent" icon="fas fa-pencil-alt" %}}
1. Faire une jointure spatiale pour enrichir les donn√©es de stations en y ajoutant des informations de `data_paris`. Appeler cet objet `stations_info`
2. Repr√©senter la carte des stations du 19e arrondissement (s'aider de la variable `c_ar`). Vous pouvez mettre en fond de carte les arrondissements parisiens. 
3. Compter le nombre de stations velib et le nombre de places velib par arrondissement ou commune (pour vous aider, vous pouvez compl√©ter vos connaissances avec [ce tutoriel](https://pandas.pydata.org/docs/getting_started/intro_tutorials/06_calculate_statistics.html)). Repr√©senter sur une carte chacune des informations
4. Repr√©senter les m√™mes informations mais en densit√© (diviser par la surface de l'arrondissement ou commune en km2)
5. (optionnel) Choisir une des cartes de densit√© et la nettoyer (retirer les axes, mettre les titres...)
{{% /box %}}


```{python}
#1.  Jointure spatiale entre stations et data_paris
stations_info = gpd.sjoin(stations, data_paris, predicate = 'within')
stations_info.head()
```

Pour la question 2,
la premi√®re m√©thode consiste √† afficher
toute la ville mais √† ne repr√©senter que
les points des stations du 19e:

```{python}
#2. Carte des stations du 19e arrondissement
# M√©thode 1 : En affichant tout Paris
base = data_paris[data_paris['INSEE_DEP'] == "75"].plot(alpha = 0.2, edgecolor = 'k') #fond de carte des arrondissements
stations_19 = stations_info.loc[stations_info['NOM'].str.contains("19e")]
stations_19.plot(ax = base, color = 'red', alpha = 0.6) # stations du 19e
```

N√©anmoins, il est pr√©f√©rable de se centrer sur 
le 19e en premier lieu, ce qui donne une
carte comme celle-ci:

```{python}
# M√©thode 2 : En affichant seulement le 19e
base = data_paris[data_paris['NOM'].str.contains("19e")].to_crs(3857).plot(alpha = 0.2, edgecolor = 'k') #fond de carte du 19e
stations_info[stations_info['NOM'].str.contains("19e")].to_crs(3857).plot(ax = base, color = 'red', alpha = 0.6) #stations du 19e
ctx.add_basemap(base, source=ctx.providers.Stamen.Toner)
```



```{python}
#3. Nombre de stations et de places v√©lib par arrondissement
stations_agg = stations_info.groupby('NOM').agg({'stationcode': 'nunique',
                                   'capacity': 'sum'}).reset_index()
stations_agg.head()
df = data_paris.merge(stations_agg, how = 'inner')
df.head()
```

La carte des places disponibles est celle-ci:

```{python}
#3. Nombre de stations et de places v√©lib par arrondissement
ax = df.plot(column = 'capacity', legend=True)
ax.set_axis_off()
ax.set_title("Nombre de places disponibles")
```

Alors que la carte des capacit√©s de stations est
plut√¥t celle-l√†:

```{python}
#3. Nombre de stations et de places v√©lib par arrondissement
ax = df.plot(column = 'stationcode', legend=True)
ax.set_axis_off()
ax.set_title("Nombre de stations")
```

Pas vraiment de diff√©rence marqu√©e entre les
deux, on peut se contenter de regarder la capacit√©.

Enfin, dans la question 4,
si on repr√©sente plut√¥t la capacit√© 
sous forme de densit√©, pour tenir compte
de la taille diff√©rente des arrondissements,
on obtient cette carte:

```{python}
#4. En densit√©
cols = ['stationcode','capacity']
df[[s + '_density' for s in cols]] = df[cols].div(df.to_crs(2158).area*10**(-6), axis = 0)
df.plot(column = 'capacity_density', cmap = 'RdYlBu_r', legend=True)
```

Avec une palette `plasma_r`, cela donne plut√¥t cette carte:

```{python}
#4. En densit√©
df.plot(column = 'capacity_density', cmap = 'plasma_r', legend=True)
```

Avec un peu de travail sur l'esth√©tique, la carte
que vous obtenez √† l'issue de l'exercice
ressemble √† celle-ci:

```{python}
#| output: false
# 5 Cartes nettoy√©es
ax = df.plot(column = 'capacity_density', cmap = 'RdYlBu_r', legend=True, legend_kwds={"orientation": "horizontal", "pad": 0.01}) 
ax.set_axis_off()
ax.set_title("Densit√© des stations v√©lib dans l'agglom√©ration parisienne")
```

```{python}
ax.get_figure()
```

```{python}
#| echo: false
#| output: false
fig = ax.get_figure()
fig.savefig("featured.png")
```

# Trouver les toilettes publiques les plus proches

## Objectif

Jusqu'√† pr√©sent, nous nous sommes familiaris√©s avec
la manipulation de donn√©es spatiales et la repr√©sentation
rapide de celle-ci gr√¢ce aux fonctionalit√©s de `GeoPandas`.

A partir de maintenant, nous allons utiliser `GeoPandas` 
pour des t√¢ches de manipulation g√©om√©trique.  
Ces op√©rations reposeront sur des t√¢ches classiques
de la g√©omatique qui sont facilit√©es par le fait que
`GeoPandas` offre une surcouche au package `Shapely` 
de la m√™me mani√®re que `Pandas` √©tait une sur-couche
de `Numpy` pour les op√©rations num√©riques.

L'exemple suivant permet d'illustrer 
le principe d'une des
op√©rations que nous allons utiliser,
√† savoir la recherche de plus proche point:

```{python}
#| echo: true

from shapely.ops import Polygon
from shapely.ops import nearest_points
triangle = Polygon([(0, 0), (1, 0), (0.5, 1), (0, 0)])
square = Polygon([(0, 2), (1, 2), (1, 3), (0, 3), (0, 2)])
[o.wkt for o in nearest_points(triangle, square)]
```

`GeoPandas` va permettre de g√©n√©raliser ce processus
en utilisant non plus deux listes modifi√©es (les
polygones de `Shapely`) mais des `DataFrames` g√©ographiques.
Cela permettra, au passage, d'enrichir les 
jointures spatiales avec les attributs des `DataFrames`
concern√©s. 

Sur `Shapely`, vous pourrez trouver une aide [ici](https://pysal.org/scipy2019-intermediate-gds/deterministic/gds1-relations.html#how-about-nearest-neighbor-joins).
N√©anmoins, √† mesure que `GeoPandas` se d√©veloppe, il 
devient de moins en moins n√©cessaire d'utiliser directement
`Shapely`. 

## Mise en application

Nous allons rechercher les toilettes publiques les 
plus proches de chaque station. 
Sans les fonctionalit√©s de `GeoPandas`,
cette recherche serait assez p√©nible. 

{{% box status="exercise" title="Exercice 5 (optionnel) : Trouver les toilettes publiques les plus proches d'une station de v√©lib" icon="fas fa-pencil-alt" %}}
1. Charger la localisation des toilettes publiques pr√©sente ici : https://data.ratp.fr/explore/dataset/sanitaires-reseau-ratp/download/?format=geojson&timezone=Europe/Berlin&lang=fr. Appelez-la `toilettes_publiques`.
2. Convertir les objets `toilettes_publiques` et `stations` en projection Lambert-93 (CRS 2154). Cette
conversion permettra de mesurer en m√®tres les distances entre objets g√©ographiques. Sans
celle-ci, nous ferions des distances entre coordonn√©es GPS, ce qui n'aide pas l'analyse
et l'interpr√©tation. 
3. Utiliser la jointure spatiale par plus proche distance `sjoin_nearest` pour associer √† chaque station les toilettes publiques les plus proches
4. Trouver les toilettes publiques les plus proches des stations de v√©lib autour d'Edgard Quinet.
5. Repr√©senter un histogramme des distances aux toilettes les plus proches
{{% /box %}}

Le jeu de donn√©es _open-data_ des toilettes 
publiques pr√©sente l'aspect suivant:

```{python}
# 1. Charger les localisations des toilettes
toilettes_publiques = gpd.read_file("https://data.ratp.fr/explore/dataset/sanitaires-reseau-ratp/download/?format=geojson&timezone=Europe/Berlin&lang=fr")
toilettes_publiques.head(2)
```


```{python}
#2. Conversion des CRS
toilettes_publiques = toilettes_publiques.to_crs(2154)
stations = stations.to_crs(2154)
```

Les toilettes les plus proches 
d'Edgar Quinet sont les suivantes:

```{python}
# 3. Jointure spatiale
stations_toilettes = stations.sjoin_nearest(
  toilettes_publiques,
  how='inner',
  distance_col="distance")


# 4. Trouver les toilettes les plus proches d'Edgard Quinet
stations_toilettes.loc[
  stations_toilettes['name'].str.contains("Edgar Quinet"),
  ["localisation", "station","name","distance"]]
```

Il va donc falloir se
retenir un peu car s'agit de toilettes situ√©es
√† la station Denfert Rochereau !

Enfin, de mani√®re plus globale, voici la distribution
des distances aux toilettes les plus proches:

```{python}
#5. Histogramme
stations_toilettes['distance'].plot(kind = "hist")
```

Le mode de la distribution est entre 1 et 2 km, ce
qui est une petite distance tout de m√™me !
C'est normal, il ne s'agit pas de l'ensemble des
toilettes publiques de la ville de Paris mais
de celles g√©r√©es par la RATP. Rassurez-vous, au 
moins dans Paris intra-muros, vous n'avez pas
√† syst√©matiquement marcher (ou rouler) autant. 


# Exercices suppl√©mentaires {#exo-supp}

Voici une fonction pour t√©l√©charger et d√©zipper
facilement un fonds de carte issu de `data.gouv`

```{python}
#| echo: true
#| include: true

import requests
import tempfile
import zipfile

temporary_location = tempfile.gettempdir()

def download_unzip(url, dirname = tempfile.gettempdir(), destname = "borders"):
  myfile = requests.get(url)
  open("{}/{}.zip".format(dirname, destname), 'wb').write(myfile.content)
  with zipfile.ZipFile("{}/{}.zip".format(dirname, destname), 'r') as zip_ref:
      zip_ref.extractall(dirname + '/' + destname)
```

{{% box status="exercise" title="Exercice optionnel 1: t√©l√©charger et d√©zipper vous-m√™me le fonds de carte" icon="fas fa-pencil-alt" %}}

Importer le fichier avec le package `GeoPandas`
(si vous avez laiss√© les param√®tres par d√©faut,
le fichier devrait
√™tre √† l'emplacement `temporary_location + "/borders/communes-20210101.shp"`).

{{% /box %}}


```{python}
#| eval: false

# 1) t√©l√©charger les donn√©es communales
url = "https://www.data.gouv.fr/fr/datasets/r/0e117c06-248f-45e5-8945-0e79d9136165"
download_unzip(url)
```

```{python}
#| eval: false

# 2) Importer le fichier
#communes_borders = gpd.read_file(temporary_location + "/borders/communes-20220101.shp")
```

{{% box status="exercise" title="Exercice optionnel 2 : Utiliser les arrondissements fournis par l'open data parisien" icon="fas fa-pencil-alt" %}}

1. Importer les donn√©es de d√©coupage des arrondissements parisiens √† l'adresse
<https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr>
2. V√©rifier sur une carte que les d√©coupages des arrondissements sont bien pr√©sents.
3. V√©rifier l'attribut `crs`. Est-il coh√©rent avec celui des donn√©es communales ?
4. Retirer Paris du jeu de donn√©es communales et utiliser les arrondissements
pour enrichir (nommer l'objet obtenu `data_borders`). Ici, on peut ne pas se
soucier de la variable commune de superficie aux niveaux diff√©rents car on
va la recr√©er. En revanche, renommer la variable `c_arinsee` en `insee` avec
la m√©thode `rename` et faire attention aux types des variables

{{% /box %}}


```{python}
#1) Importer arrondissements
arrondissements = gpd.read_file("https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr")
arrondissements = arrondissements.to_crs(2154)
```


```{python}
#2) V√©rifier pr√©sence arrondissements
arrondissements.plot()
```

```{python}
#3) V√©rifier l'attribut `crs`. Est-il coh√©rent ?
print(communes_borders.crs)
print(communes_borders.crs == arrondissements.crs)
# Oui, les deux fonds de carte ont le m√™me attribut CRS, pas besoin de convertir les projections de l'une d'entre elles
```



```{python}
#4) Retirer Paris et ajouter les arrondissements
## On fait en sorte que les colonnes de arrondissements soient les m√™mes que celles de communes borders
arrondissements = arrondissements.rename(columns = {"c_arinsee": "INSEE_DEP"})
arrondissements['INSEE_DEP'] = "75"
# On s√©lectionne enl√®ve la ligne du contour de Paris initiale, et on ajoute √† la place les lignes d'arrondissements
data_paris = communes_borders[
  communes_borders["INSEE_DEP"] != "75"].to_crs(2154).append(arrondissements.to_crs(2154))
data_paris.tail(2)
```



## Jointures spatiales

L'objectif de cet exercice est de ne conserver que les 
lignes de transports √† l'int√©rieur de Paris intra-muros.
Il s'agit d'appliquer les jointures spatiales de mani√®re
un petit peu diff√©rente √† pr√©c√©demment.

{{% box status="exercise" title="Exercice optionnel 3 : Les lignes de transport dans Paris" icon="fas fa-pencil-alt" %}}

1. Utiliser l'URL <https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/download/?format=geojson&timezone=Europe/Berlin&lang=fr> pour r√©cup√©rer les lignes de transport
de la RATP. L'appeler `transports`.
2. A partir des arrondissements parisiens, utiliser `unary_union` pour cr√©er un unique polygone parisien. Utiliser `within` pour ne conserver que les points de `transports` qui se trouvent
dans Paris intra-muros
3. Repr√©senter graphiquement
{{% /box %}}


```{python}
url = "https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/download/?format=geojson&timezone=Europe/Berlin&lang=fr"
transports = gpd.read_file(url)
```

```{python}
#2)
paris = data_paris.loc[data_paris['INSEE_DEP']=="75"].geometry.unary_union
transports_paris = transports[transports.geometry.within(paris)]
```

La carte obtenue aura l'aspect suivant:

```{python}
base = data_paris[data_paris['INSEE_DEP'] == '75'].plot(alpha = 0.2, edgecolor = 'black')
transports_paris.plot(ax=base, column='mode', alpha = 0.9, linewidth=3)
```

Cette fois, on a bien conserv√© que les lignes de transport dans 
Paris. Un peu de travail sur le rendu serait n√©cessaire pour
obtenir une belle carte. Vous pouvez le faire en exercice, apr√®s
avoir consult√© le chapitre relatif √† la cartographie dans
la partie visualisation de donn√©es. 
