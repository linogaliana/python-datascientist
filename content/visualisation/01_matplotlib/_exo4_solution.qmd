::::: {.content-visible when-profile="fr"}
Pour cet exercice, nous proposons une correction guidée pas à pas permettant d'illustrer la logique de la grammaire des graphiques.

:::: {.content-visible when-format="ipynb"}

::: {.callout-important}
Pour une mise en forme plus ergonomique de la construction de ce graphique pas à pas, vous pouvez consulter la version web de ce _notebook_ et utiliser celui-ci pour répliquer vous même les figures.
:::

::::

:::::

::::: {.content-visible when-profile="en"}
For this exercise, we offer a step-by-step guided correction to illustrate the logic behind the grammar of graphs.

:::: {.content-visible when-format="ipynb"}

::: {.callout-important}
For a more user-friendly layout of the step-by-step construction of this graph, you can consult the web version of this notebook and use it to replicate the figures yourself.
:::

::::

:::::

::: {.content-visible when-profile="fr"}
## La trame de la figure: `ggplot()`

La première étape de toute figure consiste à définir l'objet du graphique, c'est-à-dire les données qui seront visuellement représentées. Cela passe par la déclaration `ggplot` avec les paramètres suivants:

* Le `DataFrame`, premier paramètre de tout appel à `ggplot`. 
* Les principaux paramètres esthétiques variables - qui s'insèrent dans `aes` (_aesthetics_) - qui seront communs aux différentes couches. En l'occurrence nous n'avons que les axes à déclarer mais nous pourrions, selon la nature du graphique, avoir d'autres eshtétiques dont le comportement serait contrôlé par une variable de notre jeu de données : couleur, taille des points, largeur de la courbe, transparence, etc.

```{python}
#| column: margin
#| echo: true
#| label: fig-gg1-fr
#| fig-cap: La trame de base
ggplot(df1, aes(x="nom_compteur", y="sum_counts"))
```

Cela nous donne la structure du graphique dans laquelle vont s'insérer tous les éléments ultérieurs. Concernant les $x$ et $y$ choisis, cette déclaration permettra de définir un diagramme en barre (_barplot_) vertical. Nous verrons ensuite que nous allons renverser les axes pour le rendre plus lisible mais cela viendra plus tard. 
:::

::: {.content-visible when-profile="en"}
## The plot grid: `ggplot()`

The first step in any figure is to define the object of the graph, i.e. the data that will be visually represented. This is done using the `ggplot` statement with the following parameters:

* The `DataFrame`, the first parameter of any call to `ggplot`.
* The main variable aesthetic parameters - which are inserted into `aes` (**aes**thetics) - which will be common to the different layers. In this case, we only have the axes to declare, but depending on the nature of the graph, we could have other aesthetics whose behaviour would be controlled by a variable in our dataset: colour, point size, curve width, transparency, etc.

```{python}
#| column: margin
#| echo: true
#| label: fig-gg1-en
#| fig-cap: The plot grid
ggplot(df1, aes(x="nom_compteur", y="sum_counts"))
```

This gives us the structure of the graph into which all subsequent elements will be inserted. Regarding the chosen $x$ and $y$, this declaration will define a vertical bar plot. We will then see that we are going to reverse the axes to make it more readable, but that will come later.

:::

::: {.content-visible when-profile="fr"}
## Ajouter les géométries: `geom_*`

Les couches graphiques sont définies par la famille des fonctions `geom_` selon une logique additive (d'où le `+`). Le contrôle de celles-ci se fait à deux niveaux:

* Dans les paramètres définis par `aes` soit au niveau global (`ggplot`) soit au niveau spécifique à la géométrie en question (dans l'appel à `geom_`)
* Dans les paramètres constants qui s'appliquent uniformément à la couche, définis comme des paramètres constants

```{python}
#| column: margin
#| echo: true
#| label: fig-gg2-fr
#| fig-cap: La première couche de géométrie (bar)
(
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_bar(stat="identity", fill="red")
)
```

On peut ajouter plusieurs couches successives. Par exemple, les valeurs numériques affichées pour donner du contexte peuvent être créées à partir de `geom_text` dont le positionnement sur la figure est géré par les mêmes paramètres que les autres couches:

```{python}
#| column: margin
#| echo: true
#| label: fig-gg3-fr
#| fig-cap: La seconde couche de géométrie (texte)
df1["text"] = df1["sum_counts"].round().astype(int).astype(str)

(
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_bar(stat="identity", fill="red") +
    geom_text(aes(label = "text"), position=position_nudge(y=30)) #<1>
)
```
1. Ce paramètre de `position` est inutile, voire gênant, pour le moment. Mais il nous servira ultérieurement à décaler le label (cf. [documentation de `plotnine` {{< fa arrow-up-right-from-square >}}](https://plotnine.org/guide/position-adjustments.html){target="_blank"}) quand nous aurons inversé les axes.

:::

::: {.content-visible when-profile="en"}

## Add geometries: `geom_*`

Graphical layers are defined by the `geom_` family of functions according to an additive logic (hence the `+`). These are controlled on two levels:

* In the parameters defined by `aes`, either at the global level (`ggplot`) or at the level specific to the geometry in question (in the call to `geom_`)
* In the constant parameters that apply uniformly to the layer, defined as constant parameters


```{python}
#| column: margin
#| echo: true
#| label: fig-gg2-en
#| fig-cap: First geometry layer (bar)
(
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_bar(stat="identity", fill="red")
)
```

You can add several successive layers. For example, the numerical values displayed to provide context can be created using `geom_text`, whose positioning on the figure is managed by the same parameters as the other layers:

```{python}
#| column: margin
#| echo: true
#| label: fig-gg3-en
#| fig-cap: La seconde couche de géométrie (texte)
df1["text"] = df1["sum_counts"].round().astype(int).astype(str)

(
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_bar(stat="identity", fill="red") +
    geom_text(aes(label = "text"), position=position_nudge(y=30)) #<1>
)
```
1. This `position` parameter is unnecessary, even annoying, right now. But we will use it later to shift the label (see [plotnine documentation {{< fa arrow-up-right-from-square >}}](https://plotnine.org/guide/position-adjustments.html){target=‘_blank’}) when we have reversed the axes.


:::

::: {.content-visible when-profile="fr"}
## Modifier les échelles: `scale_*`

L'harmonisation des déclarations d'éléments visuels permise par la grammaire des graphiques se fait avec les géométries `geom_*`. Il est donc logique que le contrôle de leur comportement se fasse aussi de manière uniformisée, par le biais d'une autre famille de fonctions: les `scale_`  (`scale_x_discrete`, `scale_x_continuous`, `scale_color_discrete`...). 

Ainsi, chaque esthétique (`x`, `y`, `color`, `fill`, `size`, etc.) peut être finement paramétrée de manière systématique via sa propre échelle (`scale_*`). Ceci offre un contrôle quasi total sur la traduction visuelle des données.

On peut aussi ranger dans cette catégorie les fonctions de la famille `coord_*` qui modifient le système de coordonnées. En l'occurrence, on va se servir de `coord_flip` pour avoir un diagramme en barre verticales.  

```{python}
#| column: margin
#| echo: true
#| label: fig-gg4-fr
#| fig-cap: L'échelle de notre graphique
(
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_bar(stat="identity", fill="red") +
    geom_text(aes(label = "text"), position=position_nudge(y=30)) +
    scale_y_continuous(expand=(0, 40)) +
    coord_flip()
)
```

Ici on a peu de paramètres à modifier puisque nos échelles nous conviennent déjà bien (on a pas à utiliser le _log_ pour compresser l'échelle, à appliquer une palette de couleurs...). On va juste aggrandir un peu l'axe des $x$ pour pouvoir rentrer nos valeurs numériques. Comme avant d'échanger les coordonnées avec `coord_flip` l'axe en question est $y$, on va donc jouer avec `scale_y_continuous`.
:::

::: {.content-visible when-profile="en"}
The harmonisation of visual element declarations enabled by the graphics grammar is achieved using `geom_*` geometries. It is therefore logical that their behaviour should also be controlled in a standardised manner, using another family of functions: `scale_`  (`scale_x_discrete`, `scale_x_continuous`, `scale_color_discrete`, etc.). 

Thus, each aesthetic (`x`, `y`, `colour`, `fill`, `size`, etc.) can be finely tuned in a systematic way via its own scale (`scale_*`). This offers almost total control over the visual translation of the data.

The functions of the `coord_*` family, which modify the coordinate system, can also be included in this category. In this case, we will use `coord_flip` to obtain a vertical bar chart.

```{python}
#| column: margin
#| echo: true
#| label: fig-gg4-en
#| fig-cap: Figure scale
(
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_bar(stat="identity", fill="red") +
    geom_text(aes(label = "text"), position=position_nudge(y=30)) +
    scale_y_continuous(expand=(0, 40)) +
    coord_flip()
)
```

Here, there are few parameters to modify since our scales already suit us well (we don't have to use _log_ to compress the scale, apply a colour palette, etc.). We'll just enlarge the $x$ axis a little so we can enter our numerical values. As before, when swapping coordinates with `coord_flip`, the axis in question is $y$, so we'll play around with `scale_y_continuous`.
:::


::: {.content-visible when-profile="fr"}
## Les labels et les thèmes

La fin de la déclaration de notre figure se fait à travers les éléments de forme que sont les labels (axes, titres, notes de lecture...) et le thème (préconfiguré à travers la famille `theme_` ou personnalisé avec les paramètres de la fonction `theme`). Avant cela, réduisons la taille de nos labels de $y$ 
:::

::: {.content-visible when-profile="en"}
## Labels and themes

The final declaration of our figure is done using the formal elements that are labels (axes, titles, reading notes, etc.) and the theme (preconfigured through the `theme_` family or customised with the parameters of the `theme` function). Before that, let's reduce the size of our labels by $y$
:::

```{python}
#| echo: true
import textwrap

def wrap_label(s, width=30):
    return '\n'.join(textwrap.wrap(s, width=width))

df1["nom_compteur"] = df1["nom_compteur"].apply(wrap_label)
```

::: {.content-visible when-profile="fr"}
On peut maintenant personnaliser notre figure:
:::

::: {.content-visible when-profile="en"}
We can now customise our figure:
:::

```{python}
#| label: fig-gg5-fr-showed
#| output: false
#| echo: true

p = ( 
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_bar(stat="identity", fill="red") +
    geom_text(aes(label = "text"), position=position_nudge(y=30)) +
    scale_y_continuous(expand=(0, 40)) +
    coord_flip() +
    labs(
        title=title,
        x=xaxis,
        y=yaxis
    ) +
    theme(
        panel_background=element_rect(fill="white"),
        line=element_line(color="white"),
        axis_text_x=element_text(angle=45, hjust=1, color="red"),
        axis_title_x=element_text(color="red"),
    )
)

p
```


::::: {.content-visible when-format="html"}

:::: {#fig-finale-ggplot}

```{python}
#| label: gg5-fr-dual
#| renderings: [light, dark]
#| message: false
#| warning: false

p.show()

( 
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_bar(stat="identity", fill="red") +
    geom_text(aes(label = "text"), position=position_nudge(y=30), color = "white") +
    scale_y_continuous(expand=(0, 40)) +
    coord_flip() +
    labs(
        title=title,
        x=xaxis,
        y=yaxis
    ) +
    theme(
        plot_background=element_rect(fill="black"),
        panel_background=element_rect(fill="black"),
        line=element_line(color="black"),
        axis_text_x=element_text(color="white"),
        axis_title_x=element_text(color="white"),
        text=element_text(color="white")
    )
)
```

::: {.content-visible when-profile="fr"}
Les compteurs parisiens où le volume de cycliste est le plus important.
::: 

::: {.content-visible when-profile="en"}
The Parisian bikemeters with the highest volume of cyclists.
:::

::::

:::::

::: {.content-visible when-profile="fr"}
Bien que rapide, cette plongée dans l'univers de la grammaire des graphiques de ggplot montre à quel point celle-ci est intuitive - lorsqu'on comprend sa logique - et puissante. 
:::

::: {.content-visible when-profile="en"}
Although brief, this introduction to the world of ggplot graphics grammar shows just how intuitive - once you understand its logic - and powerful it is.
:::