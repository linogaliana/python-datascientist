---
title: "Construire des graphiques avec Python"
title-en: "Building graphics with Python"
author: Lino Galiana
categories:
    - Visualisation
    - Exercice
description: |
    Une partie essentielle du travail du  _data scientist_ est d'être en mesure de synthétiser une information dans des représentations graphiques percutantes. Ce chapitre permet de découvrir les enjeux de la représentation de données avec `Python`, l'écosystème pour faire ceci. Il ouvre également à la représentation interactive de données avec `Plotly`.
description-en: |
    An essential part of the _data scientist's_ job is to be able to synthesize information into powerful graphical representations. This chapter looks at the challenges of data representation with `Python`, the ecosystem for doing this. It also opens the door to interactive data representation with `Plotly`.
image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/drawing.png
echo: false
bibliography: ../../reference.bib
---

{{< badges
    printMessage="true"
>}}

:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Compétences à l'issue de ce chapitre

* Découvrir l'écosystème [`matplotlib`](https://matplotlib.org/) et
[`seaborn`](https://seaborn.pydata.org/) pour la construction de graphiques par enrichissement successif de couches.
* Découvrir le récent écosystème [`plotnine`](https://plotnine.readthedocs.io/en/stable/index.html),
qui est une implémentation en `Python` du _package_ `R` [`ggplot2`](https://ggplot2.tidyverse.org/)
pour ce type de représentation et qui, grâce à sa grammaire des graphiques, offre une syntaxe puissante pour construire des visualisations de données.
* Découvrir le principe des représentations interactives HTML (format _web_) grâce aux packages [`plotly`](https://plotly.com/python/) et [`altair`](https://altair-viz.github.io/).
* Apprendre les enjeux de la représentation graphique, les compromis nécessaires pour construire un message clair et les limites de certaines représentations classiques.

:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## What you will learn in this chapter  

* Get to know the [`matplotlib`](https://matplotlib.org/) and [`seaborn`](https://seaborn.pydata.org/) ecosystems, and learn how to build charts by progressively layering elements.
* Explore the modern [`plotnine`](https://plotnine.readthedocs.io/en/stable/index.html) library — a `Python` implementation of `R`'s [`ggplot2`](https://ggplot2.tidyverse.org/) — which provides a powerful grammar of graphics for constructing visualizations.
* Understand how to create interactive, web-based visualizations using the [`plotly`](https://plotly.com/python/) and [`altair`](https://altair-viz.github.io/) packages.
* Learn about the key principles of effective data visualization, including the trade-offs involved in delivering a clear message and the limitations of some traditional chart types.

:::

::::

{{< include "./01_matplotlib/_intro.qmd" >}}

{{< include "_prepare_data_bike.qmd" >}}


::: {.content-visible when-profile="fr"}
# Premières productions graphiques avec l'API `Matplotlib` de `Pandas`

Chercher à produire une visualisation parfaite du premier coup est illusoire. Il est beaucoup plus réaliste d'améliorer graduellement une représentation graphique afin, petit à petit, de mettre en avant les effets de structure dans un jeu de données.

Nous allons donc commencer par nous représenter la distribution des passages aux principales stations de mesure. Pour cela nous allons produire rapidement un _barplot_ puis l'améliorer graduellement.

Dans cette partie, nous allons ainsi reproduire les deux premiers graphiques de la [page d'analyse des données {{< fa arrow-up-right-from-square >}}](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name){target="_blank"} : *Les 10 compteurs avec la moyenne horaire la plus élevée* et *Les 10 compteurs ayant comptabilisé le plus de vélos*. Les valeurs chiffrées des graphiques peuvent être différentes de celles de la page en ligne, c'est normal, car nous ne travaillons pas systématiquement sur les données ayant la même fraîcheur que celles en ligne.


:::

::: {.content-visible when-profile="en"}
# Initial Graphical Productions with `Pandas`' `Matplotlib` API

Trying to produce a perfect visualization on the first attempt is unrealistic. It is much more practical to gradually improve a graphical representation to progressively highlight structural effects in a dataset.

We will begin by visualizing the distribution of bicycle counts at the main measurement stations. To do this, we will quickly create a _barplot_ and then improve it step by step.

In this section, we will reproduce the first two charts from the [data analysis page {{< fa arrow-up-right-from-square >}}](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name){target="_blank"}: *The 10 counters with the highest hourly average* and *The 10 counters that recorded the most bicycles*. The numerical values of the charts may differ from those on the webpage, which is expected, as we are not necessarily working with data as up-to-date as that online.



:::


{{< include "./01_matplotlib/_matplotlib_principle.qmd" >}}



::: {.content-visible when-profile="fr"}
## Découvrir `matplotlib` par l'intermédiaire de `Pandas`
:::

::: {.content-visible when-profile="en"}
## Discovering `matplotlib` through `Pandas`
:::


{{< include "01_matplotlib/_exo1.qmd" >}}

{{< include "01_matplotlib/_exo1_solution.qmd" >}}

::: {.content-visible when-profile="fr"}
On commence à avoir quelque chose qui transmet un message synthétique sur la nature des données. En l'occurrence, le message qu'on désire faire passer dans cette visualisation est la hiérarchie relative d'usage des stations. 

On peut néanmoins remarquer plusieurs éléments problématiques (par exemple les labels) mais aussi des éléments ne correspondant pas (les titres des axes, etc.) ou manquants (le nom du graphique...). La figure est encore brute de décoffrage.

Comme les graphiques produits par `Pandas` suivent la logique très flexible de `matplotlib`, il est possible de les customiser. Cependant, cela demande généralement beaucoup de travail et la grammaire `matplotlib` n'est pas aussi normalisée et intuitive que celle de [`ggplot` {{< fa arrow-up-right-from-square >}}](https://ggplot2.tidyverse.org/) en `R`. Si on désire rester dans l'écosystème `matplotlib`, il est préférable de directement utiliser [`seaborn` {{< fa arrow-up-right-from-square >}}](https://seaborn.pydata.org/), qui offre quelques arguments prêts à l'emploi. Sinon on peut basculer, comme nous le ferons, sur l'écosystème [`plotnine` {{< fa arrow-up-right-from-square >}}](https://plotnine.org/) qui offrira la syntaxe normalisée de `ggplot` pour modifier les différents éléments de notre figure.
:::

::: {.content-visible when-profile="en"}
Our visualization starts to communicate a concise message about the nature of the data. In this case, the intended message is the relative hierarchy of station usage.  

Nevertheless, several issues remain. Some elements are problematic (for example, labels), others are inconsistent (such as axis titles), and still others are missing altogether (including the title of the graph). This figure remains somewhat unfinished.  

Since the graphs produced by `Pandas` are based on the highly flexible logic of `matplotlib`, they can be customized extensively. However, this often requires considerable effort, as the `matplotlib` grammar is neither as standardized nor as intuitive as that of [`ggplot` {{< fa arrow-up-right-from-square >}}](https://ggplot2.tidyverse.org/) in `R`. For those wishing to remain within the `matplotlib` ecosystem, it is generally preferable to use [`seaborn` {{< fa arrow-up-right-from-square >}}](https://seaborn.pydata.org/) directly, as it provides several ready-to-use options. Alternatively, one can turn, as we shall do here, to the [`plotnine` {{< fa arrow-up-right-from-square >}}](https://plotnine.org/) ecosystem, which offers the standardized `ggplot` syntax for modifying the various elements of a figure.
:::



{{< include "01_matplotlib/_seaborn.qmd" >}}

{{< include "01_matplotlib/_exo2.qmd" >}}
{{< include "01_matplotlib/_exo2_solution.qmd" >}}


::: {.content-visible when-profile="fr"}
On comprend ainsi que le boulevard de Sébastopol est le plus emprunté, ce qui ne vous surprendra pas si vous faites du vélo à Paris. Néanmoins, si vous n'êtes pas familiers avec la géographie parisienne, cela sera peu informatif pour vous, vous allez avoir besoin d'une représentation graphique supplémentaire : une carte ! Nous verrons ceci lors d'un prochain chapitre.
:::

::: {.content-visible when-profile="en"}
This shows that Boulevard de Sébastopol is the most traveled, which won't surprise you if you cycle in Paris. However, if you're not familiar with Parisian geography, this will provide little information for you. You'll need an additional graphical representation: a map! We will cover this in a future chapter.
:::



::: {.content-visible when-profile="fr"}
# Découvrir `Plotnine`, la grammaire des graphiques en `Python`

`plotnine` est le nouveau venu dans l'écosystème de la visualisation en `Python`. Cette librairie est développée par `Posit`, l'entreprise à l'origine de l'éditeur `RStudio` et de l'écosystème du _tidyverse_ si central dans le langage `R`. Cette librairie vise à importer la logique de `ggplot` en `Python`, c'est-à-dire une grammaire des graphiques normalisée, lisible et flexible héritée de @wilkinson2011grammar.

Dans cette approche, un graphique est vu comme une succession de couches qui, une fois superposées, donneront la figure suivante. En soi, ce principe n'est pas différent de celui de `matplotlib`. Néanmoins, la grammaire utilisée par `plotnine` est beaucoup plus intuitive et normalisée, ce qui offrira beaucoup plus d'autonomie pour modifier sa figure.

![La logique de `ggplot` (et `plotnine`) image empruntée à [Andrew Heiss {{< fa arrow-up-right-from-square >}}](https://datavizf24.classes.andrewheiss.com/lesson/04-lesson.html#changing-colors-shapes-and-sizes-with-scale_){target="_blank"}](https://datavizf24.classes.andrewheiss.com/slides/img/03/ggplot-layers@4x.png){width=60%}

Avec `plotnine`, il n'y a plus de point d'entrée dual figure-axe. Comme l'illustrent les slides ci-dessous :

1. On initialise une figure
2. On met à jour les couches (_layers_), un niveau d'abstraction très général concernant aussi bien les données représentées que les échelles des axes ou la couleur
3. À la fin, on peut jouer sur l'esthétique en modifiant les labels des axes, de la légende, les titres, etc.
:::

::: {.content-visible when-profile="en"}
# And here enters `Plotnine`, a pythonic grammar of graphics

`plotnine` is the newcomer to the `Python` visualization ecosystem. This library is developed by `Posit`, the company behind the `RStudio` editor and the _tidyverse_ ecosystem, which is central to the `R` language. This library aims to bring the logic of `ggplot` to `Python`, meaning a standardized, readable, and flexible grammar of graphics inspired by @wilkinson2011grammar.

In this approach, a chart is viewed as a succession of layers that, when combined, create the final figure. This principle is not inherently different from that of `matplotlib`. However, the grammar used by `plotnine` is far more intuitive and standardized, offering much more autonomy for modifying a chart.
![`ggplot` (and `plotnine`) logic, picture borrowed to [Andrew Heiss {{< fa arrow-up-right-from-square >}}](https://datavizf24.classes.andrewheiss.com/lesson/04-lesson.html#changing-colors-shapes-and-sizes-with-scale_){target="_blank"}](https://datavizf24.classes.andrewheiss.com/slides/img/03/ggplot-layers@4x.png){width=60%}


With `plotnine`, there is no longer a dual figure-axis entry point. As illustrated in the slides below:

1. A figure is initialized
2. Layers are updated, a very general abstraction level that applies to the data represented, axis scales, colors, etc.
3. Finally, aesthetics can be adjusted by modifying axis labels, legend labels, titles, etc.
:::

::: {.content-visible when-profile="fr"}
Nous allons avoir besoin de données hiérarchisées pour avoir des barres ordonnées de manière cohérente:
:::


::: {.content-visible when-profile="en"}
We will need hierarchical data to have bars ordered in a consistent manner:
:::

```{python}
#| echo: true
df1["nom_compteur"] = pd.Categorical(
    df1["nom_compteur"],
    categories = df1["nom_compteur"][::-1]
)
```

{{< include "01_matplotlib/_exo4.qmd" >}}



{{< include "01_matplotlib/_exo4_solution.qmd" >}}


:::: {.content-visible when-profile="fr"}

::: {.callout-caution}
Pour contextualiser les données temporelles, on utilise généralement des dates sur l'axe des abscisses (_x_). Pour éviter de rendre celles-ci illisibles, il faut éviter de donner trop de détail (trop de valeurs affichées, affichage des jours quand les mois suffisent...). 

Tourner le texte verticalement pour faire rentrer plus de texte sur l'axe horizontal n'est pas une bonne idée: l'effet principal de cela est de donner un torticolis au lecteur de votre graphique. Il vaut mieux afficher moins de labels, quitte à faire une note de lecture pour les dates vraiment spéciales. 

:::: 

:::

:::: {.content-visible when-profile="en"}

::: {.callout-caution}
To effectively contextualize time-based data, it's standard practice to use dates along the x-axis. To maintain readability, avoid overloading the axis with too much detail such as showing every single day when months would suffice.

Rotating text vertically to squeeze more labels onto the axis isn’t a great solution - it mostly just gives your reader a sore neck. It’s often better to reduce the number of labels and, if needed, add annotations for particularly important dates.

:::  

::::

::: {.content-visible when-profile="fr"}
Pour commencer, reproduisons la troisième figure qui est, encore une fois, un _barplot_. Ici, sur le plan sémiologique, ce n'est pas justifié d'utiliser un _barplot_, une simple série suffirait à fournir une information similaire.

La première question du prochain exercice implique une première rencontre avec une donnée temporelle à travers une opération assez classique en séries temporelles : changer le format d'une date pour pouvoir faire une agrégation à un pas de temps plus large.
:::


# Visualisations alternatives

::: {.content-visible when-profile="fr"}
Jusqu'à présent, nous avons consciencieusement reproduit les visualisations proposées sur le tableau de bord de l'_open data_ parisien. Mais nous pourrions vouloir faire passer la même information avec des visualisations différentes:


* Les _lollipop chart_ ressemblent beaucoup aux diagrammes en barre mais l'information visuelle est un peu plus efficiente: on n'a pas une grosse barre pour représenter les grandeurs mais une ligne plus fine ce qui peut aider à vraiment percevoir les échelles de grandeur dans les données. 
* Puisque on a besoin de contextualiser la figure avec les valeurs exactes - en attendant de découvrir le monde de l'interactivité - pourquoi ne pas utiliser un tableau et y insérer des graphiques ? Les tableaux ne sont pas un mauvais _medium_ de communication, au contraire, s'ils proposent une information visuelle hiérarchisée ils peuvent mettre être très utiles !

## Les lollipop chart

Les diagrammes en bâtons (_barplot_) sont extrêmement communs, sans doute à cause de l'héritage d'Excel où ces graphiques sont faisables en deux clics. Néanmoins, en ce qui concerne le message à transmettre, ils sont loin d'être parfaits. Par exemple, les barres prennent beaucoup d'espace visuel, ce qui peut brouiller le message à transmettre sur le rapport entre les observations.

Sur le plan sémiologique, c'est-à-dire sur le plan de l'efficacité du message à transmettre, les _lollipop charts_ sont préférables : ils transmettent la même information mais avec moins de signes visuels pouvant brouiller sa compréhension.

Les _lollipop charts_ ne sont pas parfaits non plus mais sont un peu plus efficaces pour transmettre le message. Pour en savoir plus sur les alternatives au _barplot_, la conférence d'Eric Mauvière pour le réseau des _data scientists_ de la statistique publique, dont le message principal est _"Désempilez vos figures"_, mérite le détour ([disponible sur le site ssphub.netlify.app/ {{< fa arrow-up-right-from-square >}}](https://ssphub.netlify.app/talk/2024-02-29-mauviere/)).


La figure précédente prend ainsi la forme
:::

::: {.content-visible when-profile="en"}

Bar charts (_barplot_) are extremely common, likely due to the legacy of Excel, where these charts can be created with just a couple of clicks. However, in terms of conveying a message, they are far from perfect. For example, the bars take up a lot of visual space, which can obscure the intended message about relationships between observations.

From a semiological perspective, that is, in terms of the effectiveness of conveying a message, _lollipop charts_ are preferable: they convey the same information but with fewer visual elements that might clutter understanding.

_Lollipop charts_ are not perfect either but are slightly more effective at conveying the message. To learn more about alternatives to bar charts, Eric Mauvière's talk for the public statistics data scientists network, whose main message is _"Unstack your figures"_, is worth exploring ([available on ssphub.netlify.app/ {{< fa arrow-up-right-from-square >}}](https://ssphub.netlify.app/talk/2024-02-29-mauviere/)).

If we use a lollipop chart instead of a barplot, we end up with
:::

```{python}
#| echo: true
#| label: fig-lollipop
(
    ggplot(df1, aes(x="nom_compteur", y="sum_counts")) +
    geom_segment(aes(x="nom_compteur", xend="nom_compteur", y=0, yend="sum_counts"), size=1) +
    geom_point(color="white", fill="red", size=6, stroke=1, shape="o") +
    coord_flip() +
    labs(
        title="Les 10 compteurs avec la moyenne horaire la plus élevée",
        x="Nom du compteur",
        y="Moyenne horaire"
    ) +
    theme_minimal()
)
```

::: {.content-visible when-profile="fr"}
Grâce à cette représentation alternative, on se représente ici mieux la différence entre le compteur le plus utilisé et les autres. 

Le _lollipop chart_ est une représentation assez classique en biostatistiques ou économie pour représenter les _odds ratio_ issus d'une modélisation logistique. En l'occurrence, les lignes servent généralement à représenter la taille de l'intervalle de confiance dans cette littérature. 

![Une variante des _lollipop charts_ pour représenter les _odds ratio_ [@galianacaracteristiques]](./01_matplotlib/capture_odds_ratio.png)

Une variante des _lollipop chart_, popularisée notamment par [_datawrapper_ {{< fa arrow-up-right-from-square >}}](https://www.datawrapper.de/){target="_blank"} permet aussi de représenter des intervalles: le _range plot_. Il permet à la fois de se représenter la hiérarchie entre des observations et l'amplitude d'un phénomène. 

![Exemple de _range plot_ par Eric Mauvière ([ssphub.netlify.app/ {{< fa arrow-up-right-from-square >}}](https://ssphub.netlify.app/talk/2024-02-29-mauviere/){target="_blank"}).](https://ssphub.netlify.app/talk/2024-02-29-mauviere/mauviere.png)

:::


::: {.content-visible when-profile="en"}
This alternative representation provides a clearer picture of the difference between the most frequently used counter and the others.

The lollipop chart is a fairly standard representation in biostatistics and economics for representing odds ratios derived from logistic modelling. In this case, the lines are generally used to represent the size of the confidence interval in this literature. 

![A variant of lollipop charts to represent odds ratios [@galianacaracteristiques]](./01_matplotlib/capture_odds_ratio.png)

A variant of the lollipop chart, popularised in particular by [datawrapper {{< fa arrow-up-right-from-square >}}](https://www.datawrapper.de/){target="_blank"}, also allows intervals to be represented: the range plot. It allows both the hierarchy between observations and the amplitude of a phenomenon to be represented. 

![Example of a range plot by Eric Mauvière ([ssphub.netlify.app/ {{< fa arrow-up-right-from-square >}}](https://ssphub.netlify.app/talk/2024-02-29-mauviere/){target="_blank"}).] (https://ssphub.netlify.app/talk/2024-02-29-mauviere/mauviere.png)
:::

::: {.content-visible when-profile="fr"}
## Un tableau stylisé

Les tableaux sont de bons _medium_ pour communiquer des valeurs précises. Mais sans l'ajout d'éléments contextuels, comme des intensités de couleurs ou des figures, ils aident peu à percevoir visuellement les écrats ou les ordres de grandeur. 

Grâce à la richesse du format HTML - qui autorise l’insertion de graphismes légers directement dans les cellules - on peut combiner précision numérique et lisibilité visuelle. On a donc la possibilité d'avoir le meilleur des deux mondes.

Nous avons déjà utilisé précédemment le package [`great_tables` {{< fa arrow-up-right-from-square >}}](https://posit-dev.github.io/great-tables/articles/intro.html){target="_blank"} pour représenter des statistiques agrégées. Nous allons ici l’utiliser pour intégrer un _lollipop chart_ dans un tableau, permettant une lecture immédiate des valeurs tout en conservant leur exactitude.
:::

::: {.content-visible when-profile="en"}
## A stylised table

Tables are a good medium for communicating precise values. But without the addition of contextual elements, such as colour intensities or figures, they are of little help in visually perceiving discrepancies or orders of magnitude. 

Thanks to the richness of the HTML format, which allows lightweight graphics to be inserted directly into cells, it is possible to combine numerical precision with visual readability. This gives us the best of both worlds.

We have previously used the [`great_tables` {{< fa arrow-up-right-from-square >}}](https://posit-dev.github.io/great-tables/articles/intro.html){target='_blank'} package to represent aggregated statistics. Here, we will use it to integrate a lollipop chart into a table, allowing immediate reading of values while maintaining their accuracy.
:::

::: {.content-visible when-profile="fr"}
Nous allons en profiter pour nettoyer un peu le texte à afficher en retirant les _labels_ doublonnés et en isolant la direction. 
:::

::: {.content-visible when-profile="en"}
We will take this opportunity to clean up the text to be displayed by removing duplicate labels and isolating the direction.
:::

```{python}
#| echo: true
#| label: clean-before-table
#| code-fold: true

df1["direction"] = df1["nom_compteur"].str.extract(
    r"([A-Z]{1,3}-[A-Z]{1,3})$"
)
df1["nom_compteur"] = df1["nom_compteur"].str.replace(
    r"([A-Z]{1,3}-[A-Z]{1,3})$", "", regex=True
)

def deduplicate_label(label):
    parts = label.split()
    mid = len(parts) // 2
    for i in range(1, mid + 1):
        if parts[:i] == parts[i:2*i]:
            return ' '.join(parts[i:])
    return label

df1["nom_compteur"] = df1["nom_compteur"].apply(deduplicate_label)
df1["nom_compteur"] = df1['nom_compteur'].str.replace("(Vélos|Totem)", "", regex=True)

df1.head()
```

::: {.content-visible when-profile="fr"}
Nous allons aussi créer une colonne intermédiaire pour créer un visuel synthétique de couleur permettant de voir les compteurs sur plusieurs lignes.
:::

::: {.content-visible when-profile="en"}
We will also create an intermediate column to create a colourful summary visualisation allowing us to see the counters on several lines.
:::

```{python}
#| echo: true
#| label: pimp-before-table
#| code-fold: true

import matplotlib.pyplot as plt

df1["nom_compteur_temp"] = df1["nom_compteur"]

# Discrete colormap
categories = df1["nom_compteur_temp"].unique()
cmap = plt.get_cmap("Dark2")

# Create mapping from label to color hex
colors = {cat: cmap(i / max(len(categories) - 1, 1)) for i, cat in enumerate(categories)}
colors = {k: plt.matplotlib.colors.to_hex(v) for k, v in colors.items()}

# Function to return colored cell
def create_color_cell(label: str) -> str:
    color = colors.get(label, "#ccc")
    return f"""
    <div style="
        width: 20px;
        height: 20px;
        background-color: {color};
        border-radius: 3px;
        margin: auto;
    "></div>
    """
```

::: {.content-visible when-profile="fr"}
Il ne reste plus qu'à produire la table.
:::

::: {.content-visible when-profile="en"}
All that remains is to produce the table.
:::

```{python}
#| echo: true
#| label: tbl-lollipop
#| tbl-cap: Représentation alternative
#| code-fold: true

from great_tables import *

(
    GT(
        df1.loc[:, ["nom_compteur_temp","nom_compteur", "direction", "text", "sum_counts"]]
    )
    .fmt(fns=create_color_cell, columns="nom_compteur_temp")
    .fmt_nanoplot(columns="sum_counts")
    .tab_spanner(
        label="Compteur",
        columns=["nom_compteur_temp", "nom_compteur", "direction"]
    )
    .tab_spanner(
        label="Moyenne horaire",
        columns=["text", "sum_counts"]
    )
    .cols_label(
        nom_compteur = "Localisation",
        direction = "Direction",
        text = "",
        sum_counts = "",
        nom_compteur_temp
         = ""
    )
    .cols_width(
        cases={
            "nom_compteur_temp": "10%",
            "nom_compteur": "40%",
            "direction": "10%",
            "text": "10%"
        }
    )
    .tab_source_note(
        md("**Source**: Compteurs vélib sur la page de l'[open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name)"
        )
    )
)
```


::: {.content-visible when-profile="fr"}
# Des graphiques réactifs grâce aux librairies `Javascript`

::: {.callout-important}
On appelle _tooltip_ le texte qui s'affiche en surbrillance lorsqu'on passe la souris sur un élément de la figure (ordinateur) ou lorsqu'on clique sur la figure (smartphone). Il s'agit donc d'un niveau d'information supplémentaire permis par l'interactivité, qui peut être pratique pour alléger le message principal d'une figure.

Néanmoins, comme toute information sur une figure, du travail pour rendre celle-ci utile est nécessaire. On peut rarement se contenter du _tooltip_ par défaut d'une librairie: il faut réfléchir au message que celui-ci doit passer, complément textuel à l'information visuelle représentée sur la figure. 

Encore une fois, nous n'allons pas creuser ce sujet - c'est l'objet, en soi, d'un cours de _data visualisation_ - mais avoir en tête cet enjeu est important pour la réception d'une visualisation.

Par ailleurs, un autre élément que nous mettons totalement de côté ici mais qui est important lorsqu'on rentre dans le monde de la visualisation interactive est celui de la _responsiveness_, c'est-à-dire de la capacité d'une visualisation, et plus généralement d'un site web, à être lisible et fonctionnel sur des tailles d'écran différentes. Gérer des tailles d'écran différentes est compliqué mais est indispensable si on vise un public large dont une partie croissante utilise des smartphones pour consulter un site web.

A ceci s'ajoute des questions d'adaptabilité du site à différentes formes de handicaps visuels. Par exemple, ce serait environ 8% des hommes qui seraient atteints d'une forme de daltonisme, avec des formes différentes (6% ont des difficultés à percevoir les nuances de vert, 2% de rouge).

Bref, vous qui entrez dans le monde de la visualisation, laissez toute espérance de simplicité. Les outils sont simples d'usage mais les besoins sont complexes. 
:::  


## L'écosystème disponible depuis `Python`

Les figures figées construites avec `matplotlib` ou `plotnine` sont figées et présentent ainsi l'inconvénient de ne pas permettre d'interaction avec le lecteur. Toute l'information doit donc être contenue dans la figure, ce qui peut la rendre difficile à lire. Si la figure est bien faite, avec différents niveaux d'information, cela peut bien fonctionner.

Il est néanmoins plus simple, grâce aux technologies _web_, de proposer des visualisations à plusieurs niveaux. Un premier niveau d'information, celui du coup d'œil, peut suffire à assimiler les principaux messages de la visualisation. Ensuite, un comportement plus volontaire de recherche d'information secondaire peut permettre d'en savoir plus. Les visualisations réactives, qui sont maintenant la norme dans le monde de la _dataviz_, permettent ce type d'approche : le lecteur d'une visualisation peut passer sa souris à la recherche d'informations complémentaires (par exemple, les valeurs exactes) ou cliquer pour faire apparaître des informations complémentaires sur la visualisation ou autour.

Ces visualisations reposent sur le même triptyque que l'ensemble de l'écosystème _web_ : `HTML`, `CSS` et `JavaScript`. Les utilisateurs de `Python` ne vont jamais manipuler directement ces langages, qui demandent une certaine expertise, mais vont utiliser des librairies au niveau de `R` qui génèreront automatiquement tout le code `HTML`, `CSS` et `JavaScript` permettant de créer la figure.

Il existe plusieurs écosystèmes `Javascript` mis à disposition des développeurs.euses par le biais de `Python`. Les deux principales librairies sont [`Plotly`](https://plotly.com/python/), associée à l'écosystème `Javascript` du même nom, et [`Altair`](https://altair-viz.github.io/), associée à l'écosystème `Vega` et `Altair` en `Javascript`[^star]. Pour permettre aux pythonistes de découvrir la librairie `Javascript` émergente [`Observable Plot`](https://observablehq.com/plot/), l'ingénieur de recherche français Julien Barnier a développé [`pyobsplot`](https://juba.github.io/pyobsplot/) une librairie `Python` permettant d'utiliser cet écosystème depuis `Python`.

[^star]: Le nom de ces librairies est inspiré de la constellation du triangle d'été dont Véga et Altair sont deux membres.

L'interactivité ne doit pas juste être un gadget n'apportant pas de lisibilité supplémentaire, voire la détériorant. Il est rare de pouvoir se contenter de la figure produite sans avoir à fournir un travail supplémentaire pour la rendre efficace.
:::

::: {.content-visible when-profile="en"}

# Reactive Charts with `Javascript` Libraries

::: {.callout-important}
A *tooltip* is the text that appears when hovering over an element in a chart on a computer, or when tapping on it on a smartphone. It adds an extra layer of information through interactivity and can be a useful way to declutter the main message of a visualization.

That said, like any element of a chart, a tooltip requires thoughtful design to be effective. The default tooltips provided by visualization libraries are rarely sufficient. You need to consider what message the tooltip should convey as a textual complement to the visual data shown in the chart.

Again, we won’t go into detail here - this topic alone could fill an entire data visualization course - but it is important to keep in mind when designing interactive charts.

Another important topic we won’t cover here is *responsiveness*: the ability of a visualization (or a website more generally) to display clearly and function properly across different screen sizes. Designing for multiple devices is challenging but essential, especially given that a growing share of web traffic now comes from smartphones.

In addition, accessibility is another crucial consideration in interactive visualizations. For instance, around 8% of men have some form of color vision deficiency, most commonly difficulty perceiving green (about 6%) or red (about 2%).

In short, ye who enter to data visualization, abandon all hope. While the tools themselves may be easy to use, the needs they must meet are often complex.

:::  


## Ecosystem available from `Python`

Static figures created with `matplotlib` or `plotnine` are fixed and thus have the disadvantage of not allowing interaction with the viewer. All the information must be contained in the figure, which can make it difficult to read. If the figure is well-made with multiple levels of information, it can still work well.

However, thanks to _web_ technologies, it is simpler to offer visualizations with multiple levels. A first level of information, the quick glance, may be enough to grasp the main messages of the visualization. Then, a more deliberate behavior of seeking secondary information can provide further insights. Reactive visualizations, now the standard in the _dataviz_ world, allow for this approach: the viewer can hover over the visualization to find additional information (e.g., exact values) or click to display complementary details.

These visualizations rely on the same triptych as the entire _web_ ecosystem: `HTML`, `CSS`, and `JavaScript`. `Python` users will not directly manipulate these languages, which require a certain level of expertise. Instead, they use libraries that automatically generate all the necessary `HTML`, `CSS`, and `JavaScript` code to create the figure.

Several `Javascript` ecosystems are made available to developers through `Python`. The two main libraries are [`Plotly`](https://plotly.com/python/), associated with the `Javascript` ecosystem of the same name, and [`Altair`](https://altair-viz.github.io/), associated with the `Vega` and `Altair` ecosystems in `Javascript`[^star-en]. To allow Python users to explore the emerging `Javascript` library [`Observable Plot`](https://observablehq.com/plot/), French research engineer Julien Barnier developed [`pyobsplot`](https://juba.github.io/pyobsplot/), a `Python` library enabling the use of this ecosystem from `Python`.

[^star-en]: The names of these libraries are inspired by the Summer Triangle constellation, of which Vega and Altair are two members.

Interactivity should not just be a gimmick that adds no readability or even worsens it. It is rare to rely solely on the figure as produced without further work to make it effective.
:::

::: {.content-visible when-profile="fr"}
## La librairie `Plotly`

Le package `Plotly` est une surcouche à la librairie `Javascript` `Plotly.js` qui permet de créer et manipuler des objets graphiques de manière très flexible afin de produire des objets réactifs sans avoir à recourir à Javascript.

Le point d'entrée recommandé est le module `plotly.express` ([documentation ici](https://plotly.com/python/plotly-express/)) qui offre une approche intuitive pour construire des graphiques pouvant être modifiés *a posteriori* si besoin (par exemple pour *customiser* les axes).

::: {.callout-note}
## Visualiser les figures produites par `Plotly`

Dans un _notebook_ `Jupyter` classique, les lignes suivantes de code permettent d'afficher le résultat d'une commande `Plotly` sous un bloc de code :

```{python}
#| eval: false
from plotly.offline import init_notebook_mode
init_notebook_mode(connected = True)
```

Pour `JupyterLab`, l'extension `jupyterlab-plotly` s'avère nécessaire:

```python
!jupyter labextension install jupyterlab-plotly
```

:::

## Réplication de l'exemple précédent avec `Plotly`

Les modules suivants seront nécessaires pour construire des graphiques avec `plotly`:

```{python}
#| echo: true
import plotly
import plotly.express as px
```
:::

::: {.content-visible when-profile="en"}
## The `Plotly` Library

The `Plotly` package is a wrapper for the `Javascript` library `Plotly.js`, allowing for the creation and manipulation of graphical objects very flexibly to produce interactive objects without the need for Javascript.

The recommended entry point is the `plotly.express` module ([documentation here](https://plotly.com/python/plotly-express/)), which provides an intuitive approach for creating charts that can be modified *post hoc* if needed (e.g., to customize axes).

::: {.callout-note}
## Displaying Figures Created with `Plotly`

In a standard `Jupyter` notebook, the following lines of code allow the output of a `Plotly` command to be displayed under a code block:

```{python}
#| eval: false
from plotly.offline import init_notebook_mode
init_notebook_mode(connected = True)
```

For `JupyterLab`, the `jupyterlab-plotly` extension is required:

```python
!jupyter labextension install jupyterlab-plotly
```

:::

## Replicating the Previous Example with `Plotly`

The following modules will be required to create charts with `plotly`:

```{python}
#| echo: true
import plotly
import plotly.express as px
```
:::


:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice 7: un barplot avec `Plotly`

L'objectif est de reconstruire le premier diagramme en barre rouge avec `Plotly`.

1. Réalisez le graphique en utilisant la fonction adéquate avec `plotly.express` et...
    * Ne pas prendre le thème par défaut mais un à fond blanc, pour avoir un résultat ressemblant à celui proposé sur le site de l'*open-data*.
    * Pour la couleur rouge, vous pouvez utiliser l'argument `color_discrete_sequence`.
    * Ne pas oublier de nommer les axes.
    * Pensez à la couleur du texte de l'axe inférieur.

2. Tester un autre thème, à fond sombre. Pour les couleurs, faire un groupe stockant les trois plus fortes valeurs puis les autres.

:::

::::


:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Exercise 7: A Barplot with `Plotly`

The goal is to recreate the first red bar chart using `Plotly`.

1. Create the chart using the appropriate function from `plotly.express` and...
    * Do not use the default theme but one with a white background to achieve a result similar to that on the *open-data* site.
    * Use the `color_discrete_sequence` argument for the red color.
    * Remember to label the axes.
    * Consider the text color for the lower axis.

2. Try another theme with a dark background. For colors, group the three highest values together and separate the others.

:::

::::

::: {.content-visible when-profile="fr"}
```{python}
#| output: false
# 1. Graphique avec fond blanc
fig = px.bar(
    df1.sort_values('sum_counts', ascending=True),
    orientation='h', x='sum_counts',
    y='nom_compteur', color_discrete_sequence=["red"], template="plotly_white"
)

fig.update_layout(
    title='Les 10 compteurs avec la moyenne horaire la plus élevée',
    xaxis_title='Moyenne du comptage par heure sur la période sélectionnée')
fig.update_xaxes(title_font=dict(color='red'))
```

```{python}
#| output: false

# 2. Graphique avec thème sombre
df1['top'] = df1['sum_counts'] > df1.sort_values('sum_counts', ascending=False)['sum_counts'][3]
fig2 = px.bar(
    df1.sort_values('sum_counts', ascending=True), orientation='h', x='sum_counts',
    y='nom_compteur', color='top', # attention, l'argument color ne semble pas toujours fonctionner
    template="plotly_dark",
    color_discrete_sequence=['red','green']
)
fig2.update_layout(
    title='Les 10 compteurs avec la moyenne horaire la plus élevée',
    xaxis_title='Moyenne du comptage par heure sur la période sélectionnée'
)
```
:::

::: {.content-visible when-profile="en"}
```{python}
#| output: false
# 1. Chart with white background
fig = px.bar(
    df1.sort_values('sum_counts', ascending=True),
    orientation='h', x='sum_counts',
    y='nom_compteur', color_discrete_sequence=["red"], template="plotly_white"
)

fig.update_layout(
    title='The 10 counters with the highest hourly average',
    xaxis_title='Average count per hour over the selected period')
fig.update_xaxes(title_font=dict(color='red'))
```

```{python}
#| output: false

# 2. Chart with dark theme
df1['top'] = df1['sum_counts'] > df1.sort_values('sum_counts', ascending=False)['sum_counts'][3]
fig2 = px.bar(
    df1.sort_values('sum_counts', ascending=True), orientation='h', x='sum_counts',
    y='nom_compteur', color='top', # note: the color argument might not always work
    template="plotly_dark",
    color_discrete_sequence=['red','green']
)
fig2.update_layout(
    title='The 10 counters with the highest hourly average',
    xaxis_title='Average count per hour over the selected period'
)
```
:::


::: {.content-visible when-format="html"}

::: {.content-visible when-profile="fr"}
La première question permet de construire le graphique suivant :
:::

::: {.content-visible when-profile="en"}
The first question allows the creation of the following chart:
:::

```{python}
fig.show()
```

::: {.content-visible when-profile="fr"}
Alors qu’avec le thème sombre (question 2), on obtient :
:::

::: {.content-visible when-profile="en"}
Whereas with the dark theme (question 2), we get:
:::

```{python}
fig2.show()
```

:::


::: {.content-visible when-profile="fr"}
## La librairie `altair`

Pour cet exemple, nous allons reconstruire notre figure précédente.
:::

::: {.content-visible when-profile="en"}
## The `altair` Library

For this example, we will recreate our previous figure.
:::

```{python}
df1 = (
    df
    .groupby('nom_compteur')
    .agg({'sum_counts': "mean"})
    .sort_values('sum_counts', ascending = False)
    .head(10)
    .sort_values('sum_counts')
)
```

::: {.content-visible when-profile="fr"}
Comme `ggplot`/`plotnine`, `Vega` est un écosystème graphique visant à proposer une implémentation de la grammaire des graphiques de @wilkinson2011grammar. La syntaxe de `Vega` est donc basée sur un principe déclaratif : on déclare une construction par couches et transformations de données progressives.

À l'origine, `Vega` est basée sur une syntaxe JSON, d'où son lien fort avec `Javascript`. Néanmoins, il existe une API Python qui permet de faire ce type de figures interactives nativement en Python. Pour comprendre la logique de construction d'un code `altair`, voici comment répliquer la figure précédente avec :
:::

::: {.content-visible when-profile="en"}
Like `ggplot`/`plotnine`, `Vega` is a graphics ecosystem designed to implement the grammar of graphics from @wilkinson2011grammar. The syntax of `Vega` is therefore based on a declarative principle: a construction is declared through layers and progressive data transformations.

Originally, `Vega` was based on a JSON syntax, hence its strong connection to `Javascript`. However, there is a Python API that allows for creating these types of interactive figures natively in Python. To understand the logic of constructing an `altair` code, here is how to replicate the previous figure:
:::


::: {.content-visible when-profile="fr"}

```{python}
#| code-fold: true
#| code-summary: "Voir l'architecture d'une figure altair"
#| echo: true
import altair as alt

fig2 = (
    alt.Chart(df1.reset_index()) # <1>
    .mark_bar(color='steelblue') 
    .encode( # <2>
        x=alt.X('sum_counts:Q', title='Moyenne du comptage par heure sur la période sélectionnée'), # <3>
        y=alt.Y('nom_compteur:N', sort='-x', title=''),
        tooltip=[ # <4>
            alt.Tooltip('nom_compteur:N', title='Nom du compteur'),
            alt.Tooltip('sum_counts:Q', title='Moyenne horaire')
        ]
    ).properties( # <5>
        title='Les 10 compteurs avec la moyenne horaire la plus élevée'
    ).configure_view(
        strokeOpacity=0
    )
)

fig2.interactive()
```

1. On déclare d'abord le _dataframe_ qui sera utilisé, comme nous le faisions avec `ggplot(df)` avec `plotnine`. Puis le type de figure désirée (ici un diagramme en barre, `mark_bar` dans la grammaire d'`altair`).
2. On définit notre couche principale avec `encode`. Celle-ci peut accepter simplement des noms de colonnes ou des constructeurs plus complexes, comme ici.
3. On définit un constructeur pour notre axe des _x_, à la fois pour gérer l'échelle des valeurs mais aussi les paramètres de celle-ci (labels, etc.). Ici, on définit l'axe des _x_ comme une valeur continue (`:Q`), moyenne de `sum_counts` pour chaque valeur de $y$. Cette moyenne n'est pas indispensable, on aurait pu se contenter d'écrire `sum_counts:Q` voire même `sum_counts` mais c'est pour illustrer la gestion des transformations de données dans `altair`.
4. Le _tooltip_ nous permet de gérer l'interactivité de notre figure.
5. Les propriétés viennent à la fin de notre déclaration pour finaliser la figure.

:::

::: {.content-visible when-profile="en"}

```{python}
#| code-fold: true
#| code-summary: "View the architecture of an Altair figure"
#| echo: true
import altair as alt

fig2 = (
    alt.Chart(df1.reset_index())  # <1>
    .mark_bar(color='steelblue')
    .encode(  # <2>
        x=alt.X('sum_counts:Q', title='Average count per hour over the selected period'),  # <3>
        y=alt.Y('nom_compteur:N', sort='-x', title=''),
        tooltip=[  # <4>
            alt.Tooltip('nom_compteur:N', title='Counter name'),
            alt.Tooltip('sum_counts:Q', title='Hourly average')
        ]
    ).properties(  # <5>
        title='Top 10 counters by hourly average count'
    ).configure_view(
        strokeOpacity=0
    )
)

fig2.interactive()
```

1. First, the _dataframe_ to be used is declared, similar to `ggplot(df)` in `plotnine`. Then, the desired chart type is specified (in this case, a bar chart, `mark_bar` in Altair's grammar).
2. The main layer is defined using `encode`. This can accept either simple column names or more complex constructors, as shown here.
3. A constructor is defined for the x-axis, both to manage value scaling and its parameters (e.g., labels). Here, the x-axis is defined as a continuous value (`:Q`), the average of `sum_counts` for each $y$ value. This average is not strictly necessary; we could have used `sum_counts:Q` or even `sum_counts`, but this illustrates data transformations in `altair`.
4. The _tooltip_ adds interactivity to the chart.
5. Properties are specified at the end of the declaration to finalize the chart.

:::

::: {.content-visible when-profile="fr"}
# Références {-}
:::

::: {.content-visible when-profile="en"}
# References {-}
:::


::: {#refs}
:::