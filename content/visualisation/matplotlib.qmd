---
title: "Construire des graphiques avec Python"
title-en: "Building graphics with Python"
author: Lino Galiana
categories:
    - Visualisation
    - Exercice
description: |
    Une partie essentielle du travail du  _data scientist_ est d'être en mesure de synthétiser une information dans des représentations graphiques percutantes. Ce chapitre permet de découvrir les enjeux de la représentation de données avec `Python`, l'écosystème pour faire ceci. Il ouvre également à la représentation interactive de données avec `Plotly`.
description-en: |
    An essential part of the _data scientist's_ job is to be able to synthesize information into powerful graphical representations. This chapter looks at the challenges of data representation with `Python`, the ecosystem for doing this. It also opens the door to interactive data representation with `Plotly`.
image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/drawing.png
echo: false
bibliography: ../../reference.bib
---

{{< badges
    printMessage="true"
>}}

:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Compétences à l'issue de ce chapitre

* Découvrir l'écosystème [`matplotlib`](https://matplotlib.org/) et
[`seaborn`](https://seaborn.pydata.org/) pour la construction de graphiques par enrichissement successif de couches.
* Découvrir le récent écosystème [`plotnine`](https://plotnine.readthedocs.io/en/stable/index.html),
qui est une implémentation en `Python` du _package_ `R` [`ggplot2`](https://ggplot2.tidyverse.org/)
pour ce type de représentation et qui, grâce à sa grammaire des graphiques, offre une syntaxe puissante pour construire des visualisations de données.
* Découvrir le principe des représentations interactives HTML (format _web_) grâce aux packages [`plotly`](https://plotly.com/python/) et [`altair`](https://altair-viz.github.io/).
* Apprendre les enjeux de la représentation graphique, les compromis nécessaires pour construire un message clair et les limites de certaines représentations classiques.

:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## What you will learn in this chapter  

* Get to know the [`matplotlib`](https://matplotlib.org/) and [`seaborn`](https://seaborn.pydata.org/) ecosystems, and learn how to build charts by progressively layering elements.
* Explore the modern [`plotnine`](https://plotnine.readthedocs.io/en/stable/index.html) library — a `Python` implementation of `R`'s [`ggplot2`](https://ggplot2.tidyverse.org/) — which provides a powerful grammar of graphics for constructing visualizations.
* Understand how to create interactive, web-based visualizations using the [`plotly`](https://plotly.com/python/) and [`altair`](https://altair-viz.github.io/) packages.
* Learn about the key principles of effective data visualization, including the trade-offs involved in delivering a clear message and the limitations of some traditional chart types.

:::

::::

{{< include "./01_matplotlib/_intro.qmd" >}}

{{< include "_prepare_data_bike.qmd" >}}


::: {.content-visible when-profile="fr"}
# Premières productions graphiques avec l'API `Matplotlib` de `Pandas`

Chercher à produire une visualisation parfaite du premier coup est illusoire. Il est beaucoup plus réaliste d'améliorer graduellement une représentation graphique afin, petit à petit, de mettre en avant les effets de structure dans un jeu de données.

Nous allons donc commencer par nous représenter la distribution des passages aux principales stations de mesure. Pour cela nous allons produire rapidement un _barplot_ puis l'améliorer graduellement.

Dans cette partie, nous allons ainsi reproduire les deux premiers graphiques de la [page d'analyse des données {{< fa arrow-up-right-from-square >}}](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name){target="_blank"} : *Les 10 compteurs avec la moyenne horaire la plus élevée* et *Les 10 compteurs ayant comptabilisé le plus de vélos*. Les valeurs chiffrées des graphiques peuvent être différentes de celles de la page en ligne, c'est normal, car nous ne travaillons pas systématiquement sur les données ayant la même fraîcheur que celles en ligne.


:::

::: {.content-visible when-profile="en"}
# Initial Graphical Productions with `Pandas`' `Matplotlib` API

Trying to produce a perfect visualization on the first attempt is unrealistic. It is much more practical to gradually improve a graphical representation to progressively highlight structural effects in a dataset.

We will begin by visualizing the distribution of bicycle counts at the main measurement stations. To do this, we will quickly create a _barplot_ and then improve it step by step.

In this section, we will reproduce the first two charts from the [data analysis page {{< fa arrow-up-right-from-square >}}](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name){target="_blank"}: *The 10 counters with the highest hourly average* and *The 10 counters that recorded the most bicycles*. The numerical values of the charts may differ from those on the webpage, which is expected, as we are not necessarily working with data as up-to-date as that online.



:::


::: {.content-visible when-profile="fr"}
## Comprendre, en quelques mots, le principe de `matplotlib`

`matplotlib` date du début des années 2000 et a émergé pour proposer une alternative en `Python` à la création de graphiques sous `Matlab`, un logiciel propriétaire de calcul numérique. `matplotlib` est donc une librairie assez ancienne, antérieure à l'émergence de `Python` dans l'écosystème du traitement de données. Cela s'en ressent sur la logique de construction de `matplotlib` qui n'est pas toujours intuitive lorsqu'on est familier de l'écosystème moderne de la _data science_. Heureusement, il existe de nombreuses librairies qui s'appuient sur `matplotlib` mais qui visent à fournir une syntaxe plus familière aux _data scientists_.

`matplotlib` propose principalement deux niveaux d'abstraction: la figure et les axes. La figure est, en quelque sorte, la "toile" globale qui contient un ou plusieurs axes dans lesquels s'inséreront des graphiques. Selon les cas, il faudra jouer avec les paramètres de figure ou d'axe, ce qui rend très flexible la construction d'un graphique mais peut également être déroutant car on ne sait jamais trop quel niveau d'abstraction il faut modifier pour mettre à jour sa figure[^chatGPT]. Comme le montre la @fig-matplotlib, tous les éléments d'une figure sont paramétrables.

[^chatGPT]: Heureusement, comme il existe un énorme corpus de code en ligne utilisant `matplotlib`, les assistants de code comme `ChatGPT` ou `Github Copilot` sont précieux pour construire un graphique à partir d'instructions.

![Comprendre l'architecture d'une figure `matplotlib` (Source: [documentation officielle](https://matplotlib.org/stable/users/explain/quick_start.html))](https://matplotlib.org/stable/_images/anatomy.png){#fig-matplotlib width=50%}

En pratique, il existe deux manières de créer et mettre à jour sa figure selon qu'on préfère passer par:

- l'approche explicite, héritière d'une logique de programmation orientée objet, où on crée des objets `Figure` et `Axes` et met à jour ceux-ci.
- l'approche implicite, basée sur l'interface `pyplot` qui utilise une succession de fonctions pour mettre à jour les objets créés implicitement.
:::

::: {.content-visible when-profile="en"}
## Understanding the Basics of `matplotlib`

`matplotlib` dates back to the early 2000s and emerged as a `Python` alternative for creating charts, similar to `Matlab`, a proprietary numerical computation software. Thus, `matplotlib` is quite an old library, predating the rise of `Python` in the data processing ecosystem. This is reflected in its design, which may not always feel intuitive to those familiar with the modern _data science_ ecosystem. Fortunately, many libraries build upon `matplotlib` to provide syntax more familiar to _data scientists_.

`matplotlib` primarily offers two levels of abstraction: the figure and the axes. The figure is essentially the "canvas" that contains one or more axes, where the charts are placed. Depending on the situation, you might need to modify figure or axis parameters, which makes chart creation highly flexible but also potentially confusing, as it’s not always clear which abstraction level to modify[^chatGPT-en]. As shown in @fig-matplotlib, every element of a figure is customizable.

[^chatGPT-en]: Thankfully, with a vast amount of online code using `matplotlib`, code assistants like `ChatGPT` or `Github Copilot` are invaluable for creating charts based on instructions.

![Understanding the Anatomy of a `matplotlib` Figure (Source: [Official Documentation](https://matplotlib.org/stable/users/explain/quick_start.html))](https://matplotlib.org/stable/_images/anatomy.png){#fig-matplotlib}

In practice, there are two ways to create and update your figure, depending on your preference:

- The explicit approach, inheriting an object-oriented programming logic, where `Figure` and `Axes` objects are created and updated directly.
- The implicit approach, based on the `pyplot` interface, which uses a series of functions to update implicitly created objects.
:::

:::: {.content-visible when-profile="fr"}

::: {.panel-tabset group="matplotlib-abstraction"}
## Approche explicite (approche orientée POO)

{{< include "01_matplotlib/_matplotlib_poo.qmd" >}}

Source: [Documentation officielle de `matplotlib`](https://matplotlib.org/stable/users/explain/quick_start.html)

## Approche implicite

{{< include "01_matplotlib/_matplotlib_pyplot.qmd" >}}

Source: [Documentation officielle de `matplotlib`](https://matplotlib.org/stable/users/explain/quick_start.html)

::::

Ces éléments constituent le minimum pour comprendre la logique de `matplotlib`. Pour être plus à l'aise avec ces concepts, la pratique répétée est indispensable.

:::

:::: {.content-visible when-profile="en"}

::: {.panel-tabset group="matplotlib-abstraction"}
## Explicit Approach (Object-Oriented Approach)

{{< include "01_matplotlib/_matplotlib_poo.qmd" >}}

Source: [Official `matplotlib` Documentation](https://matplotlib.org/stable/users/explain/quick_start.html)

## Implicit Approach

{{< include "01_matplotlib/_matplotlib_pyplot.qmd" >}}

Source: [Official `matplotlib` Documentation](https://matplotlib.org/stable/users/explain/quick_start.html)

:::

These elements are the minimum required to understand the logic of `matplotlib`. To become more comfortable with these concepts, repeated practice is essential.

::::



::: {.content-visible when-profile="fr"}
## Découvrir `matplotlib` par l'intermédiaire de `Pandas`
:::

::: {.content-visible when-profile="en"}
## Discovering `matplotlib` through `Pandas`
:::



{{< include "01_matplotlib/_exo1.qmd" >}}

{{< include "01_matplotlib/_exo1_solution.qmd" >}}

::: {.content-visible when-profile="fr"}
On commence à avoir quelque chose qui commence à transmettre un message synthétique sur la nature des données. On peut néanmoins remarquer plusieurs éléments problématiques (par exemple les labels) mais aussi des éléments ne correspondant pas (les titres des axes, etc.) ou manquants (le nom du graphique...).

Comme les graphiques produits par `Pandas` suivent la logique très flexible de `matplotlib`, il est possible de les customiser. Cependant, cela demande généralement beaucoup de travail et la grammaire `matplotlib` n'est pas aussi normalisée que celle de `ggplot` en `R`. Si on désire rester dans l'écosystème `matplotlib`, il est préférable de directement utiliser `seaborn`, qui offre quelques arguments prêts à l'emploi. Sinon on peut basculer sur l'écosystème `plotnine` qui offrira une syntaxe normalisée pour modifier les différents

# Utiliser directement `seaborn`

## Comprendre `seaborn` en quelques lignes

`seaborn` est une interface haut niveau au dessus de `matplotlib`. Ce package offre un ensemble de fonctionnalités pour créer des figures ou des axes `matplotlib` directement depuis une fonction admettant de nombreux arguments et, si besoin d'aller plus loin dans la customisation, d'utiliser les fonctionnalités de `matplotlib` pour mettre à jour la figure, que ce soit par le biais de l'approche implicite ou explicite décrites précédemment.

Comme pour `matplotlib`, `seaborn` permet de faire la même figure de multiples manières. `seaborn` hérite de la dualité axes-figures de `matplotlib` et il faudra souvent jouer avec un niveau ou l'autre. La principale caractéristique de `seaborn` est d'offrir quelques points d'entrée standardisés, par exemple `seaborn.relplot` ou `seaborn.catplot`, et une logique d'_inputs_ basée sur le `DataFrame` là où `matplotlib` est structurée autour du _array_ `Numpy`.

La figure comporte maintenant un message mais il est encore peu lisible. Il y a plusieurs manières de faire un *barplot* en `seaborn`. Les deux principales sont :

- `sns.catplot` ;
- `sns.barplot`.

On propose d'utiliser `sns.catplot` pour cet exercice. Il s'agit d'un point d'entrée assez fréquent pour faire des graphiques d'une variable discrétisée.

## Le diagramme en barre (_barplot_)
:::

::: {.content-visible when-profile="en"}
We are starting to create something that conveys a synthetic message about the nature of the data. However, several issues remain (e.g., labels), as well as elements that are either incorrect (axis titles, etc.) or missing (graph title...).

Since the charts produced by `Pandas` follow the highly flexible logic of `matplotlib`, they can be customized. However, this often requires significant effort, and the `matplotlib` grammar is not as standardized as `ggplot` in `R`. If you wish to remain in the `matplotlib` ecosystem, it is better to use `seaborn` directly, which provides ready-to-use arguments. Alternatively, you can switch to the `plotnine` ecosystem, which offers a standardized syntax for modifying elements.

# Using `seaborn` Directly

## Understanding `seaborn` in a Few Lines

`seaborn` is a high-level interface built on top of `matplotlib`. This package provides a set of features to create `matplotlib` figures or axes directly from a function with numerous arguments. If further customization is needed, `matplotlib` functionalities can be used to update the figure, whether through the implicit or explicit approaches described earlier.

As with `matplotlib`, the same figure can be created in multiple ways in `seaborn`. `seaborn` inherits the figure-axes duality from `matplotlib`, requiring frequent adjustments at either level. The main characteristic of `seaborn` is its standardized entry points, such as `seaborn.relplot` or `seaborn.catplot`, and its _input_ logic based on `DataFrame`, whereas `matplotlib` is structured around `Numpy` arrays.

The figure now conveys a message, but it is still not very readable. There are several ways to create a *barplot* in `seaborn`. The two main ones are:

- `sns.catplot`
- `sns.barplot`

For this exercise, we suggest using `sns.catplot`. It is a common entry point for plotting graphs of a discretized variable.

## The bar chart (_barplot_)
:::



{{< include "01_matplotlib/_exo2.qmd" >}}
{{< include "01_matplotlib/_exo2_solution.qmd" >}}



::: {.content-visible when-profile="fr"}
On comprend ainsi que le boulevard de Sébastopol est le plus emprunté, ce qui ne vous surprendra pas si vous faites du vélo à Paris. Néanmoins, si vous n'êtes pas familiers avec la géographie parisienne, cela sera peu informatif pour vous, vous allez avoir besoin d'une représentation graphique supplémentaire : une carte ! Nous verrons ceci lors d'un prochain chapitre.
:::

::: {.content-visible when-profile="en"}
This shows that Boulevard de Sébastopol is the most traveled, which won't surprise you if you cycle in Paris. However, if you're not familiar with Parisian geography, this will provide little information for you. You'll need an additional graphical representation: a map! We will cover this in a future chapter.
:::


:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice 2bis : reproduire la figure _"Les 10 compteurs ayant comptabilisé le plus de vélos"_

En suivant l'approche graduelle de l'exercice 2, refaire le graphique *Les 10 compteurs ayant comptabilisé le plus de vélos* avec `seaborn`.

:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Exercise 2b: Reproducing the Figure _"The 10 Counters That Recorded the Most Bicycles"_

Following the gradual approach of Exercise 2, recreate the chart *The 10 Counters That Recorded the Most Bicycles* using `seaborn`.

:::

::::


::: {.content-visible when-profile="fr"}
## Un exemple d'alternative au _barplot_, le _lollipop chart_

Les diagrammes en bâtons (_barplot_) sont extrêmement communs, sans doute à cause de l'héritage d'Excel où ces graphiques sont faisables en deux clics. Néanmoins, en ce qui concerne le message à transmettre, ils sont loin d'être parfaits. Par exemple, les barres prennent beaucoup d'espace visuel, ce qui peut brouiller le message à transmettre sur le rapport entre les observations.

Sur le plan sémiologique, c'est-à-dire sur le plan de l'efficacité du message à transmettre, les _lollipop charts_ sont préférables : ils transmettent la même information mais avec moins de signes visuels pouvant brouiller sa compréhension.

Les _lollipop charts_ ne sont pas parfaits non plus mais sont un peu plus efficaces pour transmettre le message. Pour en savoir plus sur les alternatives au _barplot_, la conférence d'Eric Mauvière pour le réseau des _data scientists_ de la statistique publique, dont le message principal est _"Désempilez vos figures"_, mérite le détour ([disponible sur le site ssphub.netlify.app/](https://ssphub.netlify.app/talk/2024-02-29-mauviere/)).
:::

::: {.content-visible when-profile="en"}
## An Alternative to the _Barplot_: the _Lollipop Chart_

Bar charts (_barplot_) are extremely common, likely due to the legacy of Excel, where these charts can be created with just a couple of clicks. However, in terms of conveying a message, they are far from perfect. For example, the bars take up a lot of visual space, which can obscure the intended message about relationships between observations.

From a semiological perspective, that is, in terms of the effectiveness of conveying a message, _lollipop charts_ are preferable: they convey the same information but with fewer visual elements that might clutter understanding.

_Lollipop charts_ are not perfect either but are slightly more effective at conveying the message. To learn more about alternatives to bar charts, Eric Mauvière's talk for the public statistics data scientists network, whose main message is _"Unstack your figures"_, is worth exploring ([available on ssphub.netlify.app/](https://ssphub.netlify.app/talk/2024-02-29-mauviere/)).
:::


{{< include "01_matplotlib/_exo3.qmd" >}}

::: {.content-visible when-profile="fr"}
La figure obtenue dans cet exercice est la suivante:
:::
```{python}
my_range=range(1,len(df2.index)+1)

sns.set_style("ticks", {"xtick.color": "forestgreen"})

plt.hlines(y=my_range, xmin=0, xmax=df2['sum_counts'], color='black', alpha = 0.4)
plt.plot(df2['sum_counts'], my_range, "o", color = "forestgreen")

plt.yticks(my_range, df2['nom_compteur'])
plt.title("Les 10 compteurs ayant comptabilisés le plus de vélos", loc='left')
plt.xlabel('sum_counts')
plt.ylabel('La somme des vélos comptabilisés sur la période sélectionnée')
```

::: {.content-visible when-profile="fr"}
# La même figure avec `Plotnine`

`plotnine` est le nouveau venu dans l'écosystème de la visualisation en `Python`. Cette librairie est développée par `Posit`, l'entreprise à l'origine de l'éditeur `RStudio` et de l'écosystème du _tidyverse_ si central dans le langage `R`. Cette librairie vise à importer la logique de `ggplot` en `Python`, c'est-à-dire une grammaire des graphiques normalisée, lisible et flexible héritée de @wilkinson2011grammar.

Dans cette approche, un graphique est vu comme une succession de couches qui, une fois superposées, donneront la figure suivante. En soi, ce principe n'est pas différent de celui de `matplotlib`. Néanmoins, la grammaire utilisée par `plotnine` est beaucoup plus intuitive et normalisée, ce qui offrira beaucoup plus d'autonomie pour modifier sa figure.

![La logique de `ggplot` (et `plotnine`) par @nordmann2022dataviz, image elle-même empruntée à @field2012discovering](https://psyteachr.github.io/data-skills-v2/images/corsi/layers.png){width=30%}

Avec `plotnine`, il n'y a plus de point d'entrée dual figure-axe. Comme l'illustrent les slides ci-dessous :

1. On initialise une figure
2. On met à jour les couches (_layers_), un niveau d'abstraction très général concernant aussi bien les données représentées que les échelles des axes ou la couleur
3. À la fin, on peut jouer sur l'esthétique en modifiant les labels des axes, de la légende, les titres, etc.
:::

::: {.content-visible when-profile="en"}
# The Same Figure with `Plotnine`

`plotnine` is the newcomer to the `Python` visualization ecosystem. This library is developed by `Posit`, the company behind the `RStudio` editor and the _tidyverse_ ecosystem, which is central to the `R` language. This library aims to bring the logic of `ggplot` to `Python`, meaning a standardized, readable, and flexible grammar of graphics inspired by @wilkinson2011grammar.

In this approach, a chart is viewed as a succession of layers that, when combined, create the final figure. This principle is not inherently different from that of `matplotlib`. However, the grammar used by `plotnine` is far more intuitive and standardized, offering much more autonomy for modifying a chart.
![`ggplot` (and `plotnine`) logic by @nordmann2022dataviz, borrowed from @field2012discovering](https://psyteachr.github.io/data-skills-v2/images/corsi/layers.png)


With `plotnine`, there is no longer a dual figure-axis entry point. As illustrated in the slides below:

1. A figure is initialized
2. Layers are updated, a very general abstraction level that applies to the data represented, axis scales, colors, etc.
3. Finally, aesthetics can be adjusted by modifying axis labels, legend labels, titles, etc.
:::


:::: {.content-visible when-profile="en"}

:::{.cell .markdown}
Dérouler les _slides_ ci-dessous ou [cliquer ici](/slides/ggplot.qmd)
pour afficher les slides en plein écran.

```{=html}
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><iframe class="sourceCode yaml code-with-copy" src="https://rgeo.linogaliana.fr/slides/ggplot.html#/ggplot2"></iframe></div>
```

:::

::::


:::: {.content-visible when-profile="en"}

:::{.cell .markdown}
Scroll _slides_ below or [click here](/slides/ggplot.qmd)
to display slides full screen.

```{=html}
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><iframe class="sourceCode yaml code-with-copy" src="https://rgeo.linogaliana.fr/slides/ggplot.html#/ggplot2"></iframe></div>
```

:::

::::

{{< include "01_matplotlib/_exo4.qmd" >}}
{{< include "01_matplotlib/_exo4_solution.qmd" >}}


::: {.content-visible when-profile="fr"}
# Premières agrégations temporelles


::: {.callout-caution}
Pour contextualiser les données temporelles, on utilise généralement des dates sur l'axe des abscisses (_x_). Pour éviter de rendre celles-ci illisibles, il faut éviter de donner trop de détail (trop de valeurs affichées, affichage des jours quand les mois suffisent...). 

Tourner le texte verticalement pour faire rentrer plus de texte sur l'axe horizontal n'est pas une bonne idée: l'effet principal de cela est de donner un torticolis au lecteur de votre graphique. Il vaut mieux afficher moins de labels, quitte à faire une note de lecture pour les dates vraiment spéciales. 

Dans un premier temps, nous allons ignorer cette règle de bon sens. Si on voulait vraiment proposer une figure lisible, il faudrait s'atteler à rendre l'axe temporel plus lisible. Et au passage abandonner les diagrammes en barre au profit de lignes, cela fait plus de sens pour des données temporelles.
:::  

On va maintenant se concentrer sur la dimension temporelle de notre jeu de données à travers deux approches :

- Un diagramme en barre synthétisant l'information de notre jeu de données de manière mensuelle ;
- Des séries instructives sur la dynamique temporelle. Cela sera l'objet de la prochaine partie.

:::

::: {.content-visible when-profile="en"}
# Initial Temporal Aggregations

::: {.callout-caution}
To effectively contextualize time-based data, it's standard practice to use dates along the x-axis. To maintain readability, avoid overloading the axis with too much detail such as showing every single day when months would suffice.

Rotating text vertically to squeeze more labels onto the axis isn’t a great solution - it mostly just gives your reader a sore neck. It’s often better to reduce the number of labels and, if needed, add annotations for particularly important dates.

For now, we'll ignore this common-sense advice. If we truly wanted to make our chart readable, we’d need to focus on improving the time axis formatting. And while we're at it, switching from bar charts to line plots generally makes more sense when working with time series data.
:::  

We will now focus on the temporal dimension of our dataset using two approaches:

- A bar chart summarizing the information in our dataset on a monthly basis;
- Informative series on temporal dynamics, which will be the subject of the next section.
:::

::: {.content-visible when-profile="fr"}
Pour commencer, reproduisons la troisième figure qui est, encore une fois, un _barplot_. Ici, sur le plan sémiologique, ce n'est pas justifié d'utiliser un _barplot_, une simple série suffirait à fournir une information similaire.

La première question du prochain exercice implique une première rencontre avec une donnée temporelle à travers une opération assez classique en séries temporelles : changer le format d'une date pour pouvoir faire une agrégation à un pas de temps plus large.
:::

::: {.content-visible when-profile="en"}
To begin, let us reproduce the third figure, which is, once again, a _barplot_. Here, from a semiological perspective, it is not justified to use a _barplot_; a simple time series would suffice to provide similar information.

The first question in the next exercise involves an initial encounter with temporal data through a fairly common time series operation: changing the format of a date to allow aggregation at a broader time step.
:::


{{< include "01_matplotlib/_exo5.qmd" >}}
{{< include "01_matplotlib/_exo5_solution.qmd" >}}


::: {.content-visible when-profile="fr"}

# Première série temporelle

Il est plus commun de représenter les données ayant une dimension temporelle sous la forme de série que de barres empilées.

:::: {.callout-tip}
## Exercice 5: barplot des comptages mensuels

1. Créer une variable `day` qui transforme l'horodatage en format journalier du type `2021-05-01` avec `dt.day`.
2. Reproduire la figure de la page d'_open data_.

:::

::::

:::: {.content-visible when-profile="en"}

# First Time Series

It is more common to represent data with a temporal dimension as a series rather than stacked bars.

::: {.callout-tip}
## Exercise 5: Barplot of Monthly Counts

1. Create a `day` variable that converts the timestamp into a daily format like `2021-05-01` using `dt.day`.
2. Reproduce the figure from the _open data_ page.

:::

::::


```{python}
df['day'] = df['date'].dt.date
moyenne_quotidienne = df.groupby('day', as_index=False).agg({'sum_counts':'mean'})
moyenne_quotidienne['day'] = pd.to_datetime(moyenne_quotidienne['day'])
```

```{python}
# Version plotnine
figure4 = (
    ggplot(moyenne_quotidienne, aes(x = "day", y = 'sum_counts')) +
    geom_line(color = "magenta") +
    geom_area(fill="magenta", alpha = 0.6) +
    labs(
        x = "Date et heure de comptage (Jour)",
        y = "Moyenne journalière du comptage par heure\nsur la période sélectionnée",
       title = "Moyenne journalière des comptages vélos"
    ) +
    theme_minimal() +
    theme(
        axis_text_x = element_text(angle = 45, hjust = 1),
        plot_title = element_text(hjust = 0.5)
    )
)
figure4
```


```{python}
#| output: false

# Version matplotlib
plt.clf()
ax = sns.lineplot(x='day', y='sum_counts', data=moyenne_quotidienne, color = "magenta")
l1 = ax.lines[0]
x1 = l1.get_xydata()[:, 0]
y1 = l1.get_xydata()[:, 1]
ax.fill_between(x1, y1, color="magenta", alpha=0.3)
```


::: {.content-visible when-profile="fr"}
# Des graphiques réactifs grâce aux librairies `Javascript`

::: {.callout-important}
On appelle _tooltip_ le texte qui s'affiche en surbrillance lorsqu'on passe la souris sur un élément de la figure (ordinateur) ou lorsqu'on clique sur la figure (smartphone). Il s'agit donc d'un niveau d'information supplémentaire permis par l'interactivité, qui peut être pratique pour alléger le message principal d'une figure.

Néanmoins, comme toute information sur une figure, du travail pour rendre celle-ci utile est nécessaire. On peut rarement se contenter du _tooltip_ par défaut d'une librairie: il faut réfléchir au message que celui-ci doit passer, complément textuel à l'information visuelle représentée sur la figure. 

Encore une fois, nous n'allons pas creuser ce sujet - c'est l'objet, en soi, d'un cours de _data visualisation_ - mais avoir en tête cet enjeu est important pour la réception d'une visualisation.

Par ailleurs, un autre élément que nous mettons totalement de côté ici mais qui est important lorsqu'on rentre dans le monde de la visualisation interactive est celui de la _responsiveness_, c'est-à-dire de la capacité d'une visualisation, et plus généralement d'un site web, à être lisible et fonctionnel sur des tailles d'écran différentes. Gérer des tailles d'écran différentes est compliqué mais est indispensable si on vise un public large dont une partie croissante utilise des smartphones pour consulter un site web.

A ceci s'ajoute des questions d'adaptabilité du site à différentes formes de handicaps visuels. Par exemple, ce serait environ 8% des hommes qui seraient atteints d'une forme de daltonisme, avec des formes différentes (6% ont des difficultés à percevoir les nuances de vert, 2% de rouge).

Bref, vous qui entrez dans le monde de la visualisation, laissez toute espérance de simplicité. Les outils sont simples d'usage mais les besoins sont complexes. 
:::  


## L'écosystème disponible depuis `Python`

Les figures figées construites avec `matplotlib` ou `plotnine` sont figées et présentent ainsi l'inconvénient de ne pas permettre d'interaction avec le lecteur. Toute l'information doit donc être contenue dans la figure, ce qui peut la rendre difficile à lire. Si la figure est bien faite, avec différents niveaux d'information, cela peut bien fonctionner.

Il est néanmoins plus simple, grâce aux technologies _web_, de proposer des visualisations à plusieurs niveaux. Un premier niveau d'information, celui du coup d'œil, peut suffire à assimiler les principaux messages de la visualisation. Ensuite, un comportement plus volontaire de recherche d'information secondaire peut permettre d'en savoir plus. Les visualisations réactives, qui sont maintenant la norme dans le monde de la _dataviz_, permettent ce type d'approche : le lecteur d'une visualisation peut passer sa souris à la recherche d'informations complémentaires (par exemple, les valeurs exactes) ou cliquer pour faire apparaître des informations complémentaires sur la visualisation ou autour.

Ces visualisations reposent sur le même triptyque que l'ensemble de l'écosystème _web_ : `HTML`, `CSS` et `JavaScript`. Les utilisateurs de `Python` ne vont jamais manipuler directement ces langages, qui demandent une certaine expertise, mais vont utiliser des librairies au niveau de `R` qui génèreront automatiquement tout le code `HTML`, `CSS` et `JavaScript` permettant de créer la figure.

Il existe plusieurs écosystèmes `Javascript` mis à disposition des développeurs.euses par le biais de `Python`. Les deux principales librairies sont [`Plotly`](https://plotly.com/python/), associée à l'écosystème `Javascript` du même nom, et [`Altair`](https://altair-viz.github.io/), associée à l'écosystème `Vega` et `Altair` en `Javascript`[^star]. Pour permettre aux pythonistes de découvrir la librairie `Javascript` émergente [`Observable Plot`](https://observablehq.com/plot/), l'ingénieur de recherche français Julien Barnier a développé [`pyobsplot`](https://juba.github.io/pyobsplot/) une librairie `Python` permettant d'utiliser cet écosystème depuis `Python`.

[^star]: Le nom de ces librairies est inspiré de la constellation du triangle d'été dont Véga et Altair sont deux membres.

L'interactivité ne doit pas juste être un gadget n'apportant pas de lisibilité supplémentaire, voire la détériorant. Il est rare de pouvoir se contenter de la figure produite sans avoir à fournir un travail supplémentaire pour la rendre efficace.
:::

::: {.content-visible when-profile="en"}

# Reactive Charts with `Javascript` Libraries

::: {.callout-important}
A *tooltip* is the text that appears when hovering over an element in a chart on a computer, or when tapping on it on a smartphone. It adds an extra layer of information through interactivity and can be a useful way to declutter the main message of a visualization.

That said, like any element of a chart, a tooltip requires thoughtful design to be effective. The default tooltips provided by visualization libraries are rarely sufficient. You need to consider what message the tooltip should convey as a textual complement to the visual data shown in the chart.

Again, we won’t go into detail here - this topic alone could fill an entire data visualization course - but it is important to keep in mind when designing interactive charts.

Another important topic we won’t cover here is *responsiveness*: the ability of a visualization (or a website more generally) to display clearly and function properly across different screen sizes. Designing for multiple devices is challenging but essential, especially given that a growing share of web traffic now comes from smartphones.

In addition, accessibility is another crucial consideration in interactive visualizations. For instance, around 8% of men have some form of color vision deficiency, most commonly difficulty perceiving green (about 6%) or red (about 2%).

In short, ye who enter to data visualization, abandon all hope. While the tools themselves may be easy to use, the needs they must meet are often complex.

:::  


## The Ecosystem Available from `Python`

Static figures created with `matplotlib` or `plotnine` are fixed and thus have the disadvantage of not allowing interaction with the viewer. All the information must be contained in the figure, which can make it difficult to read. If the figure is well-made with multiple levels of information, it can still work well.

However, thanks to _web_ technologies, it is simpler to offer visualizations with multiple levels. A first level of information, the quick glance, may be enough to grasp the main messages of the visualization. Then, a more deliberate behavior of seeking secondary information can provide further insights. Reactive visualizations, now the standard in the _dataviz_ world, allow for this approach: the viewer can hover over the visualization to find additional information (e.g., exact values) or click to display complementary details.

These visualizations rely on the same triptych as the entire _web_ ecosystem: `HTML`, `CSS`, and `JavaScript`. `Python` users will not directly manipulate these languages, which require a certain level of expertise. Instead, they use libraries that automatically generate all the necessary `HTML`, `CSS`, and `JavaScript` code to create the figure.

Several `Javascript` ecosystems are made available to developers through `Python`. The two main libraries are [`Plotly`](https://plotly.com/python/), associated with the `Javascript` ecosystem of the same name, and [`Altair`](https://altair-viz.github.io/), associated with the `Vega` and `Altair` ecosystems in `Javascript`[^star]. To allow Python users to explore the emerging `Javascript` library [`Observable Plot`](https://observablehq.com/plot/), French research engineer Julien Barnier developed [`pyobsplot`](https://juba.github.io/pyobsplot/), a `Python` library enabling the use of this ecosystem from `Python`.

[^star]: The names of these libraries are inspired by the Summer Triangle constellation, of which Vega and Altair are two members.

Interactivity should not just be a gimmick that adds no readability or even worsens it. It is rare to rely solely on the figure as produced without further work to make it effective.
:::

::: {.content-visible when-profile="fr"}
## La librairie `Plotly`

Le package `Plotly` est une surcouche à la librairie `Javascript` `Plotly.js` qui permet de créer et manipuler des objets graphiques de manière très flexible afin de produire des objets réactifs sans avoir à recourir à Javascript.

Le point d'entrée recommandé est le module `plotly.express` ([documentation ici](https://plotly.com/python/plotly-express/)) qui offre une approche intuitive pour construire des graphiques pouvant être modifiés *a posteriori* si besoin (par exemple pour *customiser* les axes).

::: {.callout-note}
## Visualiser les figures produites par `Plotly`

Dans un _notebook_ `Jupyter` classique, les lignes suivantes de code permettent d'afficher le résultat d'une commande `Plotly` sous un bloc de code :

```{python}
#| eval: false
from plotly.offline import init_notebook_mode
init_notebook_mode(connected = True)
```

Pour `JupyterLab`, l'extension `jupyterlab-plotly` s'avère nécessaire:

```python
!jupyter labextension install jupyterlab-plotly
```

:::

## Réplication de l'exemple précédent avec `Plotly`

Les modules suivants seront nécessaires pour construire des graphiques avec `plotly`:

```{python}
#| echo: true
import plotly
import plotly.express as px
```
:::

::: {.content-visible when-profile="en"}
## The `Plotly` Library

The `Plotly` package is a wrapper for the `Javascript` library `Plotly.js`, allowing for the creation and manipulation of graphical objects very flexibly to produce interactive objects without the need for Javascript.

The recommended entry point is the `plotly.express` module ([documentation here](https://plotly.com/python/plotly-express/)), which provides an intuitive approach for creating charts that can be modified *post hoc* if needed (e.g., to customize axes).

::: {.callout-note}
## Displaying Figures Created with `Plotly`

In a standard `Jupyter` notebook, the following lines of code allow the output of a `Plotly` command to be displayed under a code block:

```{python}
#| eval: false
from plotly.offline import init_notebook_mode
init_notebook_mode(connected = True)
```

For `JupyterLab`, the `jupyterlab-plotly` extension is required:

```python
!jupyter labextension install jupyterlab-plotly
```

:::

## Replicating the Previous Example with `Plotly`

The following modules will be required to create charts with `plotly`:

```{python}
#| echo: true
import plotly
import plotly.express as px
```
:::


:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice 7: un barplot avec `Plotly`

L'objectif est de reconstruire le premier diagramme en barre rouge avec `Plotly`.

1. Réalisez le graphique en utilisant la fonction adéquate avec `plotly.express` et...
    * Ne pas prendre le thème par défaut mais un à fond blanc, pour avoir un résultat ressemblant à celui proposé sur le site de l'*open-data*.
    * Pour la couleur rouge, vous pouvez utiliser l'argument `color_discrete_sequence`.
    * Ne pas oublier de nommer les axes.
    * Pensez à la couleur du texte de l'axe inférieur.

2. Tester un autre thème, à fond sombre. Pour les couleurs, faire un groupe stockant les trois plus fortes valeurs puis les autres.

:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Exercise 7: A Barplot with `Plotly`

The goal is to recreate the first red bar chart using `Plotly`.

1. Create the chart using the appropriate function from `plotly.express` and...
    * Do not use the default theme but one with a white background to achieve a result similar to that on the *open-data* site.
    * Use the `color_discrete_sequence` argument for the red color.
    * Remember to label the axes.
    * Consider the text color for the lower axis.

2. Try another theme with a dark background. For colors, group the three highest values together and separate the others.

:::

::::

::: {.content-visible when-profile="fr"}
```{python}
#| output: false
# 1. Graphique avec fond blanc
fig = px.bar(
    df1.sort_values('sum_counts', ascending=True),
    orientation='h', x='sum_counts',
    y='nom_compteur', color_discrete_sequence=["red"], template="plotly_white"
)

fig.update_layout(
    title='Les 10 compteurs avec la moyenne horaire la plus élevée',
    xaxis_title='Moyenne du comptage par heure sur la période sélectionnée')
fig.update_xaxes(title_font=dict(color='red'))
```

```{python}
#| output: false

# 2. Graphique avec thème sombre
df1['top'] = df1['sum_counts'] > df1.sort_values('sum_counts', ascending=False)['sum_counts'][3]
fig2 = px.bar(
    df1.sort_values('sum_counts', ascending=True), orientation='h', x='sum_counts',
    y='nom_compteur', color='top', # attention, l'argument color ne semble pas toujours fonctionner
    template="plotly_dark",
    color_discrete_sequence=['red','green']
)
fig2.update_layout(
    title='Les 10 compteurs avec la moyenne horaire la plus élevée',
    xaxis_title='Moyenne du comptage par heure sur la période sélectionnée'
)
```
:::

::: {.content-visible when-profile="en"}
```{python}
#| output: false
# 1. Chart with white background
fig = px.bar(
    df1.sort_values('sum_counts', ascending=True),
    orientation='h', x='sum_counts',
    y='nom_compteur', color_discrete_sequence=["red"], template="plotly_white"
)

fig.update_layout(
    title='The 10 counters with the highest hourly average',
    xaxis_title='Average count per hour over the selected period')
fig.update_xaxes(title_font=dict(color='red'))
```

```{python}
#| output: false

# 2. Chart with dark theme
df1['top'] = df1['sum_counts'] > df1.sort_values('sum_counts', ascending=False)['sum_counts'][3]
fig2 = px.bar(
    df1.sort_values('sum_counts', ascending=True), orientation='h', x='sum_counts',
    y='nom_compteur', color='top', # note: the color argument might not always work
    template="plotly_dark",
    color_discrete_sequence=['red','green']
)
fig2.update_layout(
    title='The 10 counters with the highest hourly average',
    xaxis_title='Average count per hour over the selected period'
)
```
:::


::: {.content-visible when-format="html"}

::: {.content-visible when-profile="fr"}
La première question permet de construire le graphique suivant :
:::

::: {.content-visible when-profile="en"}
The first question allows the creation of the following chart:
:::

```{python}
fig.show()
```

::: {.content-visible when-profile="fr"}
Alors qu’avec le thème sombre (question 2), on obtient :
:::

::: {.content-visible when-profile="en"}
Whereas with the dark theme (question 2), we get:
:::

```{python}
fig2.show()
```

:::


::: {.content-visible when-profile="fr"}
## La librairie `altair`

Pour cet exemple, nous allons reconstruire notre figure précédente.
:::

::: {.content-visible when-profile="en"}
## The `altair` Library

For this example, we will recreate our previous figure.
:::

```{python}
df1 = (
    df
    .groupby('nom_compteur')
    .agg({'sum_counts': "mean"})
    .sort_values('sum_counts', ascending = False)
    .head(10)
    .sort_values('sum_counts')
)
```

::: {.content-visible when-profile="fr"}
Comme `ggplot`/`plotnine`, `Vega` est un écosystème graphique visant à proposer une implémentation de la grammaire des graphiques de @wilkinson2011grammar. La syntaxe de `Vega` est donc basée sur un principe déclaratif : on déclare une construction par couches et transformations de données progressives.

À l'origine, `Vega` est basée sur une syntaxe JSON, d'où son lien fort avec `Javascript`. Néanmoins, il existe une API Python qui permet de faire ce type de figures interactives nativement en Python. Pour comprendre la logique de construction d'un code `altair`, voici comment répliquer la figure précédente avec :
:::

::: {.content-visible when-profile="en"}
Like `ggplot`/`plotnine`, `Vega` is a graphics ecosystem designed to implement the grammar of graphics from @wilkinson2011grammar. The syntax of `Vega` is therefore based on a declarative principle: a construction is declared through layers and progressive data transformations.

Originally, `Vega` was based on a JSON syntax, hence its strong connection to `Javascript`. However, there is a Python API that allows for creating these types of interactive figures natively in Python. To understand the logic of constructing an `altair` code, here is how to replicate the previous figure:
:::


::: {.content-visible when-profile="fr"}

```{python}
#| code-fold: true
#| code-summary: "Voir l'architecture d'une figure altair"
#| echo: true
import altair as alt

fig2 = (
    alt.Chart(df1.reset_index()) # <1>
    .mark_bar(color='steelblue') 
    .encode( # <2>
        x=alt.X('sum_counts:Q', title='Moyenne du comptage par heure sur la période sélectionnée'), # <3>
        y=alt.Y('nom_compteur:N', sort='-x', title=''),
        tooltip=[ # <4>
            alt.Tooltip('nom_compteur:N', title='Nom du compteur'),
            alt.Tooltip('sum_counts:Q', title='Moyenne horaire')
        ]
    ).properties( # <5>
        title='Les 10 compteurs avec la moyenne horaire la plus élevée'
    ).configure_view(
        strokeOpacity=0
    )
)

fig2.interactive()
```

1. On déclare d'abord le _dataframe_ qui sera utilisé, comme nous le faisions avec `ggplot(df)` avec `plotnine`. Puis le type de figure désirée (ici un diagramme en barre, `mark_bar` dans la grammaire d'`altair`).
2. On définit notre couche principale avec `encode`. Celle-ci peut accepter simplement des noms de colonnes ou des constructeurs plus complexes, comme ici.
3. On définit un constructeur pour notre axe des _x_, à la fois pour gérer l'échelle des valeurs mais aussi les paramètres de celle-ci (labels, etc.). Ici, on définit l'axe des _x_ comme une valeur continue (`:Q`), moyenne de `sum_counts` pour chaque valeur de $y$. Cette moyenne n'est pas indispensable, on aurait pu se contenter d'écrire `sum_counts:Q` voire même `sum_counts` mais c'est pour illustrer la gestion des transformations de données dans `altair`.
4. Le _tooltip_ nous permet de gérer l'interactivité de notre figure.
5. Les propriétés viennent à la fin de notre déclaration pour finaliser la figure.

:::

::: {.content-visible when-profile="en"}

```{python}
#| code-fold: true
#| code-summary: "View the architecture of an Altair figure"
#| echo: true
import altair as alt

fig2 = (
    alt.Chart(df1.reset_index())  # <1>
    .mark_bar(color='steelblue')
    .encode(  # <2>
        x=alt.X('sum_counts:Q', title='Average count per hour over the selected period'),  # <3>
        y=alt.Y('nom_compteur:N', sort='-x', title=''),
        tooltip=[  # <4>
            alt.Tooltip('nom_compteur:N', title='Counter name'),
            alt.Tooltip('sum_counts:Q', title='Hourly average')
        ]
    ).properties(  # <5>
        title='Top 10 counters by hourly average count'
    ).configure_view(
        strokeOpacity=0
    )
)

fig2.interactive()
```

1. First, the _dataframe_ to be used is declared, similar to `ggplot(df)` in `plotnine`. Then, the desired chart type is specified (in this case, a bar chart, `mark_bar` in Altair's grammar).
2. The main layer is defined using `encode`. This can accept either simple column names or more complex constructors, as shown here.
3. A constructor is defined for the x-axis, both to manage value scaling and its parameters (e.g., labels). Here, the x-axis is defined as a continuous value (`:Q`), the average of `sum_counts` for each $y$ value. This average is not strictly necessary; we could have used `sum_counts:Q` or even `sum_counts`, but this illustrates data transformations in `altair`.
4. The _tooltip_ adds interactivity to the chart.
5. Properties are specified at the end of the declaration to finalize the chart.

:::

::: {.content-visible when-profile="fr"}
# Références {-}
:::

::: {.content-visible when-profile="en"}
# References {-}
:::


::: {#refs}
:::