---
title: "Introduction à la cartographie avec Python"
title-en: "Introduction to cartography with Python"
author: Lino Galiana
tags:
  - Visualisation
  - geopandas
  - cartes
  - Cartographie
  - Exercice
categories:
  - Visualisation
  - Exercice
description: |
  La cartographie est un excellent moyen de diffuser de la connaissance sur les données, y compris à des publics peu familiers de la statistique. Ce chapitre permet de découvrir le défi de la cartographie et la manière dont on peut utiliser `Python` pour construire des cartes. 
description: |
  Mapping is an excellent way of disseminating knowledge about data, even to audiences unfamiliar with statistics. This chapter looks at the challenge of mapping and how you can use `Python` to build maps. 
image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/cartography.png
bibliography: ../../reference.bib
echo: false
---

{{< badges
    printMessage="true"
>}}

:::: {.content-visible when-profile="fr"}

::: {.callout-tip collapse="true"}

## Compétences à l'issue de ce chapitre

- Comprendre les enjeux de la cartographie appliquée à la visualisation des données spatiales ;
- Utiliser Python pour créer des cartes, en mobilisant les principes de base de la représentation géographique ;
- Explorer les exercices proposés pour appréhender les techniques cartographiques en pratique ;
- Appliquer les outils et méthodes vus dans la partie sur données spatiales pour produire des visualisations cartographiques efficaces ;
- Maîtriser la progression pédagogique visant à traduire l’information spatiale en carte informative.



:::

::::

  
::::: {.content-visible when-profile="en"}

::: {.callout-tip collapse="true"}

## Skills you will acquire in this chapter

- Understand the key challenges of cartography when visualizing spatial data  
- Use Python to create maps based on core principles of geographic representation  
- Work through hands-on exercises to explore practical cartographic techniques  
- Apply tools and methods from the spatial data section to build effective map-based visualizations  
- Follow the pedagogical progression to learn how to translate spatial information into clear, informative maps  


:::

::::


:::: {.content-visible when-profile="fr"}
# Introduction

La cartographie est l'une des plus anciennes représentations d'informations sous forme graphique. Longtemps cantonnée aux domaines militaires et administratifs ou à la synthèse d'informations pour la navigation, la cartographie est, au moins depuis le XIXe siècle, une des formes privilégiées de représentation de l'information. Il s'agit de l'époque où la carte par aplat de couleur, dite carte choroplèthe, a commencé à devenir une représentation de données géographiques traditionnelle.

D'après @chen2008brief, la première représentation de ce type a été proposée par Charles Dupin en 1826 [@fig-dupin] pour représenter les niveaux d'instruction sur le territoire français. L'émergence des cartes choroplèthes est en effet indissociable de l'organisation du pouvoir sous forme d'entités politiques supposées unitaires. Par exemple, les cartes du monde représentent souvent des aplats de couleurs à partir des nations, les cartes nationales à partir d'échelons administratifs (régions, départements, communes, mais aussi États ou _Länder_).

![La première carte choroplèthe par Dupin (1826)](https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/Carte_figurative_de_l%27instruction_populaire_de_la_France.jpg/800px-Carte_figurative_de_l%27instruction_populaire_de_la_France.jpg){#fig-dupin width="50%" fig-align="center"}

On peut voir l'émergence pendant le XIXe siècle de la carte choroplèthe comme un moment important de la cartographie, un glissement de l'usage militaire vers l'usage politique. Il ne s'agissait plus exclusivement de représenter le territoire physique mais aussi la réalité socioéconomique, dans des bornes administratives connues de tous.

Avec la prolifération de données géolocalisées et l'usage accru de données pour la décision, il est devenu crucial pour les _data scientists_ de savoir faire une carte rapidement. Ce chapitre, complément de celui sur les [données spatiales](/content/manipulation/03_geopandas_intro.qmd), propose quelques exercices pour apprendre les enjeux de la représentation de données sous forme cartographique avec `Python`.

::: {.callout-note}
Produire de belles cartes demande du temps mais aussi du bon sens. Comme toute représentation graphique, il est important de réfléchir au message à faire passer et aux moyens appropriés.  
La sémiologie cartographique, une discipline scientifique qui s'intéresse aux messages transmis par les cartes, propose certaines règles pour éviter de transmettre des messages faussés, volontairement ou involontairement.

Certaines peuvent être retrouvées à travers des conseils pratiques dans ce [guide de sémiologie cartographique](https://www.insee.fr/fr/statistiques/3640429) de l'Insee. Celles-ci sont reprises dans [ce guide](https://juliedjidji.github.io/memocarto/semio.html).

[Cette présentation](https://neocarto.github.io/docs/slides/ENTPE/docs/#/title-slide) de Nicolas Lambert revient, à partir de nombreux exemples, sur quelques principes de la _dataviz_ cartographique.
:::

Ce chapitre présentera d'abord quelques fonctionnalités basiques de [`Geopandas`](https://geopandas.org/mapping.html) pour la construction de cartes figées. Pour contextualiser l'information présentée, nous utiliserons des contours officiels produits par l'IGN. Nous proposerons ensuite des cartes avec une contextualisation accrue et plusieurs niveaux d'information, ce qui permettra d'illustrer l'intérêt de l'utilisation de librairies réactives, s'appuyant sur `JavaScript`, comme [`Folium`](https://python-visualization.github.io/folium/latest/).
::::

:::: {.content-visible when-profile="en"}
# Introduction

Cartography is one of the oldest forms of graphical representation of information. Historically confined to military and administrative uses or navigation-related information synthesis, cartography has, at least since the 19th century, become one of the preferred ways to represent information. It was during this period that the color-shaded map, known as the choropleth map, began to emerge as a standard way to visualize geographic data.

According to @chen2008brief, the first representation of this type was proposed by Charles Dupin in 1826 [@fig-dupin] to illustrate literacy levels across France. The rise of choropleth maps is closely linked to the organization of power through unitary political entities. For instance, world maps often use color shades to represent nations, while national maps use administrative divisions (regions, departments, municipalities, as well as states or _Länder_).

![The first choropleth map by Dupin (1826)](https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/Carte_figurative_de_l%27instruction_populaire_de_la_France.jpg/800px-Carte_figurative_de_l%27instruction_populaire_de_la_France.jpg){#fig-dupin width="50%" fig-align="center"}

The emergence of choropleth maps during the 19th century marks an important shift in cartography, transitioning from military use to political application. No longer limited to depicting physical terrain, maps began to represent socioeconomic realities within well-defined administrative boundaries.

With the proliferation of geolocated data and the increasing use of data-driven decision-making, it has become crucial for _data scientists_ to quickly create maps. This chapter, complementing the one on [spatial data](/content/manipulation/03_geopandas_intro.qmd), offers exercises to explore the key principles of data visualization through cartography using `Python`.

::: {.callout-note}
Creating high-quality maps requires time but also thoughtful decision-making. Like any graphical representation, it is essential to consider the message being conveyed and the most appropriate means of representation.  
Cartographic semiology, a scientific discipline focusing on the messages conveyed by maps, provides guidelines to prevent misleading representations—whether intentional or accidental.

Some of these principles are outlined in this [cartographic semiology guide](https://www.insee.fr/fr/statistiques/3640429) from Insee. They are also summarized in [this guide](https://juliedjidji.github.io/memocarto/semio.html).

[This presentation](https://neocarto.github.io/docs/slides/ENTPE/docs/#/title-slide) by Nicolas Lambert, using numerous examples, explores key principles of cartographic _dataviz_.
:::

This chapter will first introduce some basic functionalities of [`Geopandas`](https://geopandas.org/mapping.html) for creating static maps. To provide context to the presented information, we will use official geographic boundaries produced by IGN. We will then explore maps with enhanced contextualization and multiple levels of information, illustrating the benefits of using interactive libraries based on `JavaScript`, such as [`Folium`](https://python-visualization.github.io/folium/latest/).
::::



::: {.content-visible when-profile="fr"}
## Données utilisées

Au cours de ce chapitre, nous allons utiliser plusieurs jeux de données pour illustrer différents types de cartes :

- Des comptages de population ;
- Les limites départementales de la France métropolitaine ;
- Les limites communales du Finistère ;
- Le couvert forestier du département des Landes ;
- La localisation des stations Vélib' ;

## Installations préalables

Avant de pouvoir commencer, il est nécessaire d'installer quelques packages au préalable :
:::

::: {.content-visible when-profile="en"}
## Data Used

Throughout this chapter, we will use several datasets to illustrate different types of maps:

- Population counts;
- Departmental boundaries of metropolitan France;
- Municipal boundaries of Finistère;
- Forest cover in the Landes department;
- The location of Vélib' stations;

## Prerequisite installations

Before getting started, a few packages need to be installed:
:::

```{python}
#| eval: false
#| echo: true

# Sur colab
!pip install pandas fiona shapely pyproj rtree geopandas #<1> 
```
1. Ces librairies sont utiles pour l'analyse géospatiale (cf. [chapitre dédié](/content/manipulation/03_geopandas_intro.qmd))

::: {.content-visible when-profile="fr"}
Nous allons principalement avoir besoin de `Pandas` et `GeoPandas` pour ce chapitre.
:::

::: {.content-visible when-profile="en"}
We will primarily need `Pandas` and `GeoPandas` for this chapter.
:::

```{python}
#| echo: true
import pandas as pd
import geopandas as gpd
```

::: {.content-visible when-profile="fr"}
# Premières cartes pour connaître l'emprise spatiale de ses données

Nous allons utiliser `cartiflette` qui facilite la récupération des fonds de carte administratifs de l'IGN. Ce package est un projet interministériel visant à offrir une interface simple par le biais de `Python` pour récupérer des découpages officiels de l'IGN.

En premier lieu, nous allons récupérer les limites des départements :
:::

::: {.content-visible when-profile="en"}
# First Maps to Understand the Spatial Coverage of Your Data

We will use `cartiflette`, which simplifies the retrieval of administrative basemaps from IGN. This package is an interministerial project designed to provide a simple `Python` interface for obtaining official IGN boundaries.

First, we will retrieve the departmental boundaries:
:::

```{python}
#| echo: true
#| output: false
from cartiflette import carti_download

departements = carti_download(
    values="France",
    crs=4326,
    borders="DEPARTEMENT",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE_DROM_RAPPROCHES",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022,
)
```

::: {.content-visible when-profile="fr"}
Ces données rapprochent les DROM de la France hexagonale comme c'est expliqué dans l'un des [tutoriels de `cartiflette`](https://github.com/inseeFrLab/cartiflette-website/) et comme l'exercice 1 permettra de le vérifier.
:::

::: {.content-visible when-profile="en"}
These data bring the DROM closer to mainland France, as explained in one of the [`cartiflette` tutorials](https://github.com/inseeFrLab/cartiflette-website/) and as Exercise 1 will allow us to verify.
:::


```{python}
communes = carti_download(
    values="29",
    crs=4326,
    borders="COMMUNE",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022,
)
```

::: {.content-visible when-profile="fr"}
L'exercice 1 vise à s'assurer que nous avons bien récupéré les contours voulus en les représentant simplement. Ceci devrait être le premier réflexe de tout _geodata scientist_.
:::

::: {.content-visible when-profile="en"}
Exercise 1 aims to ensure that we have correctly retrieved the desired boundaries by simply visualizing them. This should be the first reflex of any _geodata scientist_.
:::


:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice 1: représentation des contours avec les méthodes de `GeoPandas`

1. Utiliser la méthode `plot` sur le jeu de données `departements` pour vérifier l'emprise spatiale. Les coordonnées affichées vous évoquent quelle projection ? Vérifier avec la méthode `crs`.  
2. Reprojeter les données en Lambert 93 (EPSG: 2154) et faire la même carte.  
3. En utilisant les options `matplotlib` adéquates, représenter une carte avec les contours noirs, le fond blanc et sans axes.  
4. Faire la même carte pour les communes du Finistère.  
:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Exercise 1: Representing Boundaries with `GeoPandas` Methods

1. Use the `plot` method on the `departements` dataset to check the spatial extent. What projection do the displayed coordinates suggest? Verify using the `crs` method.  
2. Reproject the data to Lambert 93 (EPSG: 2154) and create the same map.  
3. Using appropriate `matplotlib` options, create a map with black boundaries, a white background, and no axes.  
4. Create the same map for the municipalities of Finistère.  
:::

::::


::: {.content-visible when-profile="fr"}
La carte des départements, sans modifier aucune option, ressemble à celle-ci :
:::

::: {.content-visible when-profile="en"}
The map of the departments, without modifying any options, looks like this:
:::


```{python}
# Question 1
departements.plot()
```

::: {.content-visible when-profile="fr"}
Les coordonnées affichées nous suggèrent du `WGS84`, ce qu'on peut vérifier avec la méthode `crs` :
:::

::: {.content-visible when-profile="en"}
The displayed coordinates suggest `WGS84`, which can be verified using the `crs` method:
:::


```{python}
departements.crs
```

::: {.content-visible when-profile="fr"}
Si on fait la conversion en Lambert 93 (système légal pour l'hexagone), on obtient une emprise différente mais qui est censée être plus véridique pour la métropole (mais pas pour les DROM rapprochés puisque, par exemple, la Guyane est en principe beaucoup plus grande).
:::

::: {.content-visible when-profile="en"}
If we convert to Lambert 93 (the official system for mainland France), we obtain a different extent, which is supposed to be more accurate for the mainland (but not for the relocated DROM, since, for example, French Guiana is actually much larger).
:::


```{python}
departements.to_crs(2154).plot()
```

::: {.content-visible when-profile="fr"}
Et bien sûr, on retrouve facilement les cartes ratées du [chapitre sur `GeoPandas`](/content/manipulation/03_geopandas_intro.qmd), par exemple si on applique une transformation prévue pour l'Amérique du Nord :
:::

::: {.content-visible when-profile="en"}
And of course, we can easily reproduce the failed maps from the [chapter on `GeoPandas`](/content/manipulation/03_geopandas_intro.qmd), for example, if we apply a transformation designed for North America:
:::


```{python}
#| echo: true
departements.to_crs(5070).plot()
```

::: {.content-visible when-profile="fr"}
Si on fait une carte un petit peu plus esthétique, cela nous donne :
:::

::: {.content-visible when-profile="en"}
If we create a slightly more aesthetically pleasing map, we get:
:::


```{python}
# Question 3
ax = (
  departements.boundary.plot(edgecolor = "black", linewidth=0.2)
)
ax.set_axis_off()
```

::: {.content-visible when-profile="fr"}
Et la même pour le Finistère :
:::

::: {.content-visible when-profile="en"}
And the same for Finistère:
:::

```{python}
# Question 4
ax = (
  communes.boundary.plot(edgecolor = "black", linewidth=0.2)
)
ax.set_axis_off()
```


::: {.content-visible when-profile="fr"}
Ces cartes sont simples et pourtant elles font déjà appel à des connaissances implicites. Elles demandent déjà une connaissance du territoire. Quand nous commencerons à coloriser certains départements, savoir lesquels ont des valeurs extrêmes implique de bien connaître sa géographie française. De même, cela apparaît certes évident, mais rien ne dit dans notre carte du Finistère que ce département est bordé par l'océan. Un lecteur français le verra comme une évidence, mais ce n'est pas forcément le cas d'un lecteur étranger qui, bien sûr, ne connaît pas le détail de notre géographie.

Pour cela, nous avons des parades grâce aux cartes réactives qui permettent :

* D'afficher des informations contextuelles quand on passe la souris ou clique sur un élément de la carte.
* D'afficher un fond de carte offrant des informations contextuelles comme les axes de transport, les localités ou les frontières naturelles.

Pour ceci, nous allons garder uniquement les données correspondant à une réelle emprise spatiale, ce qui exclut notre zoom de l'Île-de-France et les DROM.
:::

::: {.content-visible when-profile="en"}
These maps are simple, yet they already rely on implicit knowledge. They require familiarity with the territory. When we start coloring certain departments, recognizing which ones have extreme values will require a good understanding of French geography. Likewise, while it may seem obvious, nothing in our map of Finistère explicitly states that the department is bordered by the ocean. A French reader would see this as self-evident, but a foreign reader, who may not be familiar with the details of our geography, would not necessarily know this.

To address this, we can use interactive maps that allow:

* Displaying contextual information when hovering over or clicking on an element of the map.
* Displaying a basemap with contextual information such as transport networks, localities, or natural boundaries.

For this, we will retain only the data corresponding to an actual spatial extent, excluding our zoom on Île-de-France and the DROM.
:::

```{python}
#| echo: true
departements_no_duplicates = (
  departements
  .drop_duplicates(subset = "INSEE_DEP") #<1>
)
departements_hexagone = (
  departements_no_duplicates
  .loc[~departements['INSEE_DEP'].str.startswith("97")] #<2>
)
```
1. On retire le zoom sur l'Île de France
2. On ne garde que la France hexagonale

::: {.content-visible when-profile="fr"}
On obtient bien l'hexagone :
:::

::: {.content-visible when-profile="en"}
We successfully obtain the hexagon:
:::

```{python}
#| echo: true
departements_hexagone.plot()
```

::: {.content-visible when-profile="fr"}
Pour le prochain exercice, nous allons avoir besoin de quelques variables supplémentaires. En premier lieu, le centre géométrique de la France, qui nous permettra de placer le centre de notre carte.
:::

::: {.content-visible when-profile="en"}
For the next exercise, we will need a few additional variables. First, the geometric center of France, which will help us position the center of our map.
:::


```{python}
#| echo: true
minx, miny, maxx, maxy = departements_hexagone.total_bounds
center = [(miny + maxy) / 2, (minx + maxx) / 2]
```

::: {.content-visible when-profile="fr"}
Nous allons aussi avoir besoin d'un dictionnaire pour renseigner à `Folium` des informations sur les paramètres de notre carte.
:::

::: {.content-visible when-profile="en"}
We will also need a dictionary to provide `Folium` with information about our map parameters.
:::



::: {.content-visible when-profile="fr"}

```{python}
#| echo: true
style_function = lambda x: {
    'fillColor': 'white',  #<1>
    'color': 'black',     
    'weight': 1.5,        
    'fillOpacity': 0.0   
}
```
1. En fait, cela permettra d'avoir une couche transparente en combinant avec le paramètre `fillOpacity` à 0%.

`style_function` est une fonction anonyme qui sera utilisée dans l'exercice.

Une information qui s'affiche lorsqu'on passe la souris s'appelle un _tooltip_ en langage de développement web.
:::

::: {.content-visible when-profile="en"}

```{python}
#| echo: true
style_function = lambda x: {
    'fillColor': 'white',  #<1>
    'color': 'black',     
    'weight': 1.5,        
    'fillOpacity': 0.0   
}
```
1. In fact, this will allow for a transparent layer by combining it with the `fillOpacity` parameter set to 0%.

`style_function` is an anonymous function that will be used in the exercise.

Information that appears when hovering over an element is called a _tooltip_ in web development terminology.
:::


```{python}
#| echo: true
import folium
tooltip = folium.GeoJsonTooltip(
    fields=['LIBELLE_DEPARTEMENT', 'INSEE_DEP', 'POPULATION'],
    aliases=['Département:', 'Numéro:', 'Population:'],
    localize=True
)
```

::: {.content-visible when-profile="fr"}
Pour le prochain exercice, il faudra utiliser le _GeoDataFrame_ dans la projection Mercator. En effet, `Folium` attend des données dans cette projection car cette librairie se base sur les fonds de carte de navigation, qui sont adaptés à cette représentation. En principe, on utilise plutôt `Folium` pour des représentations locales, où la déformation des surfaces induite par la projection Mercator n'est pas problématique. 

Pour le prochain exercice, où nous représenterons la France dans son ensemble, nous faisons donc un usage quelque peu détourné de la librairie. Mais la France étant encore assez lointaine du pôle Nord, la déformation reste un prix à payer faible par rapport aux gains de l'interactivité.
:::

::: {.content-visible when-profile="en"}
For the next exercise, the _GeoDataFrame_ must be in the Mercator projection. `Folium` requires data in this projection because it relies on navigation basemaps, which are designed for this representation. Typically, `Folium` is used for local visualizations where the surface distortion caused by the Mercator projection is not problematic.

For the next exercise, where we will represent France as a whole, we are slightly repurposing the library. However, since France is still relatively far from the North Pole, the distortion remains a small trade-off compared to the benefits of interactivity.
:::


:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice 2: faire une première carte réactive avec `Folium`

1. Créer la couche de fond en utilisant l'objet `center` et le niveau `zoom_start` égal à 5.  
2. Mettre à jour celle-ci en utilisant notre `departements_hexagone` et les paramètres `style_function` et `tooltip`.
:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Exercise 2: Creating a First Interactive Map with `Folium`

1. Create the base layer using the `center` object and set `zoom_start` to 5.  
2. Update it using our `departements_hexagone` dataset and the parameters `style_function` and `tooltip`.
:::

::::


::: {.content-visible when-profile="fr"}
Voici la couche de fond de la question 1:

```{python}
m = folium.Map(location=center, zoom_start=5)
m
```

Et une fois mise en forme, cela nous donne la carte:

```{python}
folium.GeoJson(
    departements_hexagone,
    style_function=style_function,
    tooltip=tooltip
).add_to(m)

m
```

Lorsqu'on passe sa souris sur la carte ci-dessus, on obtient quelques informations contextuelles. On peut donc jouer sur différents niveaux d'information : un premier coup d'œil permet de se représenter les données dans l'espace, une recherche approfondie permet d'avoir des informations secondaires, utiles à la compréhension, mais pas indispensables.

Ces premiers exercices illustraient une situation où on ne désire représenter que les limites des polygones. C'est une carte utile pour rapidement placer son jeu de données dans l'espace, mais cela n'apporte pas d'information supplémentaire. Pour cela, il va être nécessaire d'utiliser les données tabulaires associées à la dimension spatiale.
:::

::: {.content-visible when-profile="en"}
Here is the base layer from question 1:

```{python}
m = folium.Map(location=center, zoom_start=5)
m
```

And once formatted, this gives us the map:

```{python}
folium.GeoJson(
    departements_hexagone,
    style_function=style_function,
    tooltip=tooltip
).add_to(m)

m
```

When hovering over the above map, some contextual information appears. This allows for different levels of information: at first glance, the data is spatially represented, while further exploration reveals secondary details that aid understanding but are not essential.

These initial exercises illustrated a situation where only the polygon boundaries are represented. This type of map is useful for quickly situating a dataset in space, but it does not provide additional information. To achieve that, it will be necessary to use the tabular data associated with the spatial dimension.
:::



::: {.content-visible when-profile="fr"}
# Représenter des données : un premier exemple avec une carte de couverture forestière

Pour cette partie, nous allons faire une carte du couvert forestier landais à partir de la BD Forêt produite par l'IGN. L'objectif n'est plus seulement de placer des limites du territoire d'intérêt mais de représenter de l'information sur celui-ci à partir des données présentes dans un _GeoDataFrame_.

La BD Forêt étant un peu volumineuse dans le format _shapefile_, nous proposons de la récupérer dans un format plus compressé : le _geopackage_.
:::

::: {.content-visible when-profile="en"}
# Representing Data: A First Example with a Forest Cover Map

In this section, we will create a map of the Landes forest cover using the BD Forêt dataset produced by IGN. The goal is no longer just to display the boundaries of the area of interest but to represent information about it using data from a _GeoDataFrame_.

Since BD Forêt is somewhat large in _shapefile_ format, we suggest retrieving it in a more compressed format: _geopackage_.
:::

```{python}
#| echo: true
foret = gpd.read_file(
  "https://minio.lab.sspcloud.fr/projet-formation/diffusion/r-geographie/landes.gpkg"
)
```

Nous allons aussi créer un masque pour les contours du département: 

```{python}
#| echo: true
landes = (
  departements
  .loc[departements["INSEE_DEP"] == "40"].to_crs(2154)
)
```


:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice 3: première carte par aplat de couleur

Créer une carte du couvert forestier des Landes à partir des données importées précédemment depuis la BD Forêt. Vous pouvez ajouter les limites du département pour contextualiser cette carte.

Cette carte peut être créée via `Geopandas` et `matplotlib` ou via `plotnine` (cf. [chapitre précédent](/content/visualisation/matplotlib.qmd)).
:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Exercise 3: First Choropleth Map

Create a map of the forest cover in Landes using data previously imported from the BD Forêt dataset. You can add the department boundaries to provide context for this map.

This map can be created using `Geopandas` and `matplotlib` or with `plotnine` (see [previous chapter](/content/visualization/matplotlib.qmd)).
:::

::::


::: {.content-visible when-profile="fr"}
Comme on peut le voir sur la carte (@fig-landes), le département des Landes est très forestier. Ceci est logique puisque les deux tiers du département sont couverts, ce qu'on peut vérifier avec le calcul suivant[^landes-epsg] :

[^landes-epsg]: Ce calcul est possible car les deux bases sont en projection Lambert 93 pour lequel les opérations géométriques (dont les calculs de surface) sont autorisés.
:::

::: {.content-visible when-profile="en"}
As seen on the map (@fig-landes), the Landes department is heavily forested. This makes sense since two-thirds of the department are covered, which can be verified with the following calculation[^landes-epsg-en]:

[^landes-epsg]: This calculation is possible because both datasets are in the Lambert 93 projection, which allows for geometric operations (including surface area calculations).

:::


```{python}
#| echo: true
f"Part du couvert forestier dans les Landes: {float(foret.area.sum()/landes.area):.0%}"
```



```{python}
#| fig-cap: "Couvert forestier des Landes"
#| label: fig-landes
# Version plotnine
from plotnine import *

map = (
  ggplot(foret) +
  geom_map(fill = "forestgreen", size = 0) +
  geom_map(data = landes, color = "black", size = 1, fill = None) +
  theme_void()
)

map
```

```{python}
#| output: false
# Version matplotlib
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 10))
foret.plot(ax=ax, color="forestgreen", edgecolor=None)
landes.plot(ax=ax, edgecolor="black", linewidth=1, facecolor="none")
ax.set_axis_off()
plt.show()
```

::: {.content-visible when-profile="fr"}
Ici, la carte est assez claire et donne un message relativement lisible. Bien sûr, on ne dispose pas de détails qui pourraient intéresser les curieux (par exemple, quelles localités sont particulièrement couvertes), mais on dispose d'une vision synthétique du phénomène étudié.

# Découverte des cartes choroplèthes

L'exercice précédent nous a permis de créer une carte par aplat de couleur. Ceci nous amène naturellement vers la carte choroplèthe, où l'aplat de couleur vise à représenter une information socioéconomique.

Nous allons utiliser les données de population présentes dans les données récupérées par le biais de `cartiflette`[^poplegales]. Nous allons nous amuser à créer la carte choroplèthe en lui donnant le style _vintage_ des premières cartes de Dupin (1826).

[^poplegales]: _Stricto sensu_, il faudrait vérifier que ces colonnes correspondent bien aux populations légales définies par l'Insee. Cette variable est fournie nativement par l'IGN dans ses fonds de carte. Nous laissons les lecteurs intéressés faire ce travail, qui permet de réviser les compétences `Pandas`.
:::

::: {.content-visible when-profile="en"}
Here, the map is quite clear and conveys a relatively readable message. Of course, it does not provide details that might interest curious viewers (e.g., which specific localities are particularly forested), but it does offer a synthetic view of the studied phenomenon.

# Introduction to Choropleth Maps

The previous exercise allowed us to create a solid color map. This naturally leads us to choropleth maps, where color shading is used to represent socioeconomic information.

We will use population data available from the datasets retrieved via `cartiflette`[^poplegales]. As an exercise, we will create a choropleth map styled in a _vintage_ look, reminiscent of the early maps of Dupin (1826).

[^poplegales]: _Stricto sensu_, we should verify that these columns accurately correspond to the official population counts defined by Insee. This variable is natively provided by IGN in its basemap data. We leave this verification to interested readers, as it offers a good opportunity to practice `Pandas` skills.
:::


:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice 4: une première carte de population

L'objectif de cet exercice va être d'enrichir les informations présentées sur la carte des départements.

1. Représenter rapidement la carte des départements en colorant en fonction de la variable `POPULATION`.  

   Cette carte présente plusieurs problèmes :  
   * Si vous connaissez la géographie française, vous devriez noter une forme anormale, comme si l'axe est-ouest avait été agrandi par excès. C'est parce qu'il faut reprojeter la carte en Lambert 93.  
   * Elle est peu lisible à cause de plusieurs facteurs : gradient continu, distribution non normale de la variable, légende perfectible, etc.  

   Les prochaines questions visent à améliorer ceci progressivement.

2. Refaire cette carte dans la projection Lambert 93.  
3. Discrétiser la variable `POPULATION` en utilisant 4 classes par le biais d'une discrétisation par quantile. Refaire la carte.  
4. Diviser votre population par la taille de chaque département (en km²) en créant une variable à partir de `.area.div(1e6)`[^note-mesure].  
5. Choisir une palette de couleur _vintage_ type échelle de gris.  

[^note-mesure]: Le Lambert 93 donne une aire en mètres carrés. Pour la transformer en km², il faut faire `div(1e6)`.
:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Exercise 4: A First Population Map

The goal of this exercise is to enhance the information presented on the departmental map.

1. Quickly generate a map of the departments, coloring them according to the `POPULATION` variable.  

   This map presents several issues:  
   * If you are familiar with French geography, you should notice an unusual shape, as if the east-west axis were excessively stretched. This happens because the map needs to be reprojected into Lambert 93.  
   * It is difficult to read due to several factors: continuous gradient, non-normal distribution of the variable, suboptimal legend, etc.  

   The next questions aim to improve this step by step.

2. Recreate this map using the Lambert 93 projection.  
3. Discretize the `POPULATION` variable into 4 classes using quantile-based discretization, then recreate the map.  
4. Normalize the population by the area of each department (in km²) by creating a new variable using `.area.div(1e6)`[^note-mesure-en].  
5. Choose a _vintage_ grayscale color palette.  

[^note-mesure-en]: Lambert 93 provides area in square meters. To convert it to km², use `div(1e6)`.
:::

::::


::: {.content-visible when-profile="fr"}
La première question donne une carte ayant cet aspect :
:::

::: {.content-visible when-profile="en"}
The first question produces a map that looks like this:
:::


```{python}
from plotnine import *

# Question 1
map1 = (
  ggplot(departements) +
  geom_map(aes(fill = "POPULATION")) +
  theme_void()
)

map1
```

::: {.content-visible when-profile="fr"}
Elle est déjà améliorée par l'utilisation d'une projection adaptée pour le territoire, le Lambert 93 (question 2) :
:::

::: {.content-visible when-profile="en"}
It is already improved by using a projection suited for the territory, Lambert 93 (question 2):
:::


```{python}
# Question 2
departements_l93 = departements.to_crs(2154)
map2 = (
  ggplot(departements_l93) +
  geom_map(aes(fill = "POPULATION")) +
  theme_void()
)

map2
```

::: {.content-visible when-profile="fr"}
La carte ci-dessous, après discrétisation (question 3), donne déjà une représentation plus véridique des inégalités de population. On remarque que la diagonale du vide commence à se dessiner, ce qui est logique pour une carte de population.
:::

::: {.content-visible when-profile="en"}
The map below, after discretization (question 3), already provides a more accurate representation of population inequalities. We can see the "diagonal of emptiness" starting to emerge, which is expected in a population map.
:::


```{python}
# Question 3
departements_l93['POPULATION_discrete'] = pd.Categorical(
  pd.qcut(departements['POPULATION'].div(1000).round(), q=4)
)

(
  ggplot(departements_l93) +
  geom_map(aes(fill = "POPULATION_discrete")) +
  theme_void()
)
```

::: {.content-visible when-profile="fr"}
Cependant, l'un des problèmes des choroplèthes est qu'elles donnent un poids exagéré aux grands espaces. Ceci avait été particulièrement mis en avant dans le cas des cartes électorales avec le visuel ["Land doesn't vote, people do"](https://x.com/karim_douieb/status/1181934417650040832) (version [élections européennes de 2024](https://x.com/karim_douieb/status/1800777148871188766)). 

Sans pouvoir totalement s'abstraire de ce problème — pour cela, il faudrait changer de type de représentation graphique, par exemple avec des ronds proportionnels — on peut déjà réduire l'effet de la surface sur notre variable d'intérêt en représentant la densité (population au km² plutôt que la population).
:::

::: {.content-visible when-profile="en"}
However, one of the problems with choropleth maps is that they give disproportionate visual weight to large areas. This issue was particularly highlighted in election maps with the visual ["Land doesn't vote, people do"](https://x.com/karim_douieb/status/1181934417650040832) (see the [2024 European elections version](https://x.com/karim_douieb/status/1800777148871188766)). 

While we cannot completely eliminate this issue—doing so would require switching to a different type of visualization, such as proportional circles—we can mitigate the effect of area on our variable of interest by representing density (population per km² rather than total population).
:::

```{python}
import pandas as pd

departements_l93['surface_km2'] = departements_l93.area.div(1e6)
departements_l93['densite_discrete'] = pd.qcut(
    departements_l93['POPULATION'].div(departements_l93['surface_km2']).round(),
    q=4
  )
```

::: {.content-visible when-profile="fr"}
On obtient donc la carte suivante lorsqu'on représente la densité plutôt que la population totale :
:::

::: {.content-visible when-profile="en"}
We obtain the following map when representing population density instead of total population:
:::


```{python}
(
  ggplot(departements_l93) +
  geom_map(aes(fill = "densite_discrete")) +
  theme_void() +
  scale_fill_discrete()
)
```

::: {.content-visible when-profile="fr"}
Cela nous donne déjà une image plus véridique de la distribution de la population sur le territoire français. Néanmoins, la palette de couleur _desigual_ utilisée par défaut n'aide pas trop à saisir les nuances. Avec une palette de couleur en nuancier, qui tient compte de l'aspect ordinal de nos données, on obtient une carte plus lisible (question 5) :
:::

::: {.content-visible when-profile="en"}
This already provides a more accurate picture of population distribution across France. However, the default _desigual_ color palette does not help much in capturing the nuances. Using a gradient color palette, which considers the ordinal nature of our data, results in a more readable map (question 5):
:::


```{python}
# Question 5
(
  ggplot(departements_l93) +
  geom_map(aes(fill = "densite_discrete")) +
  theme_void() +
  scale_fill_grey(start=0.2, end=0.8) +
  labs(fill = "Densité (pop/km²)")
)
```

::: {.content-visible when-profile="fr"}
C'est déjà mieux. Néanmoins, pour avoir une meilleure carte, il faudrait choisir une discrétisation plus adéquate. C'est un travail itératif important, qui mobilise plusieurs domaines de compétences : statistique, sociologie ou économie selon le type d'information représentée, informatique, etc. Bref, la palette normale de compétences d'un _data scientist_.

# Représenter des données infracommunales

Jusqu'à présent, nous avons travaillé sur des données où, en soi, représenter des frontières administratives suffisait pour contextualiser. Penchons-nous maintenant sur le cas où avoir un fonds de carte contextuel va devenir crucial : les cartes infracommunales.

Pour cela, nous allons représenter la localisation des stations Vélib'. Celles-ci sont disponibles en _open data_ sur le site de la Mairie de Paris.
:::

::: {.content-visible when-profile="en"}
This is already better. However, to create an even more effective map, a more suitable discretization method should be chosen. This is an important iterative process that requires multiple skill sets, including statistics, sociology or economics (depending on the type of information represented), and computer science. In short, the typical skill set of a _data scientist_.

# Representing Sub-Municipal Data

Until now, we have worked with data where simply displaying administrative boundaries was sufficient for context. Now, let's focus on a case where having a contextual basemap becomes crucial: sub-municipal maps.

For this, we will represent the locations of Vélib' stations. These are available as _open data_ from the Paris City Hall website.
:::

```{python}
#| echo: true
import geopandas as gpd

velib_data = "https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr"
stations = gpd.read_file(velib_data)
```

::: {.content-visible when-profile="fr"}
Si on représente directement celles-ci avec la méthode `plot`, on manque de contexte :
:::

::: {.content-visible when-profile="en"}
If we directly plot them using the `plot` method, we lack context:
:::

```{python}
#| echo: true
stations.plot()
```

::: {.content-visible when-profile="fr"}
Il est même impossible de savoir si on se trouve réellement dans Paris. On peut essayer d'associer nos données aux découpages administratifs pour vérifier que nous sommes bien dans la région parisienne.

La première étape est de récupérer les découpages des arrondissements parisiens et des communes limitrophes, ce qui se fait facilement avec `cartiflette` :
:::

::: {.content-visible when-profile="en"}
It is even impossible to determine whether we are actually in Paris. We can attempt to associate our data with administrative boundaries to confirm that we are indeed in the Paris region.

The first step is to retrieve the boundaries of Parisian districts and neighboring municipalities, which can be easily done using `cartiflette`:
:::


```{python}
#| echo: true
from cartiflette import carti_download

# 1. Fonds communaux
contours_villes_arrt = carti_download(
    values = ["75", "92", "93", "94"],
    crs = 4326,
    borders="COMMUNE_ARRONDISSEMENT",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)

# 2. Départements 
departements = contours_villes_arrt.dissolve("INSEE_DEP")
```

::: {.content-visible when-profile="fr"}
Si maintenant on utilise ce masque pour contextualiser les données, on est rassuré sur la nature des données.
:::

::: {.content-visible when-profile="en"}
If we now use this mask to provide context to the data, we can be reassured about the nature of the data.
:::


```{python}
#| echo: true
ax = stations.sample(200).plot(color = "red")
contours_villes_arrt.boundary.plot(ax=ax, edgecolor="k", linewidth=.5)
departements.boundary.plot(ax=ax, edgecolor="blue", linewidth=1)
ax.set_axis_off()
```

::: {.content-visible when-profile="fr"}
Les Parisiens reconnaîtront facilement leur bourgade car ils connaissent bien l'organisation de l'espace de cette agglomération. Cependant, pour des lecteurs ne connaissant pas celle-ci, cette carte sera de peu de secours. L'idéal est plutôt d'utiliser le fonds de carte contextuel de `Folium` pour cela.

Afin de ne pas surcharger la carte, il est utile d'utiliser la dimension réactive de `Folium` en laissant l'utilisateur.trice naviguer dans la carte et afficher un volume d'information adapté à la fenêtre visible. Pour cela, `Folium` embarque une fonctionnalité `MarkerCluster` très pratique.

On peut ainsi produire la carte désirée de cette manière :
:::

::: {.content-visible when-profile="en"}
Parisians will easily recognize their city because they are familiar with the spatial organization of this metropolitan area. However, for readers unfamiliar with it, this map will be of little help. The ideal solution is to use `Folium`'s contextual basemap.

To avoid cluttering the map, it is useful to leverage `Folium`'s interactive features, allowing the user to navigate the map and display an appropriate amount of information based on the visible window. For this, `Folium` includes a very handy `MarkerCluster` functionality.

Thus, we can create the desired map as follows:
:::

```{python}
#| code-fold: true
import folium
from folium.plugins import MarkerCluster

# 1. Calcul du centre de la carte et des bornes sw et ne
stations['lon'] = stations.geometry.x
stations['lat'] = stations.geometry.y
center = stations[['lat', 'lon']].mean().values.tolist()
sw = stations[['lat', 'lon']].min().values.tolist()
ne = stations[['lat', 'lon']].max().values.tolist()

m = folium.Map(location=center, tiles='OpenStreetMap')
marker_cluster = MarkerCluster().add_to(m)

# Add the markers to the MarkerCluster
for i in range(len(stations)):
    folium.Marker(
        location=[stations.iloc[i]['lat'], stations.iloc[i]['lon']],
        popup=stations.iloc[i]['name']
    ).add_to(marker_cluster)

# Fit the map bounds to the markers
m.fit_bounds([sw, ne])
m
```


::: {.content-visible when-profile="fr"}
# Références supplémentaires {.unnumbered}
:::

::: {.content-visible when-profile="en"}
# Additional References {.unnumbered}
:::
