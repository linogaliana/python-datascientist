---
title: "Un cadavre exquis pour d√©couvrir le travail collaboratif `Git`"
tags:
  - Git
categories:
  - Exercice
  - Git
description: |
  Ce chapitre propose une mise en application de quelques principes
  centraux du langage Git vus pr√©c√©demment.
image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/cadavre_exquis_kids.png
---


# Un cadavre exquis pour d√©couvrir le travail collaboratif

Jusqu'√† pr√©sent, nous avons d√©couvert les vertus de `Git` dans un projet
individuel. Nous allons maintenant aller plus loin dans un projet 
collectif. Pour rappel, dans le chapitre pr√©c√©dent nous avons √©voqu√© les concepts natifs de `Git` que sont d√©p√¥ts local et distant (`remote`), l'op√©ration de `clone`, _staging area_, `commit`, `push`, `pull`, les branches. Nous avons aussi √©voqu√© certains concepts li√©s √† la forge `Github` que sont l'authentification et les _issues_.

Maintenant, nous allons √©voquer les enjeux li√©s au travail collaboratif, ce qui nous am√®nera, notamment, √† √©voquer les enjeux de la gestion de conflits. 


# Le *workflow* adopt√©

Nous allons adopter le mode de travail le plus simple, le *Github flow*. Nous l'avons d√©j√† adopt√© lors du dernier exercice du chapitre pr√©c√©dent, consacr√© √† l'utilisation des branches.

Le _Github flow_ correspond √† cette forme caract√©ristique d'arbre:

1. La branche `main` constitue le tronc
2. Les branches partent de `main` et divergent
3. Lorsque les modifications aboutissent, elles sont int√©gr√©es √† `main` ; 
la branche en question dispara√Æt :

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/ghflow.png)


Il existe des *workflows* plus complexes, notamment le `Git Flow` que j'utilise
pour d√©velopper ce cours. [Ce tutoriel](https://www.atlassian.com/fr/git/tutorials/comparing-workflows/gitflow-workflow), tr√®s bien fait, 
illustre avec un graphique la complexit√© accrue de ce flow : 

![](https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg?cdnVersion=55)

Cette fois, une branche interm√©diaire, par exemple une branche `development`,
int√®gre des modifications √† tester avant de les int√©grer dans la version 
officielle (`main`).

::: {.tip}
Vous pourrez trouvez des dizaines d‚Äôarticles et d‚Äôouvrages sur ce sujet dont chacun pr√©tend avoir trouv√© la meilleure organisation du travail (_Git flow_, _GitHub flow_, _GitLab flow_...). Ne lisez pas trop ces livres et articles sinon vous serez perdus (un peu comme avec les magazines destin√©s aux jeunes parents...).

La m√©thode de travail la plus simple est le *Github flow* qu'on vous a propos√© d'adopter. L'arborescence est reconnaissable : des branches divergent et reviennent syst√©matiquement vers `main`. 

Pour des projets plus complexes dans des √©quipes d√©veloppant des applications, on pourra utiliser d'autres m√©thodes de travail, notamment le `Git flow`. Il n'existe pas de r√®gles universelles pour d√©terminer la m√©thode de travail ; l'important c'est, avant tout, de se mettre d'accord sur des r√®gles communes de travail avec votre √©quipe.

:::

## Les conflits

Au cours du dernier exercice du chapitre pr√©c√©dent, nous avons, sans vraiment l'expliquer, d√©couvert le principe du _merge_ (ou fusion, en Fran√ßais). Les fusions de versions consistent √† r√©concilier deux versions d'un code. Cela peut se faire en privil√©giant l'une sur l'autre ou bien en choisissant, dans les passages qui divergent, parfois l'une et parfois l'autre. On parle de conflits pour d√©signer une situation o√π un m√™me fichier pr√©sente deux versions diff√©rentes qui doivent √™tre r√©concili√©es. 

`Git` simplifie √©norm√©ment la gestion de conflits, c'est l'une des raisons de son succ√®s. Si vous avez d√©j√† partag√© du code par mail en √©quipe, vous devez savoir que r√©concilier des versions est extr√™mement fastidieux : il faut, plus ou moins ligne √† ligne, v√©rifier que la version que vous avez re√ßu par mail ne diff√®re pas de la v√¥tre, que vous avez fait √©voluer en parall√®le. Gr√¢ce au suivi fin de l'√©volution d'un fichier que permet `Git`, cette gestion de conflits sera facilit√©e. Il faudra tout de m√™me privil√©gier une version sur l'autre mais cela sera plus rapide et plus fiable. 

Si `Git` offre des fonctionnalit√©s int√©ressantes, pour la gestion des conflits, ce n'est n√©anmoins pas une excuse pour √™tre d√©sorganis√©. Comme nous allons le voir dans les prochains exercices, on a certes des chapitres

::: {.tip}
## M√©thode pour les merges

Lors du chapitre pr√©c√©dent, nous avons fait un _merge_ de notre branche `issue-1` vers `main`, notre branche principale. Nous sommes pass√©s par l'interface de `Github` pour faire cela. Il s'agit de la m√©thode recommand√©e pour les _merges_ vers `main`. Cela permet de garder une trace explicite de ceux-ci (par exemple [ici](https://github.com/linogaliana/python-datascientist/pulls?q=is%3Apr+is%3Aclosed)), sans avoir √† chercher dans l'arborescence, parfois complexe, d'un projet.

La bonne pratique veut qu'on fasse un `squash commit` pour √©viter une inflation du nombre de commits dans `main`: les branches ont vocation √† proposer une multitude de petits commits, les modifications dans `main` doivent √™tre simples √† tracer d'o√π le fait de modifier des petits bouts de code. 

Comme on l'a fait dans un exercice pr√©c√©dent, il est tr√®s pratique d‚Äôajouter dans le corps du message  `close #xx` o√π `xx` est le num√©ro d'une *issue* associ√©e √† la `pull request`. Lorsque la `pull request` sera fusionn√©e, l‚Äô*issue* sera automatiquement ferm√©e et un lien sera cr√©√© entre l'`issue` et la `pull request`. Cela vous permettra de comprendre, plusieurs mois ou ann√©es plus tard comment et pourquoi telle ou telle fonctionnalit√© a √©t√© impl√©ment√©e.

En revanche, l'int√©gration des derni√®res modifications de `main` vers une branche se fait en local. Si votre branche est en conflit, **le conflit doit √™tre r√©solu dans la branche et pas dans main**. 
`main` doit toujours rester propre. 
:::

## Divergence d'historique: les diff√©rentes situations

### Cas simple

Imaginons deux personnes qui collaborent sur un projet, Alice et Bob. Bob a mis de c√¥t√© le projet quelques jours. Il veut r√©cup√©rer les avanc√©es faites par Alice pendant cette p√©riode. Celle-ci a fait √©voluer le projet, supposons avec un seul _commit_ puisque cela ne change rien. 

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/ff.png){#fig-history-simple}

L'historique de Bob est coh√©rent avec celui sur `Github`, il lui manque juste le dernier _commit_ en bleu (@fig-history-simple). Il suffit donc √† Bob de r√©cup√©rer ce _commit_ en local avant de commencer √† √©diter ses fichiers.

Ce type de fusion est un _fast-forward merge_. Le commit distant est rajout√© √† l‚Äôhistorique local, sans difficult√©. Le d√©p√¥t local est √† nouveau √† jour avec le d√©p√¥t distant. 

Il s'agit du _merge_ id√©al car celui-ci peut √™tre automatis√©, il n'y a aucun risque d'√©craser des modifications faites par Bob par celles d'Alice. Une organisation d'√©quipe ad√©quate permettra de s'assurer que la plupart des _merges_ seront de ce type. 

### Cas plus compliqu√©

Maintenant, imaginons le cas plus compliqu√© o√π Bob avait fait √©voluer son code en parall√®le, sans r√©cup√©rer les modifications d'Alice avant de revenir sur le projet. 

Son historique local diverge donc de l'historique distant:

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/ff.png){#fig-history-complicated}

Les derniers commits ne sont pas les m√™mes. `Git` ne peut pas r√©soudre de lui-m√™me la divergence. C'est √† Bob de trancher sur la version qu'il pr√©f√®re. Deux strat√©gies pour r√©concilier les historiques sont accessibles:

* Le _merge_ ;
* Le _rebase_.

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/merge.png){#fig-history-merge}

Le rapatriement des modifications d'Alice dans l'historique de Bob cr√©e un premier commit de merge. Les fichiers en question pr√©senteront alors des balises permettant d'identifier la divergence de version et la source de celle-ci. Dans le fichier brut, cela donnera

  ```python
  import pandas as pd

  <<<<<<< main
  toto = pd.read_csv("source.csv")
  =======
  toto = pd.read_csv("source.csv", sep = ";")
  >>>>>>> zyx911fhjehzafoldfkjknvjnvjnj;

  toto.head(2)
  ```

`VSCode`, gr√¢ce √† l'extension `Git`, propose une visualisation native de ce bout de code et propose, en clique-bouton, diff√©rentes mani√®res de r√©concilier les versions. Il est bien s√ªr toujours possible d'√©diter ces fichiers : il suffit de supprimer les balises et modifier les lignes en question. 

![](./img/conflict.png)

Une fois les versions r√©concili√©es, il ne reste plus qu'√† faire un nouveau _commit_. Cette histoire r√©concilie les versions d'Alice et Bob. L'inconv√©nient est qu'elle rend l'historique non lin√©aire (voir la [documentation d'Atlassian](https://www.atlassian.com/fr/git/tutorials/using-branches/git-merge) pour plus de d√©tails) mais c'est `Git` qui a g√©r√© automatiquement ce sujet en cr√©ant une branche temporaire. Jusqu'√† r√©cemment, ceci √©tait le comportement par d√©faut de `Git`. 

Une autre approche est accessible, le _rebase_. 

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/rebase1.png){#fig-history-rebase1}

`Git` effectue trois √©tapes: 

1. Supprime temporairement le _commit_ local
2. R√©alise un _fast forward merge_ maintenant que le _commit_ local n'est plus l√†
3. Rajoute le commit local au bout de l'historique

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/rebase2.png){#fig-history-rebase2}

Le _commit_ local a chang√© d'identit√©, ce qui explique son nouveau SHA. Cette approche pr√©sente l'avantage de garder un historique lin√©aire. N√©anmoins, elle peut avoir des effects de bord et est donc √† utiliser avec pr√©caution (plus d'explications dans [la documentation de `Git`](https://git-scm.com/book/fr/v2/Les-branches-avec-Git-Rebaser-Rebasing#s_rebase_peril))


# Mise en pratique

::: {.exercise}
## Exercice 1 : Interactions avec le d√©p√¥t distant


Cet exercice se fait par groupe de trois ou quatre. Il y aura deux r√¥les dans ce sc√©nario :

- Une personne aura la responsabilit√© d'√™tre **mainteneur**
- Deux √† trois personnes seront **d√©veloppeurs**. 

1Ô∏è‚É£ Le.la mainteneur.e cr√©e un d√©p√¥t sur `Github` avec un `README` et un `.gitignore`. Il/Elle donne des droits au(x) d√©veloppeur.euse(s) du projet (`Settings > Manage Access > Invite a collaborator`).

2Ô∏è‚É£ Chaque membre du projet, cr√©e une copie locale du projet (un _clone_). Si vous avez un trou de m√©moire, vous pouvez retourner au chapitre pr√©c√©dent pour v√©rifier la d√©marche.

3Ô∏è‚É£ Chaque membre du projet cr√©e un fichier avec son nom et son pr√©nom, selon cette structure `nom-prenom.md` en √©vitant les caract√®res sp√©ciaux. Il √©crit dedans trois phrases de son choix **sans ponctuation ni majuscules** (pour pouvoir effectuer une correction ult√©rieurement). Enfin, il _commit_ sur le projet.

Pour rappel, en ligne de commande cela donnera les commandes suivantes √† modifier

~~~shell
git add nom-prenom.md
git commit -m "C'est l'histoire de XXXXX"
~~~

4Ô∏è‚É£ Chacun essaie d'envoyer (*push*) ses modifications locales sur le d√©p√¥t. En ligne de commande, cela donne

~~~shell
git push origin main
~~~


5Ô∏è‚É£ A ce stade, une seule personne (la plus rapide) devrait ne pas avoir rencontr√© de rejet du `push`. C'est normal, avant d'accepter une modification `Git` v√©rifie en premier lieu la coh√©rence de la branche avec le d√©p√¥t distant. Le premier ayant fait un `push` a modifi√© le d√©p√¥t commun ; les autres doivent int√©grer ces modifications dans leur version locale (*pull*) avant d'avoir le droit de proposer un  changement.

Pour celui/celle/ceux dont le `push` a √©t√© refus√©, il faudra aller dans le terminal et faire

~~~shell
git pull origin main
~~~

pour essayer de ramener les modifications distantes en local. Celui-ci devrait √©chouer et `Git` devrait vous afficher le message suivant:

```python
hint: You have divergent branches and need to specify how to reconcile them.
hint: You can do so by running one of the following commands sometime before
hint: your next pull:
hint:
hint:   git config pull.rebase false  # merge
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint:
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
fatal: Need to specify how to reconcile divergent branches.
```

Copier l'une des r√®gles propos√©es et coller dans votre terminal. Il est recommand√© de choisir la r√®gle `git config pull.rebase false` mais cela n'aura, si vous suivez les consignes, par d'incidence si vous privil√©giez `git config pull.rebase true`. 

6Ô∏è‚É£ Taper `git log` et regarder la mani√®re dont a √©t√© int√©gr√© la modification de votre camarade ayant pu faire son `push`

Vous remarquerez que les commits de vos camarades sont int√©gr√©s tels quels √† 
l'histoire du d√©p√¥t. 

7Ô∏è‚É£ Faire √† nouveau 

~~~shell
git pull origin main
~~~

Le dernier doit refaire, √† nouveau, les √©tapes 5 √† 7 (dans une √©quipe de quatre
il faudra encore le refaire une fois).

:::

__‚ùì Question : que se serait-il pass√© si les diff√©rents membres du groupe avaient effectu√© leurs modifications sur un seul et m√™me fichier ?__

Le prochain exercice offre une r√©ponse √† cette question.

::: {.exercise}
## Exercice 2 : G√©rer les conflits quand on travaille sur le m√™me fichier

Dans la continuit√© de l'exercice pr√©c√©dent, chaque personne va travailler sur les fichiers des autres membres de l'√©quipe.

1Ô∏è‚É£ Les deux ou trois d√©veloppeurs ajoutent la ponctuation et les majuscules du fichier du premier d√©veloppeur.

2Ô∏è‚É£ Ils sautent une ligne et ajoutent une phrase (pas tous la m√™me).

3Ô∏è‚É£ Valider les r√©sultats (`git add .` et `commit`) et faire un `push`

4Ô∏è‚É£ La personne la plus rapide n'a, normalement, rencontr√© aucune difficult√© (elle peut s'arr√™ter temporairement pour regarder ce qui va se passer chez les voisins). Les autres voient leur `push` refus√© et doivent faire un `pull`. 

üí• Il y a conflit, ce qui doit √™tre signal√© par un message du type :

```python
Auto-merging XXXXXX
CONFLICT (content): Merge conflict in XXXXXX.md
Automatic merge failed; fix conflicts and then commit the result.
```

5Ô∏è‚É£ Etudier le r√©sultat de `git status` 

6Ô∏è‚É£ Si vous ouvrez les fichiers incrimin√©s, vous devriez voir des balises du type

```python
<<<<<<< HEAD
this is some content to mess with
content to append
=======
totally different content to merge later
>>>>>>> new_branch_to_merge_later
```

7Ô∏è‚É£ Corriger √† la main les fichiers en choisissant, pour chaque ligne, la version qui vous convient et en retirant les balises. Valider en faisant: 

~~~python
git add . && git commit -m "R√©solution du conflit par XXXX"
~~~

Remplacer `XXXX` par votre nom. La balise `&&` permet d'encha√Æner, en une seule ligne de code, les deux commandes.

8Ô∏è‚É£ Faire un push. Pour la derni√®re personne, refaire les op√©rations 4 √† 8

:::

`Git` permet donc de travailler, en m√™me temps, sur le m√™me fichier et de limiter le nombre de gestes manuels n√©cessaires pour faire la fusion. Lorsqu'on travaille sur des bouts diff√©rents du m√™me fichier, on n'a m√™me pas besoin de faire de modification manuelle, la fusion peut √™tre automatique.

`Git` est un outil tr√®s puissant. Mais, il ne remplace pas une bonne organisation du travail. Vous l'avez vu, ce mode de travail uniquement sur `main` peut √™tre p√©nible. Les branches prennent tout leur sens dans ce cas. 

::: {.exercise}
## Exercice 3 : Gestion des branches

1Ô∏è‚É£ Le.la mainteneur.euse va contribuer directement dans `main` et ne cr√©e pas de branche. Chaque d√©veloppeur cr√©e une branche, en local nomm√©e `contrib-XXXXX` o√π `XXXXX` est le pr√©nom: 

~~~shell
git checkout -b contrib-XXXXX
~~~

2Ô∏è‚É£ Chaque membre du groupe cr√©e un fichier `README.md` o√π il √©crit une phrase sujet-verbe-compl√©ment. Le mainteneur est le seul √† ajouter un titre dans le README (qu'il _commit_ dans `main`).

3Ô∏è‚É£ Chacun _push_ le produit de son subconscient sur le d√©p√¥t.

4Ô∏è‚É£ Les d√©veloppeurs ouvrent, chacun, une _pull request_ sur `Github` de leur branche vers `main`. Ils lui donnent un titre explicite. 

5Ô∏è‚É£ Dans la discussion de chaque `pull request`, le mainteneur demande au d√©veloppeur d'int√©grer le titre qu'il a √©crit.  

6Ô∏è‚É£ Chaque d√©veloppeur, en local, int√®gre cette modification en faisant


```shell
# Pour √™tre s√ªr d'√™tre sur sa propre branche
git checkout branche-XXXX
git merge main
```

R√©gler le conflit et valider (`add` et `commit`). Pousser le r√©sultat. Le mainteneur choisit une des `pull request` et la valide avec l'option `squash commits`. V√©rifier sur la page d'accueil le r√©sultat.

7Ô∏è‚É£ L'auteur (si 2 d√©veloppeurs)  ou les deux auteurs (si 3 d√©veloppeurs) de la `pull request` non valid√©e doivent √† nouveau r√©p√©ter l'op√©ration 6. 

8Ô∏è‚É£ Une fois le conflit de version r√©gl√© et pouss√©, le mainteneur valide la `pull request` selon la m√™me proc√©dure que pr√©c√©demment. 

9Ô∏è‚É£ V√©rifier l'arborescence du d√©p√¥t dans `Insights > Network`. Votre arbre doit avoir une forme caract√©ristique de ce qu'on appelle le `Github flow`:

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/ghflow.png)

:::

Il n'est absolument pas obligatoire que chaque projet collaboratif choisisse ce mode de collaboration. Pour de nombreux projets, o√π on √©dite pas le m√™me bout de fichier en m√™me temps, passer directement par `main` est suffisant. Le mode ci-dessus est important pour des projets cons√©quents, o√π la branche `main` se doit d'√™tre irr√©prochable parce que, par exemple, elle entra√Æne une s√©rie de tests automatis√©s et le d√©ploiement automatis√© d'un livrable. Mais pour des projets plus modestes, il n'est pas indispensable d'aller dans un formalisme extr√™me. Le bon usage de `Git` est un usage pragmatique o√π celui-ci est utilis√© pour ses avantages et o√π l'organisation du travail s'adapte √† ceux-ci. 


# Conclusion

Ces chapitres consacr√©s √† `Git` ont permis de d√©mystifier ce logiciel en illustrant, par la pratique, les principaux concepts et la gymnastique quotidienne. Ils visent √† faire √©conomiser de pr√©cieuses heures car l'apprentissage de `Git` en autodidacte est souvent frustrant et incomplet. Il est indispensable de garder cette habitude de faire du `Git` sur ses projets. Ces derniers seront de meilleure qualit√©.

Nous n'avons vu que les fonctionnalit√©s basiques de `Git` et de `Github`. L'objet du cours de 3e ann√©e de l'ENSAE de ["Mise en production de projets _data science_"](https://ensae-reproductibilite.github.io/website/) est de faire d√©couvrir d'autres fonctionnalit√©s de `Git` et `Github` qui permettent de produire des projets plus ambitieux, plus fiables et plus √©volutifs.