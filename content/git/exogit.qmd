---
title: "Un cadavre exquis pour d√©couvrir Git"
draft: false
weight: 20
slug: exogit
tags:
  - Git
categories:
  - Exercice
  - Git
type: book
description: |
  Ce chapitre propose une mise en application de quelques principes
  centraux du langage Git vus pr√©c√©demment.
image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/cadavre_exquis_kids.png
---


# Premier commit



::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 4 : Premier commit (enfin !)</h3>
```

Sur `Jupyter`, tout se passe dans la partie inf√©rieure de l'interface graphique.

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git-panel-jupyter.png)

Sur `VSCode`, il faut au contraire regarder en haut.

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git_vscode_2.png)

1Ô∏è‚É£ Entrer le titre `Initial commit` et ajouter une description
`Cr√©ation des premiers fichiers üéâ`.
Sur `VSCode`, le titre du commit correspond √† la
premi√®re ligne du message de commit, les lignes suivantes correspondent √† la
description.



Le fait de nommer le premier commit *"Initial commit"* est une
habitude, vous
n'√™tes pas oblig√© de suivre cette convention si elle ne vous pla√Æt pas.

2Ô∏è‚É£ Cliquer sur `Commit`. Le fichier a disparu de la liste, c'est normal,
il n'a plus de modification √† valider. Pour le retrouver dans la liste
des fichiers `Changed`, il faudra le modifier √† nouveau

3Ô∏è‚É£ Sur `Jupyter`, cliquer sur l'onglet `History` ou sur `VSCode` cliquer 
sur l'ic√¥ne `View Git Graph`. Votre `commit` appara√Æt √† ce niveau.
Si vous cliquez dessus, vous obtenez des informations sur le `commit`.

```{=html}
</div>
```
:::

‚ùì Question : √† ce stade, le d√©p√¥t du projet sur `GitHub` (_remote_) a-t-il √©t√© modifi√© ?


::: {.cell .markdown}
```{=html}
<div class="alert alert-info" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-comment"></i> Note</h3>
```

Si vous utilisiez la ligne de commande, la mani√®re √©quivalente de faire
serait

~~~shell
git commit -m "Initial commit" -m "Cr√©ation des premiers fichiers üéâ"
~~~

L'option `m` permet de cr√©er un message, qui sera disponible √† l'ensemble
des contributeurs du projet. Avec la ligne de commande, ce n'est pas toujours
tr√®s pratique. Les interfaces graphiques permettent des messages plus
d√©velopp√©s (la bonne pratique veut qu'on √©crive un message de commit comme un
mail succinct : un titre et un peu d'explications, si besoin).

```{=html}
</div>
```
:::



# Le fichier `.gitignore`



Lorsqu'on utilise `Git`, il y a des fichiers qu'on ne veut pas partager
ou dont on ne veut pas suivre les modifications (typiquement les grosses bases de donn√©es).

C'est le fichier `.gitignore`
qui g√®re les fichiers exclus du contr√¥le de version.
Lors de la cr√©ation du projet sur `GitHub`, nous avons demand√© la cr√©ation d'un fichier `.gitignore`, qui se situe √† la racine du projet. Il sp√©cifie l'ensemble des fichiers qui seront toujours exclus de l'indexation faite par `Git`.

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 5 : Le fichier <code>.gitignore</code></h3>
```

1Ô∏è‚É£ Par d√©faut, le fichier `.gitignore` n'est pas affich√© car
les fichiers `.*` sont des fichiers de configuration. Il faut activer
une option pour l'afficher. Tout en haut
de `Jupyter`, cliquer sur `View -> Show Hidden Files`

2Ô∏è‚É£ Ouvrir ce fichier maintenant qu'il s'affiche et observer
quelques r√®gles √©crites dedans

3Ô∏è‚É£ Cr√©er un dossier `data` √† la racine du projet et cr√©er √† l'int√©rieur de celui-ci un fichier `data/raw.csv` avec une ligne de donn√©es quelconque

4Ô∏è‚É£ Ajouter au `.gitignore` le dossier `data/`

5Ô∏è‚É£ V√©rifier que toutes les r√®gles ajout√©es pr√©c√©demment fonctionnent comme attendu

```{=html}
</div>
```
:::

‚ùì **Question** : que se passe-t-il lorsque l'on ajoute au `.gitignore` des fichiers qui ont d√©j√† √©t√© *commit* sur le projet Git ?


# Premi√®res interactions avec `Github` depuis sa copie de travail

Jusqu'√† pr√©sent, apr√®s avoir clon√© le d√©p√¥t, on a travaill√© uniquement
sur notre copie locale. On n'a pas cherch√© √† interagir √† nouveau 
avec `Github`. 

Cependant, il existe bien une connexion entre notre dossier local et
le d√©p√¥t `Github`. Si on utilise la ligne de commande,
on peut s'en assurer en tapant dans un terminal

~~~shell
git remote -v
~~~

Le d√©p√¥t distant s'appelle `remote` en langage Git. L'option `-v` (*verbose*)
permet de lister le(s) d√©p√¥t(s) distant(s). Le r√©sultat devrait avoir la
structure suivante :

```raw
origin  https://github.com/<username>/<projectname>.git (fetch)
origin  https://github.com/<username>/<projectname>.git (push)
```

Plusieurs informations sont int√©ressantes dans ce r√©sultat. D'abord on 
retrouve bien l'url qu'on avait renseign√© √† `Git` lors de l'op√©ration
de clonage. Ensuite, on remarque un terme `origin`. C'est un alias
pour l'url qui suit. Cela √©vite d'avoir, √† chaque fois, √† taper l'ensemble
de l'url, ce qui peut √™tre p√©nible et source d'erreur.

`fetch` et `push`
sont l√† pour nous indiquer qu'on r√©cup√®re (`fetch`) des modifications
d'`origin` mais qu'on envoie √©galement (`push`) des modifications vers
celui-ci. G√©n√©ralement, les url de ces deux d√©p√¥ts sont les m√™mes mais cela peut
arriver, lorsqu'on contribue √† des projets opensource qu'on n'a pas cr√©√©, 
qu'ils diff√®rent[^2].

[^2]: Ce cas de figure arrive lorsqu'on contribue √† des projets
sur lesquels on n'a pas de droit d'√©criture. Il est alors
n√©cessaire d'effectuer un _fork_, une copie de ce d√©p√¥t sur laquelle
on dispose de droits. 
Dans ce cas de figure, on rencontre g√©n√©ralement un nouvel alias √† c√¥t√© d'`origin`. 
nomm√© `upstream` (cf.
[le tutoriel `Github` pour mettre √† jour un _fork_](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks/syncing-a-fork)
et qui pointe vers le d√©p√¥t source √† l'origine du _fork_. 
La cr√©ation du bouton `Fetch upstream` par `Github` facilite grandement
la mise en coh√©rence d'`upstream` et `origin` et constitue la m√©thode
recommand√©e. 

## Envoyer des modifications sur le d√©p√¥t distant: `push`

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 6 : Interagir avec <code>Github</code></h3>
```


Il convient maintenant d'envoyer les fichiers sur le d√©p√¥t distant. 

<!----
A voir si on va pas devoir faire √ßa plus tard

1. R√©cup√©rer l'url du d√©p√¥t. Dans `Github`, il faut cliquer sur
le bouton `Code` comme ci-dessous

![](gitclone.png)

2. Cr√©er la connexion avec le d√©p√¥t distant (`remote`), qu'on va nommer `origin`,
en utilisant la commande suivante :

~~~~shell
git remote add origin ****
~~~~
Remplacer les ast√©risques par l'url du d√©p√¥t. 
---->

1Ô∏è‚É£
L'objectif est d'envoyer vos modifications vers `origin`. 
On va passer par la ligne de commande car les boutons `push`/`pull`
de l'extension `Jupyter` ne fonctionnent pas de mani√®re syst√©matique. 

Taper

~~~~shell
git push origin main
~~~~

Cela signifie: *"git envoie (`push`) mes modifications sur la 
branche `main` (la branche sur laquelle on a travaill√©, on reviendra
dessus) vers mon d√©p√¥t (alias
`origin`)"*

*Remarque : Si vous obtenez l'erreur suivante `error: src refspec hello does not match any`, c'est probablement que vous avez indiqu√© le mauvais nom de branche. La confusion se fait souvent entre le nom `main` ou `master` (ancienne norme de branche par d√©faut).*

Normalement, si vous avez utilis√© le `credential helper`, `Git` ne 
vous demande pas vos identifiants de connexion. Sinon, 
il faut taper
votre identifiant Github et **votre mot de passe correspond au personal access token nouvellement cr√©√©** ! 


2Ô∏è‚É£ Retournez voir le d√©p√¥t sur `Github`, vous devriez maintenant voir le fichier
`.gitignore` s'afficher en page d'accueil. 

```{=html}
</div>
```
:::

## La fonctionnalit√© `pull`

La deuxi√®me mani√®re d'interagir avec le d√©p√¥t est de r√©cup√©rer des
r√©sultats disponibles en ligne sur sa copie de travail. On appelle
cela `pull`. 

Pour le moment, vous √™tes tout seul sur le d√©p√¥t. Il n'y a donc pas de 
partenaire pour modifier un fichier dans le d√©p√¥t distant. On va simuler ce
cas en utilisant l'interface graphique de `Github` pour modifier
des fichiers. On rapatriera les r√©sultats en local dans un deuxi√®me temps. 

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 7 : Rapatrier des modifs en local</h3>
```

1Ô∏è‚É£ Se rendre sur votre d√©p√¥t depuis l'interface <https://github.com>

* Se placer sur le fichier `README.md` et cliquer sur le bouton `Edit this file`, qui prend la forme d'un ic√¥ne de crayon.

2Ô∏è‚É£ L'objectif est de
donner au `README.md` un titre en ajoutant, au d√©but du document, la ligne suivante : 

```{python}
#| output: asis
#| echo: false
print(
"""~~~markdown
# Mon oeuvre d'art surr√©aliste 
~~~""")
```

Sautez une ligne et entrez le texte que vous d√©sirez, sans ponctuation. Par exemple,

~~~markdown
le ch√™ne un jour dit au roseau
~~~

3Ô∏è‚É£ Cliquez sur l'onglet `Preview` pour voir le texte mis en forme au format `Markdown`

4Ô∏è‚É£  R√©diger un titre et un message compl√©mentaire pour faire le `commit`. Conserver
l'option par d√©faut `Commit directly to the main branch`

5Ô∏è‚É£ Editer √† nouveau le `README` en cliquant sur le crayon juste au dessus
de l'affichage du contenu du `README`.

Ajouter une deuxi√®me phrase et corrigez la
ponctuation de la premi√®re. Ecrire un message de commit et valider.

~~~markdown
Le Ch√™ne un jour dit au roseau :
Vous avez bien sujet d'accuser la Nature
~~~

6Ô∏è‚É£ Au dessus de l'aborescence des fichiers, vous devriez voir s'afficher le
titre du dernier commit. Vous pouvez cliquer dessus pour voir la modification
que vous avez faite.

7Ô∏è‚É£ Les r√©sultats sont sur le d√©p√¥t distant mais ne sont pas sur votre
dossier de travail dans `Jupyter` ou `VSCode`. Il faut re-synchroniser votre copie locale
avec le d√©p√¥t distant :

* Sur `VSCode`, cliquez simplement sur `... > Pull` √† c√¥t√© du bouton qui permet
de visualiser le graphe Git.
* Avec l'interface `Jupyter`, si cela est possible, appuyez tout simplement sur la petite
fl√®che vers le bas, qui est celle qui a d√©sormais la pastille orange.
* Si cette fl√®che n'est pas disponible ou si vous travaillez dans un autre
environnement, vous pouvez utiliser la ligne de 
commande et taper

~~~shell
git pull origin main
~~~

Cela signifie : *"git r√©cup√®re (`pull`) les modifications sur la 
branche `main` vers mon d√©p√¥t (alias
`origin`)"*

8Ô∏è‚É£ Regarder √† nouveau l'historique des commits. Cliquez sur le
dernier commit et affichez les changements sur le fichier. Vous pouvez
remarquer la finesse du contr√¥le de version : `Git` d√©tecte au sein de
la premi√®re ligne de votre texte que vous avez mis des majuscules
ou de la ponctuation. 

```{=html}
</div>
```
:::

L'op√©ration `pull` permet : 

1. A votre syst√®me local de v√©rifier les modifications sur le d√©p√¥t distant
que vous n'auriez pas faites (cette op√©ration s'appelle `fetch`)
2. De les fusionner s'il n'y a pas de conflit de version ou si les conflits de
version sont automatiquement fusionnables (deux modifications d'un fichier mais
qui ne portent pas sur le m√™me emplacement).


# M√™me tout seul, ne pas se limiter √† `main`


Au d√©but d‚Äôune t√¢che particuli√®re ou d‚Äôun projet, il est recommand√© d‚Äôouvrir des *issues*. Prenant la forme d‚Äôun espace de discussion, elles correpondront √† la fin √† des nouvelles fonctionnalit√©s (en anglais, *features*). Les issues permettent √©galement de signaler des bugs constat√©s, de se les r√©partir et d‚Äôindiquer s‚Äôils sont r√©gl√©s ou s‚Äôils ont avanc√©s. Une utilisation intensive des *issues*, avec des labels ad√©quats, peut
m√™me amener √† se passer d'outils de gestion de projets comme `Trello`. 


La branche `main` est la branche principale. Elle se doit d'√™tre "propre". Si on veut √™tre rigoureux, on ne pousse pas des travaux non aboutis sur `main`.  

Il est possible de pousser directement sur `main` dans le cas de petites corrections, de modifications mineures dont vous √™tes certains qu'elles vont fonctionner. Mais sachez que dans le cadre de projets sensibles, c'est strictement interdit. N'ayez pas peur de fixer comme r√®gle l'interdiction de pousser sur `main`, cela obligera l'√©quipe projet √† travailler professionnellement. 

Au moindre doute, cr√©ez une branche. Les branches sont utilis√©es pour des travaux significatifs :

- vous travaillez seul sur une t√¢che qui va vous prendre plusieurs heures ou jours de travail (vous ne devez pas pousser sur `main` des travaux non aboutis);
- vous travaillez sur une fonctionnalit√© nouvelle et vous souhaiterez recueillir l'avis de vos collaborateurs avant de modifier `main`;
- vous n'√™tes pas certain de r√©ussir vos modifications du premier coup et pr√©f√©rez faire des tests en parall√®le.


::: {.cell .markdown}
```{=html}
<div class="alert alert-danger" role="alert">
<i class="fa-solid fa-triangle-exclamation"></i> Warning</h3>
```

Les branches ne sont pas personnelles : **Toutes les branches sont publi√©es, le `rebase` est interdit. Le push force est √©galement interdit.**

Il faut **absolument** bannir les usages de `push force` qui peuvent d√©stabiliser les copies locales des collaborateurs. S'il est n√©cessaire de faire un `push force`, c'est qu'il y a un probl√®me dans la branche, √† identifier et r√©gler **sans** faire `push force`.

![](https://miro.medium.com/max/400/0*XaLzNzYkA6PZjbl9.jpg)

**Tous les merges dans `main` doivent se faire par l'interm√©diaire d'une `pull request` dans `Github`**. En effet, il est tr√®s d√©conseill√© de merger une branche dans main localement.

```{=html}
</div>
```
:::


::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 8: Cr√©er une nouvelle branche et l'int√©grer dans main</h3>
```


1Ô∏è‚É£ Ouvrir une *issue* sur `Github`. Signaler qu'il serait bien d'ajouter un emoji chat dans le README. Dans la partie de droite, cliquer sur la petite roue √† c√¥t√© de `Label` et cliquer sur `Edit Labels`. Cr√©er un label `Markdown`. Normalement, le label a √©t√© ajout√©.

2Ô∏è‚É£ Retournez sur votre d√©p√¥t local. Vous allez cr√©er une branche nomm√©e
`issue-1`

Avec l'interface graphique de JupyterLab, cliquez sur `Current Branch - Main`
puis sur le bouton `New Branch`. Rentrez `issue-1` comme nom de branche
(la branche doit √™tre cr√©√©e depuis `main`, ce qui est normalement le choix
par d√©faut) et cliquez sur `Create Branch`.

Sur VSCode, cliquez sur `... > Branch > Create Branch` et entrez le nom `issue-1`.

Si vous n'utilisez pas l'interface graphique mais la ligne de commande, la
mani√®re √©quivalente de faire est[^4]

~~~shell
git checkout -b issue-1
~~~~

[^4]: La commande `checkout` est un couteau-suisse de la gestion de branche en `Git`. Elle permet en effet de basculer d'une branche √† l'autre, mais aussi d'en cr√©er, etc. 


3Ô∏è‚É£ Ouvrez `README.md` et ajoutez un emoji chat (`:cat:`) √† la suite du titre.
Faites un commit en refaisant les √©tapes vues dans les exercices
pr√©c√©dents. N'oubliez pas, cela se fait en deux √©tapes:

1. Ajoute les modifications √† l'index en d√©placant le fichier `README` dans
la partie `Staged`
2. Validation des modifications avec un `commit`

Si vous passez par la ligne de commande, cela donnera :

~~~shell
git add .
git commit -m "ajout emoji chat"
~~~


4Ô∏è‚É£ Faire un **deuxi√®me commit** pour ajouter un emoji koala (:koala:) puis
pousser les modifications locales.

Cela peut √™tre fait avec l'interface
de `JupyterLab` gr√¢ce au bouton avec une fl√™che montante (il doit appara√Ætre
en orange maintenant). Sur `VSCode`, cliquez sur le bouton `Publish Branch`.

Sinon, si vous utilisez la ligne de commande, vous devrez taper

~~~shell
git push origin issue-1
~~~~

5Ô∏è‚É£ Dans `Github`, devrait appara√Ætre 

> `issue-1 had recent pushes XX minutes ago`. 

Cliquer sur `Compare & Pull Request`. Donner un titre informatif √† votre *pull request* 
Dans le message en dessous, taper

> `- close #1`

Le tiret est une petite astuce pour que `Github` 
remplace le num√©ro de l'issue par le titre.

Cliquez sur `Create Pull Request` mais 
**ne validez pas la fusion**, on le fera dans un second temps.

Le fait d'avoir mis un message `close` suivi d'un num√©ro d'issue `#1`
permettra de fermer automatiquement l'*issue 1* lorsque vous ferez le *merge*.
En attendant, vous avez cr√©√© un lien entre l'*issue* et la *pull request*

Au passage, vous pouvez ajouter le label `Markdown` sur la droite. 

6Ô∏è‚É£ En local, retourner sur `main`. Dans l'interface `Jupyter`, il suffit
de cliquer sur `main` dans la liste des branches. Sur `VSCode`, la liste des branches
appara√Æt en cliquant sur le nom de la branche actuelle (`issue-1` en th√©orie √† ce stade).
Si vous √™tes en ligne de commande, il faut faire

~~~shell
git checkout main
~~~~

`checkout` est une commande `Git` qui permet de naviguer d'une branche √† l'autre
(voire d'un commit √† l'autre). 

Ajouter une phrase √† la suite de votre texte dans le `README.md` 
(ne touchez pas au titre !). Vous pouvez remarquer que les emojis
ne sont pas dans le titre, c'est normal vous n'avez pas encore fusionn√© les versions

7Ô∏è‚É£ Faire un commit et un push. En ligne de commande, cela donne

~~~shell
git add .
git commit -m "ajoute un troisi√®me vers"
git push origin main
~~~


8Ô∏è‚É£ Sur `Github`, cliquer sur `Insights` en haut du d√©p√¥t puis, √† gauche sur `Network` (cela n'est
possible que si vous avez rendu public votre d√©p√¥t).

Vous devriez voir appara√Ætre l'arborescence de votre d√©p√¥t. On peut voir `issue-1` comme une ramification et `main` comme le tronc.

L'objectif est maintenant de ramener les modifications faites dans `issue-1` dans la branche principale. Retournez dans l'onglet `Pull Requests`. L√†, changer le type de `merge` pour `Squash and Merge`, comme ci-dessous (petit conseil : choisissez toujours cette m√©thode de *merge*).

Une fois que cela est fait, vous pouvez retourner dans `Insights` puis `Network` pour v√©rifier que tout s'est bien pass√© comme pr√©vu. 


![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/squashmerge.png)


9Ô∏è‚É£ Supprimer la branche (*branch > delete this branch*). Puisqu'elle est merg√©e, elle ne servira plus. La conserver risque d'amener √† des `push` involontaires dessus. 

```{=html}
</div>
```
:::


L'option de fusion *Squash and Merge* permet de regrouper tous les commits d'une branche (potentiellement tr√®s nombreux) en un seul dans la branche de destination. Cela √©vite, sur les gros projets, des branches avec des milliers de *commits*.

Je recommande de toujours utiliser cette technique et non les autres. 
Pour d√©sactiver les autres techniques, vous pouvez aller dans
`Settings` et dans la partie `Merge button` ne conserver coch√©e que la
m√©thode `Allow squash merging`


# Un cadavre exquis pour d√©couvrir le travail collaboratif

Jusqu'√† pr√©sent, nous avons d√©couvert les vertus de `Git` dans un projet
individuel. Nous allons maintenant aller plus loin dans un projet 
collectif. 

## Le *workflow* adopt√©

Nous allons adopter le mode de travail le plus simple, le *Github Flow*. 
Il correspond √† cette forme caract√©ristique d'arbre:

1. La branche `main` constitue le tronc
2. Les branches partent de `main` et divergent
3. Lorsque les modifications aboutissent, elles sont int√©gr√©es √† `main` ; 
la branche en question dispara√Æt :

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/ghflow.png)


Il existe des *workflows* plus complexes, notamment le `Git Flow` que j'utilise
pour d√©velopper ce cours. [Ce tutoriel](https://www.atlassian.com/fr/git/tutorials/comparing-workflows/gitflow-workflow), tr√®s bien fait, 
illustre avec un graphique la complexit√© accrue de ce flow : 

![](https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg?cdnVersion=55)

Cette fois, une branche interm√©diaire, par exemple une branche `development`
int√®gre des modifications √† tester avant de les int√©grer dans la version 
officielle (`main`).

::: {.cell .markdown}
```{=html}
<div class="alert alert-warning" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-lightbulb"></i> Hint</h3>
```

Vous pourrez trouvez des dizaines d‚Äôarticles et d‚Äôouvrages sur ce sujet dont chacun pr√©tend avoir trouv√© la meilleure organisation du travail (`Git flow`, `GitHub flow`, `GitLab flow`...). Ne lisez pas trop ces livres et articles sinon vous serez perdus (un peu comme avec les magazines destin√©s aux jeunes parents...).

La m√©thode de travail la plus simple est le *Github flow* qu'on vous a propos√© d'adopter. L'arborescence est reconnaissable : des branches divergent et reviennent syst√©matiquement vers `main`. 

Pour des projets plus complexes dans des √©quipes d√©veloppant des applications, on pourra utiliser d'autres m√©thodes de travail, notamment le `Git flow`. Il n'existe pas de r√®gles universelles pour d√©terminer la m√©thode de travail ; l'important c'est, avant tout, de se mettre d'accord sur des r√®gles communes de travail avec votre √©quipe.

```{=html}
</div>
```
:::

## M√©thode pour les merges

Les merges vers `main` doivent imp√©rativement passer par `Github` (ou `Gitlab`). Cela permet de garder une trace explicite de ceux-ci (par exemple [ici](https://github.com/linogaliana/python-datascientist/pulls?q=is%3Apr+is%3Aclosed)), sans avoir √† chercher dans l'arborescence, parfois complexe, d'un projet.

La bonne pratique veut qu'on fasse un `squash commit` pour √©viter une inflation du nombre de commits dans `main`: les branches ont vocation √† proposer une multitude de petits commits, les modifications dans `main` doivent √™tre simples √† tracer d'o√π le fait de modifier des petits bouts de code. 

Comme on l'a fait dans un exercice pr√©c√©dent, il est tr√®s pratique d‚Äôajouter dans le corps du message  `close #xx` o√π `xx` est le num√©ro d'une *issue* associ√©e √† la `pull request`. Lorsque la `pull request` sera fusionn√©e, l‚Äô*issue* sera automatiquement ferm√©e et un lien sera cr√©√© entre l'`issue` et la `pull request`. Cela vous permettra de comprendre, plusieurs mois ou ann√©es plus tard comment et pourquoi telle ou telle fonctionnalit√© a √©t√© impl√©ment√©e.

En revanche, l'int√©gration des derni√®res modifications de `main` vers une branche se fait en local. Si votre branche est en conflit, **le conflit doit √™tre r√©solu dans la branche et pas dans main**. 
`main` doit toujours rester propre. 

## Mise en pratique

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 9 : Interactions avec le d√©p√¥t distant</h3>
```


Cet exercice se fait par groupe de trois ou quatre. Il y aura deux r√¥les dans ce sc√©nario :

- Une personne aura la responsabilit√© d'√™tre **mainteneur**
- Deux √† trois personnes seront **d√©veloppeurs**. 

1Ô∏è‚É£ Le mainteneur cr√©e un d√©p√¥t sur `Github`. Il/Elle donne des droits au(x) d√©veloppeur(s) du projet (`Settings > Manage Access > Invite a collaborator`).

2Ô∏è‚É£ Chaque membre du projet, cr√©e une copie locale du projet gr√¢ce √† la commande `git clone` ou
avec le bouton `Clone a repository` de `JupyterLab`.

Pour cela, r√©cup√©rer l'url HTTPS du d√©p√¥t en copiant l'url du d√©p√¥t que vous pouvez trouver, par exemple, dans la page d'accueil du d√©p√¥t, en dessous de `Quick setup ‚Äî if you‚Äôve done this kind of thing before`

En ligne de commande, cela donnera :

~~~shell
git clone https://github.com/<username>/<reponame>.git
~~~

3Ô∏è‚É£ Chaque membre du projet cr√©e un fichier avec son nom et son pr√©nom, selon cette structure `nom-prenom.md` en √©vitant les caract√®res sp√©ciaux. Il √©crit dedans trois phrases de son choix **sans ponctuation ni majuscules** (pour pouvoir effectuer une correction ult√©rieurement). Enfin, il commit sur le projet.

Pour rappel, en ligne de commande cela donnera les commandes suivantes √† modifier

~~~shell
git add nom-prenom.md
git commit -m "C'est l'histoire de XXXXX"
~~~

4Ô∏è‚É£ Chacun essaie d'envoyer (*push*) ses modifications locales sur le d√©p√¥t:

~~~shell
git push origin main
~~~


5Ô∏è‚É£ A ce stade, une seule personne (la plus rapide) devrait ne pas avoir rencontr√© de rejet du `push`. C'est normal, avant d'accepter une modification `Git` v√©rifie en premier lieu la coh√©rence de la branche avec le d√©p√¥t distant. Le premier ayant fait un `push` a modifi√© le d√©p√¥t commun ; les autres doivent int√©grer ces modifications dans leur version locale (*pull*) avant d'avoir le droit de proposer un  changement.

Pour celui/celle/ceux dont le `push` a √©t√© refus√©, faire

~~~shell
git pull origin main
~~~

pour ramener les modifications distantes en local. 

6Ô∏è‚É£ Taper `git log` et regarder la mani√®re dont a √©t√© int√©gr√© la modification de votre camarade ayant pu faire son `push`

Vous remarquerez que les commits de vos camarades sont int√©gr√©s tels quels √† 
l'histoire du d√©p√¥t. 

7Ô∏è‚É£ Faire √† nouveau 

~~~shell
git pull origin main
~~~

Le dernier doit refaire, √† nouveau, les √©tapes 5 √† 7 (dans une √©quipe de quatre
il faudra encore le refaire une fois).

```{=html}
</div>
```
:::

::: {.cell .markdown}
```{=html}
<div class="alert alert-danger" role="alert">
<i class="fa-solid fa-triangle-exclamation"></i> Warning √† nouveau: ne JAMAIS FAIRE <code>git push force</code></h3>
```

Quand on fait face √† un rejet du `push`, on est tent√© de faire passer en force le `push` malgr√© la mise en garde pr√©c√©dente.

Il faut **imm√©diatement oublier cette solution**, elle cr√©e de nombreux probl√®mes et, en fait, ne r√©sout rien. L'un des risques est de r√©√©crire enti√®rement l'historique rendant les copies locales, et donc les modifications de vos collaborateurs, caduques. Cela vous vaudra, √† raison, des remontrances de vos partenaires qui perdent le b√©n√©fice de leur historique `Git` qui, s'ils ont des versions sans `push` depuis longtemps peuvent avoir diverger fortement du d√©p√¥t ma√Ætre. 

```{=html}
</div>
```
:::


::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 10 : G√©rer les conflits quand on travaille sur le m√™me fichier</h3>
```

Dans la continuit√© de l'exercice pr√©c√©dent, chaque personne va travailler sur les fichiers des autres membres de l'√©quipe.

1Ô∏è‚É£ Les deux ou trois d√©veloppeurs ajoutent la ponctuation et les majuscules du fichier du premier d√©veloppeur.

2Ô∏è‚É£ Ils sautent une ligne et ajoutent une phrase (pas tous la m√™me).

3Ô∏è‚É£ Valider les r√©sultats (`git add .` et `commit`) et faire un `push`

4Ô∏è‚É£ La personne la plus rapide n'a, normalement, rencontr√© aucune difficult√© (elle peut s'arr√™ter temporairement pour regarder ce qui va se passer chez les voisins). Les autres voient leur `push` refus√© et doivent faire un `pull`. 

üí• Il y a conflit, ce qui doit √™tre signal√© par un message du type :

~~~shell
Auto-merging XXXXXX
CONFLICT (content): Merge conflict in XXXXXX.md
Automatic merge failed; fix conflicts and then commit the result.
~~~

5Ô∏è‚É£ Etudier le r√©sultat de `git status` 

6Ô∏è‚É£ Si vous ouvrez les fichiers incrimin√©s, vous devriez voir des balises du type

```{python}
#| output: asis
#| echo: false
print(
"""~~~markdown
<<<<<<< HEAD
this is some content to mess with
content to append
=======
totally different content to merge later
>>>>>>> new_branch_to_merge_later
~~~
"""
)
```

7Ô∏è‚É£ Corriger √† la main les fichiers en choisissant, pour chaque ligne, la version qui vous convient et en retirant les balises. Valider en faisant: 

~~~shell
git add . && git commit -m "R√©solution du conflit par XXXX"
~~~

Remplacer XXXX par votre nom. La balise `&&` permet d'encha√Æner, en une seule ligne de code, les deux commandes.

8Ô∏è‚É£ Faire un push. Pour la derni√®re personne, refaire les op√©rations 4 √† 8

```{=html}
</div>
```
:::
`Git` permet donc de travailler, en m√™me temps, sur le m√™me fichier et de limiter le nombre de gestes manuels n√©cessaires pour faire la fusion. Lorsqu'on travaille sur des bouts diff√©rents du m√™me fichier, on n'a m√™me pas besoin de faire de modification manuelle, la fusion peut √™tre automatique.

`Git` est un outil tr√®s puissant. Mais, il ne remplace pas une bonne organisation du travail. Vous l'avez vu, ce mode de travail uniquement sur `main` peut √™tre p√©nible. Les branches prennent tout leur sens dans ce cas. 

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 11 : Gestion des branches</h3>
```

1Ô∏è‚É£ Le mainteneur va contribuer directement dans `main` et ne cr√©e pas de branche. Chaque d√©veloppeur cr√©e une branche, en local nomm√©e `contrib-XXXXX` o√π `XXXXX` est le pr√©nom: 

~~~shell
git checkout -b contrib-XXXXX
~~~

2Ô∏è‚É£ Chaque membre du groupe cr√©e un fichier `README.md` o√π il √©crit une phrase sujet-verbe-compl√©ment. Le mainteneur est le seul √† ajouter un titre dans le README (qu'il commit dans main).

3Ô∏è‚É£ Chacun push le produit de son subconscient sur le d√©p√¥t.

4Ô∏è‚É£ Les d√©veloppeurs ouvrent, chacun, une `pull request` sur `Github` de leur branche vers `main`. Ils lui donnent un titre explicite. 

5Ô∏è‚É£ Dans la discussion de chaque `pull request`, le mainteneur demande au d√©veloppeur d'int√©grer le titre qu'il a √©crit.  

6Ô∏è‚É£ Chaque d√©veloppeur, en local, int√®gre cette modification en faisant


```shell
# Pour √™tre s√ªr d'√™tre sur sa propre branche
git checkout branche-XXXX
git merge main
```

R√©gler le conflit et valider (`add` et `commit`). Pousser le r√©sultat. Le mainteneur choisit une des `pull request` et la valide avec l'option `squash commits`. V√©rifier sur la page d'accueil le r√©sultat.

7Ô∏è‚É£ L'auteur (si 2 d√©veloppeurs)  ou les deux auteurs (si 3 d√©veloppeurs) de la `pull request` non valid√©e doivent √† nouveau r√©p√©ter l'op√©ration 6. 

8Ô∏è‚É£ Une fois le conflit de version r√©gl√© et pouss√©, le mainteneur valide la `pull request` selon la m√™me proc√©dure que pr√©c√©demment. 

9Ô∏è‚É£ V√©rifier l'arborescence du d√©p√¥t dans `Insights > Network`. Votre arbre doit avoir une forme caract√©ristique de ce qu'on appelle le `Github flow`:

![](https://linogaliana.gitlab.io/collaboratif/pics/03_git/flow4_discuss.png)
```{=html}
</div>
```
:::
