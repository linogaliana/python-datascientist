---
title: "Git: un outil nécessaire pour les data scientists"
description: |
  Une partie annexe au cours pour découvrir `Git`,
  un outil
  devenu indispensable pour les data scientists
  afin de mener des projets impliquant
  du code `Python`.
image: https://ensae-reproductibilite.github.io/website/snakedolls.jpg
categories:
  - Git
---


Cette partie du site présente un élément qui n'est pas propre à
`Python` mais qui est néanmoins indispensable : la pratique de `Git`.

Une grande partie du contenu de la partie provient
d'un [cours dédié fait avec Romain Avouac](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html)

:::{.cell .markdown}
Dérouler les _slides_ ci-dessous ou [cliquer ici](/slides/ggplot.qmd)
pour afficher les slides en plein écran.

```{=html}
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><iframe class="sourceCode yaml code-with-copy" src="https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html#/partie-1-contr%C3%B4le-de-version-avec-git"></iframe></div>
```

:::



# Introduction

## Le problème

La démarche naturelle quand on commence à travailler longuement sur un projet pour lequel on veut éviter d'effacer et perdre son code à cause d'une erreur humaine est de dupliquer les fichiers et créer des __versions multiples d'un même code qui sont des instantanés à un moment donné__ :

![Le contrôle de version artisanal](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/fichiers_multiples.png){#fig-version-control-inferno}

Ceci est une manière de sauvegarder l'évolution de son code et donc la vie d'un projet. Néanmoins c'est une manière très artisanale de procéder qui n'efface pas l'erreur humaine puisqu'il est toujours possible de faire une erreur lors de la duplication du fichier ou d'oublier de sauvegarder une version qui nous satisfaisait.

Cette pratique présente de nombreux inconvénients. Le premier est le fait que la recherche d'information pertinente, par exemple sur l'introduction d'un bug, est compliquée par cette structure dupliquée. Il est difficile, sans rentrer dans le détail de chaque fichier, de connaître son évolution réelle entre deux dates. Pour l'extraction d'information, il serait beaucoup plus pertinent de construire des fichiers de l'évolution entre telle ou telle version mais cela requiert de nombreux gestes manuels et un temps conséquent. Le deuxième problème est qu'on ne sait pas forcément, quand on revient quelques jours plus tard sur le projet, pourquoi on a enregistré telle ou telle version : quand on est le 28 novembre, se souvient-on de ce qui distingue les versions du 4 mai 12:37 et 16:02 ?

Si on ajoute la dimension collaborative du travail sur le code, on voit rapidement d'autres inconvénients à cette approche artisanale. En premier lieu, quelqu'un reprenant le projet aura du mal à rentrer dans celui-ci. De plus, il sera encore plus difficile pour cette personne de rechercher l'information pertinente sur les choix de version faits: cet historique lui est finalement inutile. D'autant que se pose la question du partage de ces codes: par quel biais cet ensemble de fichiers est-il partagé ? Par mails ? Sur un disque partagé ? Mais que se passe-t-il si plusieurs participants du projet travaillent en même temps dessus ? Comment organiser la collaboration et réconcilier les changements s'ils ont lieu de manière conjointe ? 

## La solution technique: `Git`

`Git` apporte une réponse technique à ces très nombreuses questions. Ce logiciel spécialisé dans le contrôle de version, c'est-à-dire dans le suivi des évolutions d'un projet, vient résoudre de nombreux problèmes liés à la mise en oeuvre de projets de _data science_ dans les organisations. L'objet de ce chapitre est de présenter quelques concepts nécessaires à la compréhension de `Git` et présenter la manière dont celui-ci vient aider à gérer l'évolution d'un projet informatique. Le chapitre suivant introduira à la manière dont `Git` fluidifie la collaboration au sein d'équipes impliquées dans des projets de _data science_. Ceci est devenu indispensable car l'époque où les _data scientists_ travaillaient tous seuls sur des _notebooks_ est révolue. Les projets de _data science_ sont devenus, dans la plupart des organisations, plus ambitieux et impliquent souvent plusieurs personnes avec des profils diverses[^miseenprod], il est donc nécessaire d'avoir de la discipline pour que la collaboration soit fluide. 

[^miseenprod]: Ce constat est le point de départ du cours de "Mise en production de projets _data science_" disponible sur [ensae-reproductibilite.github.io/website/](https://ensae-reproductibilite.github.io/website/) que Romain Avouac et moi donnons à la fin de la scolarité de l'ENSAE. 

# Comment utiliser `Git` {{< fa brands git-alt >}} quand on fait du `Python` {{< fa brands python >}} ? 

`Git` est un logiciel de contrôle de version, c'est-à-dire un logiciel en charge d'enregistrer les évolutions d'un fichier dans le temps (ce qu'on appelle versionner). Ce n'est pas un _package_ `Python`, ce ne sera pas par ce biais que nous l'utiliserons.

Les utilisateurs de `Python` peuvent utiliser `Git` par le biais de deux intermédiaires: par le biais de la ligne de commande ou par le biais d'extensions graphiques dans leurs environnements de développement (`VSCode`, `Jupyter`, etc.). Sur le `SSPCloud`, l'infrastructure recommandée pour ce cours, nous avons la possibilité pour faire du `Git` par les deux approches mais nous allons principalement utiliser l'interface graphique de `VSCode` qui réduit le coût d'entrée dans `Git`. 


# Où trouver de l'information complémentaire à ce cours ?

`Git` fait parti des pratiques collaboratives
devenues standards dans le domaine de l'_open-source_
mais également de plus en plus communes dans les administrations et entreprises
de la _data science_. 

Il existe de
nombreuses ressources sur internet sur le sujet,
notamment une série de ressources construites
pour l'Insee [sur ce site](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/)
et des ressources de la documentation collaborative sur `R` qu'est `utilitR`
([des éléments sur la configuration](https://www.book.utilitr.org/03_fiches_thematiques/fiche_configurer_git)
et [pratique sur RStudio](https://www.book.utilitr.org/03_fiches_thematiques/fiche_git_utilisation)). Toutes
les ressources ne sont donc pas du `Python` car `Git` est un outil transversal
qui doit servir quel que soit le langage de prédilection.



<!-----------------
## Les problèmes classiques

Dans un projet, il est commun de se demander (ou de demander à quelqu'un) :

* quelle était la bonne version d'un programme ?
* qui était l'auteur d'un bout de code en particulier  ?
* si un changement était important ou juste un essai  ?
* où retrouver des traces d'un vieil essai abandonné mais potentiellement finalement prometteur  ?
* comment fusionner des programmes écrits par plusieurs personnes  ?
* etc.

![](https://thinkr.fr/wp-content/uploads/git_notfinal.gif){fig-width="60%"}

## La solution: le contrôle de version

Il existe un outil informatique puissant qui répond à tous ces besoins :
la __gestion de version__ (*version control system* (VCS) en anglais). Ses avantages sont incontestables et permettent de facilement :

* enregistrer l'historique des modifications d'un ensemble de fichiers ;
* revenir à des versions précédentes d'un ou plusieurs fichiers ;
* rechercher les modifications qui ont pu créer des erreurs ;
* partager ses modifications et récupérer celles des autres ;
* proposer des modifications, les discuter, sans pour autant modifier d'emblée la dernière version existante ;
* identifier les auteurs et la date des modifications.


En outre, ces outils fonctionnent avec tous les langages
informatiques (texte, `R`, `Python`, `Markdown`, `LaTeX`, `Java`, etc.)
car reposent sur la comparaison des lignes et des caractères des programmes.

## Avantages du contrôle de version

On peut ainsi résumer les principaux avantages du contrôle de version
de la manière suivante :

1. Conserver et archiver l'ensemble des versions d'un code ou d'une documentation
2. Travailler efficacement en équipe
3. Améliorer la qualité des codes
4. Simplifier la communication autour d'un projet


### Conserver et archiver du code

Une des principales fonctionnalités de la gestion de version est de conserver
l'ensemble des fichiers de façon sécurisée et de proposer un archivage
structuré des codes. Les fichiers sont stockés dans un **dépôt**, qui constitue le projet.

Tout repose dans la gestion et la présentation de l'historique des modifications.
Chaque modification (ajout, suppression ou changement) sur un ou plusieurs fichiers est identifiée par son auteur,
sa date et un bref descriptif[^1].
Chaque changement est donc unique et aisément identifiable quand les modifications sont classées par ordre chronologique. Les groupes de modifications transmis au dépôt sont appelées **commit**.


[^1]: Plus précisément, chaque modification est identifiée de manière unique par un code `SHA` auquel est associé l'auteur, l'horodatage et des métadonnées (par exemple le message descriptif associé).


Avec des outils graphiques, on peut vérifier l'
[ensemble des évolutions d'un fichier (`history`)](https://github.com/linogaliana/python-datascientist/commits/main/README.md),
ou [l'histoire d'un dépôt](https://github.com/linogaliana/python-datascientist/commits/main).
On peut aussi
[se concentrer sur une modification particulière d'un fichier](https://github.com/linogaliana/python-datascientist/commit/7e5d30ae0e260f9485453b42f195b0181a53e32e#diff-04c6e90faac2675aa89e2176d2eec7d8) ou vérifier, pour un fichier, la
[modification qui a entraîné l'apparition de telle ou telle ligne (`blame`)](https://github.com/linogaliana/python-datascientist/blame/main/README.md)

Sur son poste de travail, les dizaines (voire centaines) de programmes organisés à la main n'existent plus. Tout est regroupé dans un seul dossier, rassemblant les éléments du dépôt. Au sein du dépôt, tout l'historique est stocké et accessible rapidement. Si on souhaite travailler sur la dernière version des programmes (ou sur une ancienne version spécifique), il n'y a plus besoin de conserver les autres fichiers car ils sont dans l'historique du projet. Il est alors possible de choisir sur quelle version on veut travailler (la dernière commune à tout le monde, la sienne en train d'être développée, celle de l'année dernière, etc.).

### Travailler efficacement en équipe

Le deuxième avantage de la gestion de version représente une amélioration notable du travail en équipe sur des codes en commun.

La gestion de version permet de collaborer simplement et avec méthode. De façon organisée, elle permet de :

* travailler en parallèle et fusionner facilement du code
* partager une documentation des programmes grâce :
    + aux commentaires des modifications
    + à la possibilité d'une documentation commune et collaborative
* trouver rapidement des erreurs et en diffuser rapidement la
correction

A ces avantages s'ajoutent les fonctionalités collaboratives des __forges__
qui sont des plateformes où peuvent être stockés des dépôts. 
Néanmoins, ces forges proposent aujourd'hui beaucoup de fonctionalités 
qui vont au-delà de l'archivage de code : 
interagir via
des [*issues*](https://github.com/linogaliana/python-datascientist/issues),
faire des suggestions de modifications, exécuter du code dans des
environnements normalisés, etc.
Il faut vraiment les voir comme des réseaux sociaux du code. 
Les principales plateformes dans ce domaine étant `Github` et `Gitlab`.

L'usage individuel, c'est-à-dire seul sur son projet,
permet aussi de "travailler en équipe avec soi-même" car il permet de retrouver des mois plus tard le contenu et le contexte des modifications. Cela est notamment précieux lors des changements de poste ou des travaux réguliers mais espacés dans le temps (par exemple, un mois par an chaque année). Même lorsqu'on travaille tout seul, on collabore avec un *moi* futur qui peut ne plus se souvenir de la modification des fichiers.



### Améliorer la qualité des codes

Le fonctionnement de la gestion de version, reposant sur l'archivage structuré des modifications et les commentaires les accompagnant, renforce la qualité des programmes informatiques. Ils sont plus documentés, plus riches et mieux structurés. C'est pour cette raison que le contrôle de version ne doit pas être considéré comme un outil réservé à des développeurs : toute personne travaillant sur des programmes informatiques gagne à utiliser du contrôle de version.

Les services d'*intégration continue* permettent de faire des tests automatiques
de programmes informatiques, notamment de packages, qui renforcent la
réplicabilité des programmes. Mettre en place des méthodes de travail fondées
sur l'*intégration continue* rend les programmes plus robustes en forçant
ceux-ci à tourner sur des machines autres que celles du développeur du code.


### Simplifier la communication autour d'un projet

Les sites de dépôts `Github` et `Gitlab` permettent de faire beaucoup plus
que seulement archiver des codes. Les fonctionalités de déploiement
en continu permettent ainsi de :

* créer des sites web pour valoriser des projets (par exemple les sites
`readthedocs` en `python`)
* déployer de la documentation en continu
* rendre visible la qualité d'un projet avec des services de *code coverage*,
de tests automatiques ou d'environnements intégrés de travail (binder, etc.)
qu'on rend généralement visible au moyen de badges
(exemple [ici](https://github.com/linogaliana/python-datascientist#python-pour-la-data-science-))


En résumé, 

|                      |      Avant            |  Gestion de version  |
|:---------------------|----------------------:|---------------------:|
|Archivage             | à la main             | automatique          |
|Envoi de modification | mail, dossier partagé | code partagé         |
|Fusion de code        | copié-collé           | simple, sûr          |
|Versions du modèle    | dossiers archivés     | historique riche     |
|Gestion des erreurs   | à la main             | méthodique           |

---------------->

