---
title: "Découvrir Git par la pratique: la gymnastique quotidienne"
categories:
  - Tutoriel
  - Git
description: |
  `Git` est un système de contrôle de version qui facilite la
  sauvegarde, la gestion des évolutions et le partage
  d'un projet informatique. Il s'agit d'un élément devenu
  indispensable dans le domaine de la _data science_.
  Ce chapitre présente quelques concepts qui seront 
  mis en pratique dans le suivant. 
image: https://ensae-reproductibilite.github.io/website/snakedolls.jpg
echo: false
---

Le [chapitre d'introduction](/content/git/index.qmd) de la partie a évoqué les enjeux, présentés de manière synthétique
dans un [cours dédié fait avec Romain Avouac](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html)

:::{.cell .markdown}
Dérouler les _slides_ ci-dessous ou [cliquer ici](/slides/ggplot.qmd)
pour afficher les slides en plein écran.

```{=html}
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><iframe class="sourceCode yaml code-with-copy" src="https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html#/partie-1-contr%C3%B4le-de-version-avec-git"></iframe></div>
```

:::

Ce chapitre va être l'occasion de faire ses premiers pas avec `Git`. Le prochain chapitre sera consacré au travail collaboratif. 

Pour comprendre les analogies avec le versionnage artisinal à la main, rappelons nous le principe de celui-ci avec la @version-control-inferno

![Le contrôle de version artisanal](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/fichiers_multiples.png){#version-control-inferno}


::: {.important}
Il est vivement recommandé de privilégier `VSCode` pour l'apprentissage de `Git`. Son extension est très bien faite, bien meilleure que celle de `Jupyter`. 

`Colab` n'embarque pas, nativement, d'extension `Git`. Des sauvegardes automatiques sont possibles sur `Github` mais ce n'est pas une pratique à encourager. Pire encore, `Colab` proposera plutôt une intégration avec `Drive`, un autre produit `Google`. Certes le _notebook_ sera versionné puisque `Drive` embarque des sauvegardes de version mais ce n'est pas une technologie faite pour les sauvegardes de code ; elle n'apportera pas les bénéfices de `Git` qui seront évoqués ultérieurement.

Les élèves de l'ENSAE, et plus globalement l'ensemble des personnes pouvant bénéficier de l'infrastructure du SSPCloud[^eligibilite],
ont à disposition des environnements de développement `Python` avec `Git` préinstallé et accessible par l'intermédiaire d'interfaces connectées aux IDE. Ce _notebook_ est lançable sur cette infrastructure par le biais de ces boutons

[^eligibilite]: Pour savoir si vous êtes éligibles au SSPCloud, vous pouvez cliquer sur [ce lien](https://auth.lab.sspcloud.fr/auth/realms/sspcloud/login-actions/authenticate?client_id=onyxia) et consulter la liste des domaines autorisés. 

Si vous n'êtes pas éligibles au `SSPCloud`, le chemin pour obtenir un environnement prêt à l'emploi pour `Git` et `Python` est plus tortueux. Il est recommandé de télécharger et installer [`VSCode`](https://code.visualstudio.com/), d'ajouter _a minima_ les [extensions `Python`](https://code.visualstudio.com/docs/languages/python) et [`GitLens`](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens). Il est bien sûr possible d'aller plus loin dans la customisation de l'environnement de développement mais ce sont les briques minimales pour avoir un environnement local fonctionnel et ergonomique. 

:::

# Avant de démarrer: créer un compte `Github` et créer une copie de travail

La première étape se fait sur [`Github`](https://github.com). et consiste à se créer un compte sur cette plateforme.

::: {.exercise}
## Exercice 1 : Créer un compte `Github`

_Il est important de suivre pas à pas les consignes, chaque étape est importante_

1. Si vous n'en avez pas déjà un, créer un compte sur [github.com](https://github.com)
2. Créer un dépôt en suivant les consignes ci-dessous.
  + __Créer ce dépôt privé__, cela permettra
dans l'exercice 2 d'activer notre jeton. Vous pourrez le rendre public
après l'exercice 2, c'est comme vous le souhaitez.
  + __Créer ce dépôt avec un `README.md`__ en cliquant sur la case `Add a README file`
* Ajouter un `.gitignore` en sélectionnant le modèle `Python`

*Connexion sur <a href="https://github.com">https://github.com</a> > + (en haut de la page) > New repository > Renseigner le "Repository name" > Cocher "private" > "Create repository"*

:::


# Quelques bases sur `Git`

## Version distante, version locale

Nous avons, avec l'exercice précédent, créé un premier dépôt. Il s'agit d'un dépôt centralisé qui va servir de source de vérité pour notre projet et par l'intermédiaire duquel interagissent les contributeurs.trices d'un projet. Mais nous n'avons pas parlé de comment le faire évoluer, pour cela il faut créer des copies de travail. 

`Git` est un système décentralisé de contrôle de version[^asynchrone]. Cela signifie que les contributeurs.trices modifient les fichiers dans leur éditeur de prédilection puis soumettent ceux-ci pour mettre à jour la source de vérité, le dépôt distant

![Le principe décentralisé de `Git`](img/gitremote.png){#fig-local-remote}

Nous reviendrons plus précisément sur #fig-local-remote par la suite et notamment les nombreux termes techniques indiqués dessus. Mais la compréhension de cette distinction fondamentale entre dépôt distant et dépôt local était importante pour pouvoir démarrer. On appelle __forge__ une plateforme qui stocke des dépôts distants. Dans ce cours, nous allons présenter `Github` mais il en existe d'autres, notamment `Gitlab`.

Nous avons créé notre dépôt distant à l'exercice principal. Comme créer une version de travail ? Cette opération s'appelle faire un clône (`git clone`). L'objectif du prochain exercice est de faire cette opération, ce qui nécessite néanmoins la compréhension du concept d'authentification avant de pouvoir commencer celui-ci. 

[^asynchrone]: Plus précisément, `Git` est un système décentralisé et asynchrone de contrôle de version. Cela signifie qu'outre le fait qu'on édite ses fichiers sur des copies locales, on n'a pas besoin d'être connecté en continu au dépôt distant. On peut faire les modifications et les soumettre plus tard. 

Bien qu'il soit possible d'avoir une utilisation hors-ligne de `Git`, 
c'est-à-dire un pur contrôle de version local sans dépôt
distant, cela est une utilisation
rare et qui comporte un intérêt limité. L'intérêt de `Git` est
d'offrir une manière robuste et efficace d'interagir avec un 
dépôt distant facilitant ainsi la collaboration en équipe ou en
solitaire. 

::: {.tip}
## Pourquoi `Github` ?

Pour ces exercices, il est proposé
d'utiliser `Github`, la forge la plus visible[^1]. 
L'avantage de `Github` par rapport à son principal concurrent, `Gitlab`,
est que le premier est plus visible, car
mieux indexé par `Google` et concentre, en partie pour des raisons historiques, plus
de développeurs `Python` et `R` (ce qui est important dans des domaines comme
le code où les externalités de réseau jouent). 

[^1]: L'avantage que comportait `Gitlab` par rapport à `Github` 
à une époque, à savoir la possibilité de disposer gratuitement de ressources
pour faire de l'intégration continue, n'existe plus depuis que `Github`
a lancé son service `Github Actions`. Cependant, être familiarisé à 
l'environnement `Gitlab` reste utile car beaucoup de forges logicielles
internes reposent sur les fonctionalités _open-source_ (l'interface graphique
en faisant parti) de `Gitlab`. Il est donc fort utile de maîtriser 
les fonctionalités coeur de ces deux interfaces qui sont en fait quasi-identiques. Cela tombe bien, c'est l'objet de ce chapitre et du suivant.
:::


### S'authentifier à `Github` avec un jeton: principe

`Git` est un système décentralisé de contrôle de version :
les codes sont modifiés par chaque personne sur son poste de travail,
puis sont mis en conformité avec la version collective disponible
sur le dépôt distant au moment où le contributeur le décide.

Il est donc nécessaire que la forge connaisse l’identité de chacun des
contributeurs, afin de déterminer qui est l’auteur d’une modification apportée
aux codes stockés dans le dépôt distant.
Pour que `Github` reconnaisse un utilisateur proposant des modifications,
il est nécessaire de s’authentifier (un dépôt distant, même public, ne peut pas être modifié par n’importe qui). L’authentification consiste ainsi à fournir un élément que seul vous et la forge êtes censés connaître : un mot de passe, une clé compliquée, un jeton d’accès...

Plus précisément, il existe deux modalités pour faire connaître son identité à `Github` :

* une __authentification HTTPS__ (décrite ici) : l’authentification se fait avec un login et un mot de passe ou avec un _token_ (un mot de passe compliqué généré automatiquement par `Github` et connu exclusivement du détenteur du compte `Github`)  ;
* une __authentification SSH__ : l’authentification se fait par une clé cryptée disponible sur le poste de travail et que `GitHub` ou `GitLab` connaît. Une fois configurée, cette méthode ne nécessite plus de faire connaître son identité : l’empreinte digitale que constitue la clé suffit à reconnaître un utilisateur. Ce n'est pas la méthode que nous appliquerons ici[^ssh-utilitr].

[^ssh-utilitr]: La [documentation collaborative `utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_configurer_git.html#interaction-avec-un-d%C3%A9p%C3%B4t-distant-principe) présente les raisons pour lesquelles il convient de favoriser
la méthode HTTPS sur la méthode SSH. 

::: {.note}
## Note sur la double authentification

Depuis Août 2021, `Github` n'autorise plus l'authentification par mot de passe
lorsqu'on interagit (`pull`/`push`) avec un dépôt distant
([raisons ici](https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/)).
Il est nécessaire d'utiliser un *token* (jeton d'accès) qui présente l'avantage
d'être révoquable (on peut à tout moment supprimer un jeton si, par exemple,
on suspecte qu'il a été diffusé par erreur) et à droits limités 
(le jeton permet certaines opérations standards mais
n'autorise pas certaines opérations déterminantes comme la suppression
d'un dépôt).

GitHub commencera progressivement à exiger que tous les utilisateurs de GitHub activent une ou plusieurs formes d'authentification à deux facteurs (2FA). Pour plus d’informations sur le déploiement de l’inscription 2FA, consultez [cet article de blog](https://github.blog/2023-03-09-raising-the-bar-for-software-security-github-2fa-begins-march-13/). Concrètement, cela signifie que vous devrez au choix :

- Renseigner votre numéro de portable pour valider certaines connexions grâce à un code que vous recevrez par sms ;
- Installer une application d'authentification (Ex : Microsoft Authenticator) installée sur votre téléphone qui génèrera un QR code que vous pourrez scanner depuis github, ce qui ne nécessite pas que vous ayez à fournir votre numéro de téléphone
- Utiliser une clef USB de sécurité 

Pour choisir entre ces différentes options, vous pouvez vous rendre sur *Settings > Password and authentication > Enable two-factor authentication*.

:::

::: {.important}

Il est important de ne jamais stocker un _token_, et encore moins son mot de passe, dans un projet.
Il est possible de stocker un mot de passe ou *token* de manière sécurisée et durable
avec le *credential helper* de `Git`. Celui-ci est présenté par la suite.

S'il n'est pas possible d'utiliser le *credential helper* de `Git`, un mot de passe 
ou _token_ peut être stocké de manière sécurisé dans
un système de gestion de mot de passe comme [Keepass](https://keepass.fr/).

Ne jamais stocker un jeton `Github`, ou pire un mot de passe, dans un fichier
texte non crypté. Les logiciels de gestion de mot de passe
(comme [Keepass](https://keepass.fr/), recommandé par l'Anssi)
sont simples
d'usage et permettent de ne conserver sur l'ordinateur qu'une version
hashée du mot de passe qui ne peut être décryptée qu'avec un mot de passe
connu de vous seuls. 

:::

### Créer un jeton

La [documentation officielle](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) comporte un certain nombre de captures d'écran expliquant
comment procéder. En gardant cette documentation ouverte en cas de doute, et les instructions du prochain exercice, nous allons pouvoir créer un jeton d'authentification. 

::: {.exercise}
## Exercice 2 : Créer un _token_

Suivre la
[documentation officielle](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) en ne donnant que les droits `repo` au jeton[^droits].

[^droits]: Comme vous pouvez le voir, il y a de nombreux niveaux de droits différents. Votre mot de passe a en fait tout ces droits, ce qui illustre bien le pouvoir dangereux de celui-ci s'il est découvert, que ce soit du fait d'une révélation par erreur ou d'un _hacking_ de celui-ci par quelqu'un malveillant. L'utilisation de _token_ sécurise énormément votre dépôt puisqu'il ne peut pas être supprimé si le _token_ a des droits limités. De plus, si la branche principale est protégée, ce qui est le comportement par défaut de `Github`, il ne sera pas possible sans mot de passe de détruire l'historique du dépôt. 

Pour résumer les étapes devraient être les suivantes :

*Settings > Developers Settings > Personal Access Token > Generate a new token > "My bash script" > Expiration "30 days" > cocher juste "repo" > Generate token > Le copier*

__⚠️ Gardez la page ouverte__, le _token_ n'apparaît qu'une fois et nous n'avons pas encore fait l'effort de le stocker à un endroit pérenne. Cela sera l'objet du prochain exercice. 

:::

Nous avons créé un _token_ et comme cela est indiqué sur la page de `Github` ou dans les consignes de l'exercice, celui-ci n'est pas pérenne. Il va donc falloir trouver un moyen de conserver celui-ci quelque part. Nous allons proposer plusieurs solutions pour cela. Ecrire celui-ci dans un fichier texte créé avec le bloc note ne fait pas parti de ces solutions, au contraire c'est une très mauvaise pratique. 

::: {.exercise}
## Exercice 3: stocker son jeton (pour les utilisateurs du `SSPCloud`)

Le `SSPCloud` propose un service de stockage d'un jeton qui peut ensuite servir facilement pour s'authentifier sur `Github` quand on utilise `VSCode` ou `Jupyter`. 

* Copier le jeton qui est affiché sur la page de `Github` qui a été ouverte précédemment. Ne faites pas la sélection des lettres à la main, utilisez le bouton dédié au copier-coller ({{< fa solid clipboard >}})
* Cliquer sur la section ["Mon Compte"](https://datalab.sspcloud.fr/account/) du `SSPCloud`. Aller dans l'onglet `Git` et coller la valeur précédemment copiée. 

On peut s'arrêter à ce stade, nous utiliserons ce jeton lors du prochain exercice. 

:::

::: {.exercise}
## Exercice 3bis: stocker son jeton (pour les personnes n'ayant pas l'accès au `SSPCloud`)

La solution recommandée est de stocker son jeton dans un un gestionnaire de mot de passe comme 
[Keepass](https://keepass.fr/) (recommandé par l'Anssi). Il s'agit d'un logiciel qui stocke, de manière chiffrée, les mots de passe qui y sont conservés selon la logique du coffre fort numérique. 

Au-delà de l'intérêt pour stocker un jeton Github pour ce cours, ces logiciels sont très pratiques au quotidien et sécurisent l'accès à des services numériques sensibles. Ils comportent aussi des générateurs de mot de passe forts qui permettent de réduire les risques d'usurpation numérique en rendant quasi-impossible des techniques comme [l'attaque par force brute](https://fr.wikipedia.org/wiki/Attaque_par_force_brute).

:::

Maintenant que nous avons stocké notre jeton dans un endroit sécurisé, nous pouvons passer à l'étape suivante qui consiste à récupérer notre dépôt distant dans une copie de travail, opération qui nous amènera à réellement utiliser le jeton que nous avons mis de côté pour le moment. 


::: {.exercise}
## Exercice 4a: créer un service et comprendre le principe du clône et de l'authentification (utilisateurs du SSPCloud)

1. Sur le SSPCloud, se rendre dans la page [Mes Services](https://datalab.sspcloud.fr/my-services).

2. Cliquer sur `➕​ Nouveau service` et choisir un service `vscode-python` (ne pas en prendre un autre).

3. Laisser les paramètres par défaut et lancer le service. 

4. Une fois le service prêt, cliquer sur le bouton "Cliquez pour copier le mot de passe du service". Cela va stocker le mot de passe du service (généré aléatoirement, celui-ci n'a rien à voir avec votre mot de passe général du `SSPCloud`) dans le presse papier. Ce mot de passe est également visible en clair dans la partie qui est caviardée sur la @fig-readme-sspcloud. 

![](img/README.png){#fig-readme-sspcloud}

5. Coller ce mot de passe dans le champ `Password` qui s'affiche quand vous ouvrez le service. 

6. Dans un autre onglet, récupérer, sur la page d'accueil de votre dépôt, l'url du dépôt distant qui est accessible en cliquant à droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

7. Ouvrir le terminal (`☰ > Terminal > New Terminal`) et commencer à taper 

```python
git clone # coller votre url de la forme https://github.com/<username>/<reponame>.git 
```

pour coller à la suite votre URL, si <kbd>CTRL</kbd>+<kbd>V</kbd> est bloqué par le navigateur, vous pouvez faire <kbd>MAJ</kbd>+<kbd>Inser</kbd>. Taper <kbd>Entrée</kbd>.

8. Une page va s'ouvrir _"The extension 'GitHub' wants to sign in using GitHub"_. Refuser en cliquant sur _"Cancel"_ (les questions optionnelles montrent ce qu'il se passe quand vous acceptez, vous basculez sur un autre mode d'authentification).

9. Dans la fenêtre en haut, taper votre username d'abord. Puis lorsqu'il vous demande votre mot de passe, **coller votre _token_, pas votre mot de passe `Github`** (si vous avez toujours la page `Github` ouverte, le copier de là, sinon en retournant sur la page [Mon compte](https://datalab.sspcloud.fr/account/git) du `SSPCloud`)

8. Observer la mise à jour de l'explorateur de fichiers sur `VSCode`, votre `README` et votre `.gitignore` visibles sur `Github` doivent maintenant être là. 

9. Taper `cd mon-petit-projet` en supposant que le dossier de votre dépôt s'appelle `mon-petit-projet`. Puis taper `git remote -v`, une commande qui demande à `Git` de voir où pointe `origin`, votre dépôt distant. La réponse devrait être l'URL que vous avez renseigné précedemment

Ceci était une illustration nécessaire pour comprendre le principe de l'authentification. Le prochain exercice (4b) proposera une manière plus directe de fonctionner, qu'il est utile de connaître car elle vous évitera d'avoir à vous authentifier à chaque interaction avec le dépôt distant. 

En option, pour comprendre la différence avec l'authentification déléguée proposée par VSCode, vous pouvez faire, de manière optionnelle, les consignes suivantes:

1. Toujours dans le même VSCode, ouvrir un nouveau terminal (`☰ > Terminal > New Terminal`)

2. Taper `git clone https://github.com/<username>/<reponame>.git repo-bis` en remplaçant `https://github.com/<username>/<reponame>.git` par l'URL de votre dépôt. Cela clônera votre dépôt dans le dossier `repo-bis` quand vous serez effectivement authentifié.

3. Cette fois accepter l'authentification déléguée proposée par VSCode. Il s'agit d'une authentification à deux facteurs:
    * Le premier facteur d'authentification est le code que `Github` vous demande de copier et de renseigner dans la page que `VSCode` désire ouvrir (il faut que vous acceptiez de copier et d'ouvrir la page). Coller ce code à 8 caractères, valider et accepter les droits demandés par l'application. 
    * Le deuxième facteur est le code de votre application d'authentification (par exemple `Google Authenticator` ou celui que vous recevez par SMS). Mettre celui-ci et valider, le clône devrait démarrer

:::

Cet exercice vient de nous illustrer le principe de l'authentification et la manière dont `VSCode` peut attester de votre identité grâce à un _token_ ou à une double authentification. L'exercice suivant propose une méthode d'authentification par token un peu plus pratique que celle que nous avions mise en oeuvre ☝️. 


::: {.exercise}
## Exercice 4b: créer un service et comprendre le principe du clône et de l'authentification (utilisateurs du SSPCloud)

Cette approche montre comment le SSPCloud injecte lors de la création d'un service VSCode le _token_ et le dépôt que vous désirez clôner. 


1. Sur le SSPCloud, se rendre dans la page [Mes Services](https://datalab.sspcloud.fr/my-services). Vous pouvez supprimer le service existant, il n'est plus nécessaire.

2. Cliquer sur `➕​ Nouveau service` et choisir un service `vscode-python` (ne pas en prendre un autre).

3. Dans un autre onglet, récupérer, sur la page d'accueil de votre dépôt, l'url du dépôt distant qui est accessible en cliquant à droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`


* Dérouler le menu `Configuration Vscode-python` et chercher l'onglet `Git`

* Dans celui-ci, vous devriez voir votre _token_ pré-injecté dans le formulaire. Ne le changez pas. 

* Dans un autre onglet, récupérer, sur la page d'accueil de votre dépôt, l'url du dépôt distant qui est accessible en cliquant à droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

Vous pouvez utiliser l'icone à droite {{< fa brands clipboard >}} pour copier l'url.

* Coller celle-ci dans le champ `Repository` du formulaire de création du service sur le `SSPCloud`.  Lancer le service et attendre qu'il se crée (une vingtaine de secondes).

* Le clône du dépôt distant devrait être visible dans l'aborescence des fichiers. 

* Ouvrir le terminal (`☰ > Terminal > New Terminal`) et taper `git remote -v`, une commande qui demande à `Git` de voir où pointe `origin`, votre dépôt distant. La réponse prend la forme:

```python
https://ghp_XXXX@github.com/username/repository.git
```

qui se distingue de l'URL que vous aviez renseigné dans l'onglet `Git`. 
Comme vous pouvez le voir avec cette méthode, le jeton est en clair. C'est pour cette raison qu'on utilise, plutôt que des mots de passe, des jetons
puisque, si ces derniers sont révélés, on peut toujours les révoquer et éviter
les problèmes

:::


::: {.exercise collapse="true"}
## Exercice 4 alternatif: quand on ne dispose pas de compte sur le `SSPCloud`

Le mode opératoire est très proche. En pratique, la seule différence est qu'il n'y a pas besoin de créer de nouveau service puisqu'une installation de `VSCode` existe déjà. 

1. Sur votre navigateur, récupérer, sur la page d'accueil de votre dépôt, l'url du dépôt distant qui est accessible en cliquant à droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

7. Ouvrir le terminal (`Terminal > New Terminal`) et commencer à taper 

```
git clone
```

et coller la valeur copiée précédemment. Ne validez pas. Avec les touches directionnelles, se placer entre `https://` et `github.com`. Récupérer dans votre navigateur ou Keepass votre jeton Github. Coller celui-ci puis ajouter `@`. Cela devrait donner 

```python
https://ghp_XXXX@github.com/username/repository.git
```

Ce qui, dans l'ensemble, fera

```python
git clone https://ghp_XXXX@github.com/username/repository.git
```

* Le clône du dépôt distant devrait être visible dans l'aborescence des fichiers. 

Comme vous pouvez le voir avec cette méthode, le jeton est en clair. C'est pour cette raison qu'on utilise, plutôt que des mots de passe, des jetons
puisque, si ces derniers sont révélés, on peut toujours les révoquer et éviter
les problèmes

:::



## La _staging area_

Dans un monde sans `Git`, on écrit du code, on sauvegarde son script et parfois on considère que cette version vaut le coup d'être considérée comme une version de laquelle repartir. Avec `Git` c'est la même chose, seulement se principe sera formalisé plus proprement. 

Le premier niveau conceptuel est celui de l'index des modifications. Il s'agit des modifications en attente de validation, d'où le nom de _staging area_ dans la première partie de @fig-staging-area. 

![La gymnastique de `Git` dans son ensemble](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/completeworkflow.png){#fig-staging-area}

En principe, quand on édite des scripts ou _notebooks_, on enregistre régulièrement ceux-ci. Le niveau d'implication suivant est de mettre de côté une version particulière de ceux-ci, ce qu'à la main (voir la @version-control-inferno), nous ferions en dupliquant le fichier. Cela implique de mettre une ou plusieurs modifications dans la liste d'attente des modifications à valider. Cette opération s'appelle `git add` et est l'objet du prochain exercice. 


::: {.exercise}
## Exercice 5 : Indexer des modifications

1. Créer un dossier 📁 `scripts` dans le dossier de votre dépôt. Sur `VSCode`, vous pouvez utiliser les icônes adaptées. 
2. Y créer les fichiers `script1.py` et `script2.py`, chacun contenant quelques commandes `Python` de votre choix (le contenu de ces fichiers n'est pas important).

3. Se rendre dans l'extension `Git` de `VSCode`. Vous devriez
retrouver un cadre ayant cet aspect 

::: {#fig-status layout-ncol=2}

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git_vscode_1.png)

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git-status-ensae.png)


Interface graphique Git sous VSCode (à gauche) et Jupyter (à droite)
:::

En ligne de commande, c'est l'équivalent de 

```shell
git status
```

2. Sur `VSCode`, un bouton `+` figure à droite du nom
du fichier `.script1.py` et
`.script2.py`. Sur `Jupyter`, en passant votre souris au dessus du nom des fichiers `script1.py` et
`script2.py`, vous devriez voir
un `+` apparaître. Cliquez dessus. 

Si vous aviez privilégié la ligne de commande, ce que vous avez fait est équivalent à :

~~~shell
git add scripts/script1.py
git add scripts/script2.py
~~~

3. Observer le changement de statut du fichier après avoir cliqué sur `+`. Il est
désormais dans la partie `Staged`
En gros, vous venez de dire à `Git` que vous allez rendre publique une évolution
du fichier, mais vous ne l'avez pas encore fait (`Staged` est une liste d'attente).

Si vous étiez en ligne de commande vous auriez ce résultat après un `git status`

```raw
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   .gitignore
```


Les nouvelles modifications (en
l'occurrence la création du fichier et la validation de son contenu actuel)
ne sont pas encore archivées. Pour cela, il va falloir faire un 
`commit` (on rend publique une modification)

4. Avant cela, regardons les modifications qu'on va prochainement
valider. Pour cela, passez la souris au dessus du nom du fichier
`.gitignore` et cliquer sur le bouton `Diff this file` (+ -).
Une page s'ouvre et met en regard la version antérieure avec
les ajouts en vert et les suppressions en rouge. Nous retrouverons
cette visualisation avec l'interface `Github`, plus tard. 

En l'occurrence, comme le fichier n'existait pas, normalement nous n'avons que
des ajouts.

Il est également possible d'effectuer cela avec la ligne de commande mais c'est
beaucoup moins pratique. Pour cela, la commande à appeler est `git diff` et
il est nécessaire d'utiliser l'option `cached` pour lui dire d'inspecter les
fichiers pour lesquels on n'a pas encore effectué de `commit`. En vert
apparaîtront les modifications et en rouge les suppressions mais, cette fois,
les résultats ne seront pas mis côte-à-côte ce qui est beaucoup moins
pratique.

```shell
git diff --cached
```

:::


OLD


## Dépôt local et distant

Pour comprendre le principe de `Git`, il est utile de distinguer
deux niveaux: le dépôt 

`Git` est un système décentralisé et asynchrone de gestion de version. 
Cela signifie que:

* Chaque membre d'un projet travaille sur une copie locale du dépôt
(système *decentralisé*). Cette copie de travail s'appelle un `clone`.
Cela signifie qu'on n'a pas une cohérence en continu de notre version
de travail avec le dépôt ; on peut très bien ne jamais vouloir les
mettre en cohérence (par exemple, si on teste une piste qui s'avère
infructueuse) ;
* C'est lorsqu'on propose la publication de modifications sur le dépôt
collectif qu'on doit s'assurer de la cohérence avec la version disponible
en ligne (système *asynchrone*).

Le dépôt distant est généralement stocké sur
une **forge  logicielle** (`Github` ou `Gitlab`) et sert à centraliser la version
collective d'un projet. Les copies locales sont des copies de travail
qu'on utilise pour faire évoluer un projet :


Il est tout à fait possible de faire du contrôle de version sans
mettre en place de dépôt distant. Cependant, 

* c'est dangereux puisque le dépôt distant fait office de sauvegarde 
d'un projet. Sans dépôt distant, on peut tout perdre en cas de problème
sur la copie locale de travail ;
* c'est désirer être moins efficace car, comme nous allons le montrer, les
fonctionalités des plateformes `Github` et `Gitlab` sont également très 
bénéfiques lorsqu'on travaille tout seul. 

## Principe


Les trois manipulations les plus courantes sont les suivantes et représentées sur le diagramme ci-après :

* `commit` : je valide les modifications que j'ai faites en local avec un message qui les explique
* `pull` : je récupère la dernière version des codes du dépôt distant
* `push` : je transmets mes modifications validées au dépôt distant

![](https://gitlab.com/linogaliana/collaboratif/-/raw/main/pics/03_git/push_pull_Drees.png)

Les deux dernières manipulations correspondent aux interactions (notamment
la mise en cohérence) avec
le dépôt commun alors que la première manipulation `commit` correspond à
la modification des fichiers faite pour faire évoluer un projet. 

De manière plus précise, il y a trois étapes avant d'envoyer les modifications validées (`commit`) au dépôt. Elles se définissent en fonction des commandes qui permettent de les appliquer quand Git est utilisé en lignes de commandes :

* `diff` : inspection des modifications. Cela permet de comparer les fichiers modifiés et de distinguer les fichiers ajoutés ou supprimés.
* `staging area` : sélection des modifications.
* `commit` : validation des modifications sélectionnées (avec commentaire).

![](https://gitlab.com/linogaliana/collaboratif/-/raw/main/pics/03_git/trois_%C3%A9tats_fichier.png)


Lors des étapes de `push` et `pull`, des **conflits** peuvent apparaître, par exemple lorsque deux personnes ont modifié le même programme simultanément. Le terme conflit peut faire peur mais en fait c'est 
l'un des apports principaux de `Git` que de faciliter énormément la gestion
de versions différentes. Les exercices du chapitre suivant l'illustreront.  

## Les branches


C'est une des fonctionnalités les plus pratiques de la gestion de version. 
La création de `branches` dans un projet (qui devient ainsi un arbre)
permet de développer en parallèle des correctifs ou une nouvelle fonctionnalité
sans modifier le dépôt commun.

Cela permet de séparer le nouveau développement et de faire cohabiter plusieurs versions, pouvant évoluer séparément ou pouvant être facilement rassemblées. Git est optimisé pour le travail sur les branches.

Dans un projet collaboratif, une branche dite **master** joue le rôle du tronc.
C'est autour d'elle que vont pousser ou se greffer les branches.
L'un des avantages de `Git` est qu'on peut toujours revenir en arrière. Ce
filet de sécurité permet d'oser des expérimentations, y compris au sein
d'une branche. Il faut être prêt à aller dans la ligne de commande pour cela
mais c'est extrêmement confortable. 

::: {.cell .markdown}
```{=html}
<div class="alert alert-info" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-comment"></i> Note</h3>
```

Comment nommer les branches ? Là encore, il y a énormément de conventions différentes. Une fréquemment observée est :

- pour les nouvelles fonctionnalités : `feature/nouvelle-fonctionnalite` où `nouvelle-fontionnalite` est un nom court résumant la fonctionnalité
- pour les corrections de bug : `issue-num` où `num` est le numéro de l'issue

N'hésitez pas à aller encore plus loin dans la normalisation  !

```{=html}
</div>
```
:::



# Conseil de praticien : ne pas négliger le `.gitignore`

Un fichier à ne pas négliger est le `.gitignore`. Il s'agit d'un garde-fou car tous les fichiers (notamment des
données, potentiellement volumineuses ou confidentielles) n'ont pas vocation
à être partagés.

Le site [gitignore.io](https://www.toptal.com/developers/gitignore) est très pratique. Le fichier
suivant est par exemple proposé pour les utilisateurs de `Python`, auquel on peut ajouter
quelques lignes adaptées aux utilisateurs de données :

<details>
<summary>

Exemple de `.gitignore` pour les utilisateurs de données

</summary>

```markdown
"""
~~~raw
*.html
*.pdf
*.csv
*.tsv
*.json
*.xml
*.shp
*.xls
*.xlsx

### Python ###
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a Python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/
~~~
"""
)
```

</details>