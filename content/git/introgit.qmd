---
title: "D√©couvrir Git par la pratique: la gymnastique quotidienne"
categories:
  - Tutoriel
  - Git
description: |
  `Git` est un syst√®me de contr√¥le de version qui facilite la
  sauvegarde, la gestion des √©volutions et le partage
  d'un projet informatique. Il s'agit d'un √©l√©ment devenu
  indispensable dans le domaine de la _data science_.
  Ce chapitre pr√©sente quelques concepts qui seront 
  mis en pratique dans le suivant. 
image: https://ensae-reproductibilite.github.io/website/snakedolls.jpg
echo: false
---

Le [chapitre d'introduction](/content/git/index.qmd) de la partie a √©voqu√© les enjeux, pr√©sent√©s de mani√®re synth√©tique
dans un [cours d√©di√© fait avec Romain Avouac](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html)

:::{.cell .markdown}
D√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/ggplot.qmd)
pour afficher les slides en plein √©cran.

```{=html}
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><iframe class="sourceCode yaml code-with-copy" src="https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html#/partie-1-contr%C3%B4le-de-version-avec-git"></iframe></div>
```

:::

Ce chapitre va √™tre l'occasion de faire ses premiers pas avec `Git`. Le prochain chapitre sera consacr√© au travail collaboratif. 

Pour comprendre les analogies avec le versionnage artisinal √† la main, rappelons nous le principe de celui-ci avec la @version-control-inferno

![Le contr√¥le de version artisanal](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/fichiers_multiples.png){#version-control-inferno}


::: {.important}
Il est vivement recommand√© de privil√©gier `VSCode` pour l'apprentissage de `Git`. Son extension est tr√®s bien faite, bien meilleure que celle de `Jupyter`. 

`Colab` n'embarque pas, nativement, d'extension `Git`. Des sauvegardes automatiques sont possibles sur `Github` mais ce n'est pas une pratique √† encourager. Pire encore, `Colab` proposera plut√¥t une int√©gration avec `Drive`, un autre produit `Google`. Certes le _notebook_ sera versionn√© puisque `Drive` embarque des sauvegardes de version mais ce n'est pas une technologie faite pour les sauvegardes de code ; elle n'apportera pas les b√©n√©fices de `Git` qui seront √©voqu√©s ult√©rieurement.

Les √©l√®ves de l'ENSAE, et plus globalement l'ensemble des personnes pouvant b√©n√©ficier de l'infrastructure du SSPCloud[^eligibilite],
ont √† disposition des environnements de d√©veloppement `Python` avec `Git` pr√©install√© et accessible par l'interm√©diaire d'interfaces connect√©es aux IDE. Ce _notebook_ est lan√ßable sur cette infrastructure par le biais de ces boutons

[^eligibilite]: Pour savoir si vous √™tes √©ligibles au SSPCloud, vous pouvez cliquer sur [ce lien](https://auth.lab.sspcloud.fr/auth/realms/sspcloud/login-actions/authenticate?client_id=onyxia) et consulter la liste des domaines autoris√©s. 

Si vous n'√™tes pas √©ligibles au `SSPCloud`, le chemin pour obtenir un environnement pr√™t √† l'emploi pour `Git` et `Python` est plus tortueux. Il est recommand√© de t√©l√©charger et installer [`VSCode`](https://code.visualstudio.com/), d'ajouter _a minima_ les [extensions `Python`](https://code.visualstudio.com/docs/languages/python) et [`GitLens`](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens). Il est bien s√ªr possible d'aller plus loin dans la customisation de l'environnement de d√©veloppement mais ce sont les briques minimales pour avoir un environnement local fonctionnel et ergonomique. 

:::

# Avant de d√©marrer: cr√©er un compte `Github` et cr√©er une copie de travail

La premi√®re √©tape se fait sur [`Github`](https://github.com). et consiste √† se cr√©er un compte sur cette plateforme.

::: {.exercise}
## Exercice 1 : Cr√©er un compte `Github`

_Il est important de suivre pas √† pas les consignes, chaque √©tape est importante_

1. Si vous n'en avez pas d√©j√† un, cr√©er un compte sur [github.com](https://github.com)
2. Cr√©er un d√©p√¥t en suivant les consignes ci-dessous.
  + __Cr√©er ce d√©p√¥t priv√©__, cela permettra
dans l'exercice 2 d'activer notre jeton. Vous pourrez le rendre public
apr√®s l'exercice 2, c'est comme vous le souhaitez.
  + __Cr√©er ce d√©p√¥t avec un `README.md`__ en cliquant sur la case `Add a README file`
* Ajouter un `.gitignore` en s√©lectionnant le mod√®le `Python`

*Connexion sur <a href="https://github.com">https://github.com</a> > + (en haut de la page) > New repository > Renseigner le "Repository name" > Cocher "private" > "Create repository"*

:::


# Quelques bases sur `Git`

## Version distante, version locale

Nous avons, avec l'exercice pr√©c√©dent, cr√©√© un premier d√©p√¥t. Il s'agit d'un d√©p√¥t centralis√© qui va servir de source de v√©rit√© pour notre projet et par l'interm√©diaire duquel interagissent les contributeurs.trices d'un projet. Mais nous n'avons pas parl√© de comment le faire √©voluer, pour cela il faut cr√©er des copies de travail. 

`Git` est un syst√®me d√©centralis√© de contr√¥le de version[^asynchrone]. Cela signifie que les contributeurs.trices modifient les fichiers dans leur √©diteur de pr√©dilection puis soumettent ceux-ci pour mettre √† jour la source de v√©rit√©, le d√©p√¥t distant

![Le principe d√©centralis√© de `Git`](img/gitremote.png){#fig-local-remote}

Nous reviendrons plus pr√©cis√©ment sur #fig-local-remote par la suite et notamment les nombreux termes techniques indiqu√©s dessus. Mais la compr√©hension de cette distinction fondamentale entre d√©p√¥t distant et d√©p√¥t local √©tait importante pour pouvoir d√©marrer. On appelle __forge__ une plateforme qui stocke des d√©p√¥ts distants. Dans ce cours, nous allons pr√©senter `Github` mais il en existe d'autres, notamment `Gitlab`.

Nous avons cr√©√© notre d√©p√¥t distant √† l'exercice principal. Comme cr√©er une version de travail ? Cette op√©ration s'appelle faire un cl√¥ne (`git clone`). L'objectif du prochain exercice est de faire cette op√©ration, ce qui n√©cessite n√©anmoins la compr√©hension du concept d'authentification avant de pouvoir commencer celui-ci. 

[^asynchrone]: Plus pr√©cis√©ment, `Git` est un syst√®me d√©centralis√© et asynchrone de contr√¥le de version. Cela signifie qu'outre le fait qu'on √©dite ses fichiers sur des copies locales, on n'a pas besoin d'√™tre connect√© en continu au d√©p√¥t distant. On peut faire les modifications et les soumettre plus tard. 

Bien qu'il soit possible d'avoir une utilisation hors-ligne de `Git`, 
c'est-√†-dire un pur contr√¥le de version local sans d√©p√¥t
distant, cela est une utilisation
rare et qui comporte un int√©r√™t limit√©. L'int√©r√™t de `Git` est
d'offrir une mani√®re robuste et efficace d'interagir avec un 
d√©p√¥t distant facilitant ainsi la collaboration en √©quipe ou en
solitaire. 

::: {.tip}
## Pourquoi `Github` ?

Pour ces exercices, il est propos√©
d'utiliser `Github`, la forge la plus visible[^1]. 
L'avantage de `Github` par rapport √† son principal concurrent, `Gitlab`,
est que le premier est plus visible, car
mieux index√© par `Google` et concentre, en partie pour des raisons historiques, plus
de d√©veloppeurs `Python` et `R` (ce qui est important dans des domaines comme
le code o√π les externalit√©s de r√©seau jouent). 

[^1]: L'avantage que comportait `Gitlab` par rapport √† `Github` 
√† une √©poque, √† savoir la possibilit√© de disposer gratuitement de ressources
pour faire de l'int√©gration continue, n'existe plus depuis que `Github`
a lanc√© son service `Github Actions`. Cependant, √™tre familiaris√© √† 
l'environnement `Gitlab` reste utile car beaucoup de forges logicielles
internes reposent sur les fonctionalit√©s _open-source_ (l'interface graphique
en faisant parti) de `Gitlab`. Il est donc fort utile de ma√Ætriser 
les fonctionalit√©s coeur de ces deux interfaces qui sont en fait quasi-identiques. Cela tombe bien, c'est l'objet de ce chapitre et du suivant.
:::


### S'authentifier √† `Github` avec un jeton: principe

`Git` est un syst√®me d√©centralis√© de contr√¥le de version :
les codes sont modifi√©s par chaque personne sur son poste de travail,
puis sont mis en conformit√© avec la version collective disponible
sur le d√©p√¥t distant au moment o√π le contributeur le d√©cide.

Il est donc n√©cessaire que la forge connaisse l‚Äôidentit√© de chacun des
contributeurs, afin de d√©terminer qui est l‚Äôauteur d‚Äôune modification apport√©e
aux codes stock√©s dans le d√©p√¥t distant.
Pour que `Github` reconnaisse un utilisateur proposant des modifications,
il est n√©cessaire de s‚Äôauthentifier (un d√©p√¥t distant, m√™me public, ne peut pas √™tre modifi√© par n‚Äôimporte qui). L‚Äôauthentification consiste ainsi √† fournir un √©l√©ment que seul vous et la forge √™tes cens√©s conna√Ætre : un mot de passe, une cl√© compliqu√©e, un jeton d‚Äôacc√®s...

Plus pr√©cis√©ment, il existe deux modalit√©s pour faire conna√Ætre son identit√© √† `Github` :

* une __authentification HTTPS__ (d√©crite ici) : l‚Äôauthentification se fait avec un login et un mot de passe ou avec un _token_ (un mot de passe compliqu√© g√©n√©r√© automatiquement par `Github` et connu exclusivement du d√©tenteur du compte `Github`)  ;
* une __authentification SSH__ : l‚Äôauthentification se fait par une cl√© crypt√©e disponible sur le poste de travail et que `GitHub` ou `GitLab` conna√Æt. Une fois configur√©e, cette m√©thode ne n√©cessite plus de faire conna√Ætre son identit√© : l‚Äôempreinte digitale que constitue la cl√© suffit √† reconna√Ætre un utilisateur. Ce n'est pas la m√©thode que nous appliquerons ici[^ssh-utilitr].

[^ssh-utilitr]: La [documentation collaborative `utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_configurer_git.html#interaction-avec-un-d%C3%A9p%C3%B4t-distant-principe) pr√©sente les raisons pour lesquelles il convient de favoriser
la m√©thode HTTPS sur la m√©thode SSH. 

::: {.note}
## Note sur la double authentification

Depuis Ao√ªt 2021, `Github` n'autorise plus l'authentification par mot de passe
lorsqu'on interagit (`pull`/`push`) avec un d√©p√¥t distant
([raisons ici](https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/)).
Il est n√©cessaire d'utiliser un *token* (jeton d'acc√®s) qui pr√©sente l'avantage
d'√™tre r√©voquable (on peut √† tout moment supprimer un jeton si, par exemple,
on suspecte qu'il a √©t√© diffus√© par erreur) et √† droits limit√©s 
(le jeton permet certaines op√©rations standards mais
n'autorise pas certaines op√©rations d√©terminantes comme la suppression
d'un d√©p√¥t).

GitHub commencera progressivement √† exiger que tous les utilisateurs de GitHub activent une ou plusieurs formes d'authentification √† deux facteurs (2FA). Pour plus d‚Äôinformations sur le d√©ploiement de l‚Äôinscription 2FA, consultez [cet article de blog](https://github.blog/2023-03-09-raising-the-bar-for-software-security-github-2fa-begins-march-13/). Concr√®tement, cela signifie que vous devrez au choix :

- Renseigner votre num√©ro de portable pour valider certaines connexions gr√¢ce √† un code que vous recevrez par sms ;
- Installer une application d'authentification (Ex : Microsoft Authenticator) install√©e sur votre t√©l√©phone qui g√©n√®rera un QR code que vous pourrez scanner depuis github, ce qui ne n√©cessite pas que vous ayez √† fournir votre num√©ro de t√©l√©phone
- Utiliser une clef USB de s√©curit√© 

Pour choisir entre ces diff√©rentes options, vous pouvez vous rendre sur *Settings > Password and authentication > Enable two-factor authentication*.

:::

::: {.important}

Il est important de ne jamais stocker un _token_, et encore moins son mot de passe, dans un projet.
Il est possible de stocker un mot de passe ou *token* de mani√®re s√©curis√©e et durable
avec le *credential helper* de `Git`. Celui-ci est pr√©sent√© par la suite.

S'il n'est pas possible d'utiliser le *credential helper* de `Git`, un mot de passe 
ou _token_ peut √™tre stock√© de mani√®re s√©curis√© dans
un syst√®me de gestion de mot de passe comme [Keepass](https://keepass.fr/).

Ne jamais stocker un jeton `Github`, ou pire un mot de passe, dans un fichier
texte non crypt√©. Les logiciels de gestion de mot de passe
(comme [Keepass](https://keepass.fr/), recommand√© par l'Anssi)
sont simples
d'usage et permettent de ne conserver sur l'ordinateur qu'une version
hash√©e du mot de passe qui ne peut √™tre d√©crypt√©e qu'avec un mot de passe
connu de vous seuls. 

:::

### Cr√©er un jeton

La [documentation officielle](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) comporte un certain nombre de captures d'√©cran expliquant
comment proc√©der. En gardant cette documentation ouverte en cas de doute, et les instructions du prochain exercice, nous allons pouvoir cr√©er un jeton d'authentification. 

::: {.exercise}
## Exercice 2 : Cr√©er un _token_

Suivre la
[documentation officielle](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) en ne donnant que les droits `repo` au jeton[^droits].

[^droits]: Comme vous pouvez le voir, il y a de nombreux niveaux de droits diff√©rents. Votre mot de passe a en fait tout ces droits, ce qui illustre bien le pouvoir dangereux de celui-ci s'il est d√©couvert, que ce soit du fait d'une r√©v√©lation par erreur ou d'un _hacking_ de celui-ci par quelqu'un malveillant. L'utilisation de _token_ s√©curise √©norm√©ment votre d√©p√¥t puisqu'il ne peut pas √™tre supprim√© si le _token_ a des droits limit√©s. De plus, si la branche principale est prot√©g√©e, ce qui est le comportement par d√©faut de `Github`, il ne sera pas possible sans mot de passe de d√©truire l'historique du d√©p√¥t. 

Pour r√©sumer les √©tapes devraient √™tre les suivantes :

*Settings > Developers Settings > Personal Access Token > Generate a new token > "My bash script" > Expiration "30 days" > cocher juste "repo" > Generate token > Le copier*

__‚ö†Ô∏è Gardez la page ouverte__, le _token_ n'appara√Æt qu'une fois et nous n'avons pas encore fait l'effort de le stocker √† un endroit p√©renne. Cela sera l'objet du prochain exercice. 

:::

Nous avons cr√©√© un _token_ et comme cela est indiqu√© sur la page de `Github` ou dans les consignes de l'exercice, celui-ci n'est pas p√©renne. Il va donc falloir trouver un moyen de conserver celui-ci quelque part. Nous allons proposer plusieurs solutions pour cela. Ecrire celui-ci dans un fichier texte cr√©√© avec le bloc note ne fait pas parti de ces solutions, au contraire c'est une tr√®s mauvaise pratique. 

::: {.exercise}
## Exercice 3: stocker son jeton (pour les utilisateurs du `SSPCloud`)

Le `SSPCloud` propose un service de stockage d'un jeton qui peut ensuite servir facilement pour s'authentifier sur `Github` quand on utilise `VSCode` ou `Jupyter`. 

* Copier le jeton qui est affich√© sur la page de `Github` qui a √©t√© ouverte pr√©c√©demment. Ne faites pas la s√©lection des lettres √† la main, utilisez le bouton d√©di√© au copier-coller ({{< fa solid clipboard >}})
* Cliquer sur la section ["Mon Compte"](https://datalab.sspcloud.fr/account/) du `SSPCloud`. Aller dans l'onglet `Git` et coller la valeur pr√©c√©demment copi√©e. 

On peut s'arr√™ter √† ce stade, nous utiliserons ce jeton lors du prochain exercice. 

:::

::: {.exercise}
## Exercice 3bis: stocker son jeton (pour les personnes n'ayant pas l'acc√®s au `SSPCloud`)

La solution recommand√©e est de stocker son jeton dans un un gestionnaire de mot de passe comme 
[Keepass](https://keepass.fr/) (recommand√© par l'Anssi). Il s'agit d'un logiciel qui stocke, de mani√®re chiffr√©e, les mots de passe qui y sont conserv√©s selon la logique du coffre fort num√©rique. 

Au-del√† de l'int√©r√™t pour stocker un jeton Github pour ce cours, ces logiciels sont tr√®s pratiques au quotidien et s√©curisent l'acc√®s √† des services num√©riques sensibles. Ils comportent aussi des g√©n√©rateurs de mot de passe forts qui permettent de r√©duire les risques d'usurpation num√©rique en rendant quasi-impossible des techniques comme [l'attaque par force brute](https://fr.wikipedia.org/wiki/Attaque_par_force_brute).

:::

Maintenant que nous avons stock√© notre jeton dans un endroit s√©curis√©, nous pouvons passer √† l'√©tape suivante qui consiste √† r√©cup√©rer notre d√©p√¥t distant dans une copie de travail, op√©ration qui nous am√®nera √† r√©ellement utiliser le jeton que nous avons mis de c√¥t√© pour le moment. 


::: {.exercise}
## Exercice 4a: cr√©er un service et comprendre le principe du cl√¥ne et de l'authentification (utilisateurs du SSPCloud)

1. Sur le SSPCloud, se rendre dans la page [Mes Services](https://datalab.sspcloud.fr/my-services).

2. Cliquer sur `‚ûï‚Äã Nouveau service` et choisir un service `vscode-python` (ne pas en prendre un autre).

3. Laisser les param√®tres par d√©faut et lancer le service. 

4. Une fois le service pr√™t, cliquer sur le bouton "Cliquez pour copier le mot de passe du service". Cela va stocker le mot de passe du service (g√©n√©r√© al√©atoirement, celui-ci n'a rien √† voir avec votre mot de passe g√©n√©ral du `SSPCloud`) dans le presse papier. Ce mot de passe est √©galement visible en clair dans la partie qui est caviard√©e sur la @fig-readme-sspcloud. 

![](img/README.png){#fig-readme-sspcloud}

5. Coller ce mot de passe dans le champ `Password` qui s'affiche quand vous ouvrez le service. 

6. Dans un autre onglet, r√©cup√©rer, sur la page d'accueil de votre d√©p√¥t, l'url du d√©p√¥t distant qui est accessible en cliquant √† droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

7. Ouvrir le terminal (`‚ò∞ > Terminal > New Terminal`) et commencer √† taper 

```python
git clone # coller votre url de la forme https://github.com/<username>/<reponame>.git 
```

pour coller √† la suite votre URL, si <kbd>CTRL</kbd>+<kbd>V</kbd> est bloqu√© par le navigateur, vous pouvez faire <kbd>MAJ</kbd>+<kbd>Inser</kbd>. Taper <kbd>Entr√©e</kbd>.

8. Une page va s'ouvrir _"The extension 'GitHub' wants to sign in using GitHub"_. Refuser en cliquant sur _"Cancel"_ (les questions optionnelles montrent ce qu'il se passe quand vous acceptez, vous basculez sur un autre mode d'authentification).

9. Dans la fen√™tre en haut, taper votre username d'abord. Puis lorsqu'il vous demande votre mot de passe, **coller votre _token_, pas votre mot de passe `Github`** (si vous avez toujours la page `Github` ouverte, le copier de l√†, sinon en retournant sur la page [Mon compte](https://datalab.sspcloud.fr/account/git) du `SSPCloud`)

8. Observer la mise √† jour de l'explorateur de fichiers sur `VSCode`, votre `README` et votre `.gitignore` visibles sur `Github` doivent maintenant √™tre l√†. 

9. Taper `cd mon-petit-projet` en supposant que le dossier de votre d√©p√¥t s'appelle `mon-petit-projet`. Puis taper `git remote -v`, une commande qui demande √† `Git` de voir o√π pointe `origin`, votre d√©p√¥t distant. La r√©ponse devrait √™tre l'URL que vous avez renseign√© pr√©cedemment

Ceci √©tait une illustration n√©cessaire pour comprendre le principe de l'authentification. Le prochain exercice (4b) proposera une mani√®re plus directe de fonctionner, qu'il est utile de conna√Ætre car elle vous √©vitera d'avoir √† vous authentifier √† chaque interaction avec le d√©p√¥t distant. 

En option, pour comprendre la diff√©rence avec l'authentification d√©l√©gu√©e propos√©e par VSCode, vous pouvez faire, de mani√®re optionnelle, les consignes suivantes:

1. Toujours dans le m√™me VSCode, ouvrir un nouveau terminal (`‚ò∞ > Terminal > New Terminal`)

2. Taper `git clone https://github.com/<username>/<reponame>.git repo-bis` en rempla√ßant `https://github.com/<username>/<reponame>.git` par l'URL de votre d√©p√¥t. Cela cl√¥nera votre d√©p√¥t dans le dossier `repo-bis` quand vous serez effectivement authentifi√©.

3. Cette fois accepter l'authentification d√©l√©gu√©e propos√©e par VSCode. Il s'agit d'une authentification √† deux facteurs:
    * Le premier facteur d'authentification est le code que `Github` vous demande de copier et de renseigner dans la page que `VSCode` d√©sire ouvrir (il faut que vous acceptiez de copier et d'ouvrir la page). Coller ce code √† 8 caract√®res, valider et accepter les droits demand√©s par l'application. 
    * Le deuxi√®me facteur est le code de votre application d'authentification (par exemple `Google Authenticator` ou celui que vous recevez par SMS). Mettre celui-ci et valider, le cl√¥ne devrait d√©marrer

:::

Cet exercice vient de nous illustrer le principe de l'authentification et la mani√®re dont `VSCode` peut attester de votre identit√© gr√¢ce √† un _token_ ou √† une double authentification. L'exercice suivant propose une m√©thode d'authentification par token un peu plus pratique que celle que nous avions mise en oeuvre ‚òùÔ∏è. 


::: {.exercise}
## Exercice 4b: cr√©er un service et comprendre le principe du cl√¥ne et de l'authentification (utilisateurs du SSPCloud)

Cette approche montre comment le SSPCloud injecte lors de la cr√©ation d'un service VSCode le _token_ et le d√©p√¥t que vous d√©sirez cl√¥ner. 


1. Sur le SSPCloud, se rendre dans la page [Mes Services](https://datalab.sspcloud.fr/my-services). Vous pouvez supprimer le service existant, il n'est plus n√©cessaire.

2. Cliquer sur `‚ûï‚Äã Nouveau service` et choisir un service `vscode-python` (ne pas en prendre un autre).

3. Dans un autre onglet, r√©cup√©rer, sur la page d'accueil de votre d√©p√¥t, l'url du d√©p√¥t distant qui est accessible en cliquant √† droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`


* D√©rouler le menu `Configuration Vscode-python` et chercher l'onglet `Git`

* Dans celui-ci, vous devriez voir votre _token_ pr√©-inject√© dans le formulaire. Ne le changez pas. 

* Dans un autre onglet, r√©cup√©rer, sur la page d'accueil de votre d√©p√¥t, l'url du d√©p√¥t distant qui est accessible en cliquant √† droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

Vous pouvez utiliser l'icone √† droite {{< fa brands clipboard >}} pour copier l'url.

* Coller celle-ci dans le champ `Repository` du formulaire de cr√©ation du service sur le `SSPCloud`.  Lancer le service et attendre qu'il se cr√©e (une vingtaine de secondes).

* Le cl√¥ne du d√©p√¥t distant devrait √™tre visible dans l'aborescence des fichiers. 

* Ouvrir le terminal (`‚ò∞ > Terminal > New Terminal`) et taper `git remote -v`, une commande qui demande √† `Git` de voir o√π pointe `origin`, votre d√©p√¥t distant. La r√©ponse prend la forme:

```python
https://ghp_XXXX@github.com/username/repository.git
```

qui se distingue de l'URL que vous aviez renseign√© dans l'onglet `Git`. 
Comme vous pouvez le voir avec cette m√©thode, le jeton est en clair. C'est pour cette raison qu'on utilise, plut√¥t que des mots de passe, des jetons
puisque, si ces derniers sont r√©v√©l√©s, on peut toujours les r√©voquer et √©viter
les probl√®mes

:::


::: {.exercise collapse="true"}
## Exercice 4 alternatif: quand on ne dispose pas de compte sur le `SSPCloud`

Le mode op√©ratoire est tr√®s proche. En pratique, la seule diff√©rence est qu'il n'y a pas besoin de cr√©er de nouveau service puisqu'une installation de `VSCode` existe d√©j√†. 

1. Sur votre navigateur, r√©cup√©rer, sur la page d'accueil de votre d√©p√¥t, l'url du d√©p√¥t distant qui est accessible en cliquant √† droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

7. Ouvrir le terminal (`Terminal > New Terminal`) et commencer √† taper 

```
git clone
```

et coller la valeur copi√©e pr√©c√©demment. Ne validez pas. Avec les touches directionnelles, se placer entre `https://` et `github.com`. R√©cup√©rer dans votre navigateur ou Keepass votre jeton Github. Coller celui-ci puis ajouter `@`. Cela devrait donner 

```python
https://ghp_XXXX@github.com/username/repository.git
```

Ce qui, dans l'ensemble, fera

```python
git clone https://ghp_XXXX@github.com/username/repository.git
```

* Le cl√¥ne du d√©p√¥t distant devrait √™tre visible dans l'aborescence des fichiers. 

Comme vous pouvez le voir avec cette m√©thode, le jeton est en clair. C'est pour cette raison qu'on utilise, plut√¥t que des mots de passe, des jetons
puisque, si ces derniers sont r√©v√©l√©s, on peut toujours les r√©voquer et √©viter
les probl√®mes

:::



## La _staging area_

Dans un monde sans `Git`, on √©crit du code, on sauvegarde son script et parfois on consid√®re que cette version vaut le coup d'√™tre consid√©r√©e comme une version de laquelle repartir. Avec `Git` c'est la m√™me chose, seulement se principe sera formalis√© plus proprement. 

Le premier niveau conceptuel est celui de l'index des modifications. Il s'agit des modifications en attente de validation, d'o√π le nom de _staging area_ dans la premi√®re partie de @fig-staging-area. 

![La gymnastique de `Git` dans son ensemble](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/completeworkflow.png){#fig-staging-area}

En principe, quand on √©dite des scripts ou _notebooks_, on enregistre r√©guli√®rement ceux-ci. Le niveau d'implication suivant est de mettre de c√¥t√© une version particuli√®re de ceux-ci, ce qu'√† la main (voir la @version-control-inferno), nous ferions en dupliquant le fichier. Cela implique de mettre une ou plusieurs modifications dans la liste d'attente des modifications √† valider. Cette op√©ration s'appelle `git add` et est l'objet du prochain exercice. 


::: {.exercise}
## Exercice 5 : Indexer des modifications

1. Cr√©er un dossier üìÅ `scripts` dans le dossier de votre d√©p√¥t. Sur `VSCode`, vous pouvez utiliser les ic√¥nes adapt√©es. 
2. Y cr√©er les fichiers `script1.py` et `script2.py`, chacun contenant quelques commandes `Python` de votre choix (le contenu de ces fichiers n'est pas important).

3. Se rendre dans l'extension `Git` de `VSCode`. Vous devriez
retrouver un cadre ayant cet aspect 

::: {#fig-status layout-ncol=2}

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git_vscode_1.png)

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git-status-ensae.png)


Interface graphique Git sous VSCode (√† gauche) et Jupyter (√† droite)
:::

En ligne de commande, c'est l'√©quivalent de 

```shell
git status
```

2. Sur `VSCode`, un bouton `+` figure √† droite du nom
du fichier `.script1.py` et
`.script2.py`. Sur `Jupyter`, en passant votre souris au dessus du nom des fichiers `script1.py` et
`script2.py`, vous devriez voir
un `+` appara√Ætre. Cliquez dessus. 

Si vous aviez privil√©gi√© la ligne de commande, ce que vous avez fait est √©quivalent √† :

~~~shell
git add scripts/script1.py
git add scripts/script2.py
~~~

3. Observer le changement de statut du fichier apr√®s avoir cliqu√© sur `+`. Il est
d√©sormais dans la partie `Staged`
En gros, vous venez de dire √† `Git` que vous allez rendre publique une √©volution
du fichier, mais vous ne l'avez pas encore fait (`Staged` est une liste d'attente).

Si vous √©tiez en ligne de commande vous auriez ce r√©sultat apr√®s un `git status`

```raw
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   .gitignore
```


Les nouvelles modifications (en
l'occurrence la cr√©ation du fichier et la validation de son contenu actuel)
ne sont pas encore archiv√©es. Pour cela, il va falloir faire un 
`commit` (on rend publique une modification)

4. Avant cela, regardons les modifications qu'on va prochainement
valider. Pour cela, passez la souris au dessus du nom du fichier
`.gitignore` et cliquer sur le bouton `Diff this file` (+ -).
Une page s'ouvre et met en regard la version ant√©rieure avec
les ajouts en vert et les suppressions en rouge. Nous retrouverons
cette visualisation avec l'interface `Github`, plus tard. 

En l'occurrence, comme le fichier n'existait pas, normalement nous n'avons que
des ajouts.

Il est √©galement possible d'effectuer cela avec la ligne de commande mais c'est
beaucoup moins pratique. Pour cela, la commande √† appeler est `git diff` et
il est n√©cessaire d'utiliser l'option `cached` pour lui dire d'inspecter les
fichiers pour lesquels on n'a pas encore effectu√© de `commit`. En vert
appara√Ætront les modifications et en rouge les suppressions mais, cette fois,
les r√©sultats ne seront pas mis c√¥te-√†-c√¥te ce qui est beaucoup moins
pratique.

```shell
git diff --cached
```

:::


OLD


## D√©p√¥t local et distant

Pour comprendre le principe de `Git`, il est utile de distinguer
deux niveaux: le d√©p√¥t 

`Git` est un syst√®me d√©centralis√© et asynchrone de gestion de version. 
Cela signifie que:

* Chaque membre d'un projet travaille sur une copie locale du d√©p√¥t
(syst√®me *decentralis√©*). Cette copie de travail s'appelle un `clone`.
Cela signifie qu'on n'a pas une coh√©rence en continu de notre version
de travail avec le d√©p√¥t ; on peut tr√®s bien ne jamais vouloir les
mettre en coh√©rence (par exemple, si on teste une piste qui s'av√®re
infructueuse) ;
* C'est lorsqu'on propose la publication de modifications sur le d√©p√¥t
collectif qu'on doit s'assurer de la coh√©rence avec la version disponible
en ligne (syst√®me *asynchrone*).

Le d√©p√¥t distant est g√©n√©ralement stock√© sur
une **forge  logicielle** (`Github` ou `Gitlab`) et sert √† centraliser la version
collective d'un projet. Les copies locales sont des copies de travail
qu'on utilise pour faire √©voluer un projet :


Il est tout √† fait possible de faire du contr√¥le de version sans
mettre en place de d√©p√¥t distant. Cependant, 

* c'est dangereux puisque le d√©p√¥t distant fait office de sauvegarde 
d'un projet. Sans d√©p√¥t distant, on peut tout perdre en cas de probl√®me
sur la copie locale de travail ;
* c'est d√©sirer √™tre moins efficace car, comme nous allons le montrer, les
fonctionalit√©s des plateformes `Github` et `Gitlab` sont √©galement tr√®s 
b√©n√©fiques lorsqu'on travaille tout seul. 

## Principe


Les trois manipulations les plus courantes sont les suivantes et repr√©sent√©es sur le diagramme ci-apr√®s :

* `commit` : je valide les modifications que j'ai faites en local avec un message qui les explique
* `pull` : je r√©cup√®re la derni√®re version des codes du d√©p√¥t distant
* `push` : je transmets mes modifications valid√©es au d√©p√¥t distant

![](https://gitlab.com/linogaliana/collaboratif/-/raw/main/pics/03_git/push_pull_Drees.png)

Les deux derni√®res manipulations correspondent aux interactions (notamment
la mise en coh√©rence) avec
le d√©p√¥t commun alors que la premi√®re manipulation `commit` correspond √†
la modification des fichiers faite pour faire √©voluer un projet. 

De mani√®re plus pr√©cise, il y a trois √©tapes avant d'envoyer les modifications valid√©es (`commit`) au d√©p√¥t. Elles se d√©finissent en fonction des commandes qui permettent de les appliquer quand Git est utilis√© en lignes de commandes :

* `diff` : inspection des modifications. Cela permet de comparer les fichiers modifi√©s et de distinguer les fichiers ajout√©s ou supprim√©s.
* `staging area` : s√©lection des modifications.
* `commit` : validation des modifications s√©lectionn√©es (avec commentaire).

![](https://gitlab.com/linogaliana/collaboratif/-/raw/main/pics/03_git/trois_%C3%A9tats_fichier.png)


Lors des √©tapes de `push` et `pull`, des **conflits** peuvent appara√Ætre, par exemple lorsque deux personnes ont modifi√© le m√™me programme simultan√©ment. Le terme conflit peut faire peur mais en fait c'est 
l'un des apports principaux de `Git` que de faciliter √©norm√©ment la gestion
de versions diff√©rentes. Les exercices du chapitre suivant l'illustreront.  

## Les branches


C'est une des fonctionnalit√©s les plus pratiques de la gestion de version. 
La cr√©ation de `branches` dans un projet (qui devient ainsi un arbre)
permet de d√©velopper en parall√®le des correctifs ou une nouvelle fonctionnalit√©
sans modifier le d√©p√¥t commun.

Cela permet de s√©parer le nouveau d√©veloppement et de faire cohabiter plusieurs versions, pouvant √©voluer s√©par√©ment ou pouvant √™tre facilement rassembl√©es. Git est optimis√© pour le travail sur les branches.

Dans un projet collaboratif, une branche dite **master** joue le r√¥le du tronc.
C'est autour d'elle que vont pousser ou se greffer les branches.
L'un des avantages de `Git` est qu'on peut toujours revenir en arri√®re. Ce
filet de s√©curit√© permet d'oser des exp√©rimentations, y compris au sein
d'une branche. Il faut √™tre pr√™t √† aller dans la ligne de commande pour cela
mais c'est extr√™mement confortable. 

::: {.cell .markdown}
```{=html}
<div class="alert alert-info" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-comment"></i> Note</h3>
```

Comment nommer les branches ? L√† encore, il y a √©norm√©ment de conventions diff√©rentes. Une fr√©quemment observ√©e est :

- pour les nouvelles fonctionnalit√©s : `feature/nouvelle-fonctionnalite` o√π `nouvelle-fontionnalite` est un nom court r√©sumant la fonctionnalit√©
- pour les corrections de bug : `issue-num` o√π `num` est le num√©ro de l'issue

N'h√©sitez pas √† aller encore plus loin dans la normalisation  !

```{=html}
</div>
```
:::



# Conseil de praticien : ne pas n√©gliger le `.gitignore`

Un fichier √† ne pas n√©gliger est le `.gitignore`. Il s'agit d'un garde-fou car tous les fichiers (notamment des
donn√©es, potentiellement volumineuses ou confidentielles) n'ont pas vocation
√† √™tre partag√©s.

Le site [gitignore.io](https://www.toptal.com/developers/gitignore) est tr√®s pratique. Le fichier
suivant est par exemple propos√© pour les utilisateurs de `Python`, auquel on peut ajouter
quelques lignes adapt√©es aux utilisateurs de donn√©es :

<details>
<summary>

Exemple de `.gitignore` pour les utilisateurs de donn√©es

</summary>

```markdown
"""
~~~raw
*.html
*.pdf
*.csv
*.tsv
*.json
*.xml
*.shp
*.xls
*.xlsx

### Python ###
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a Python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/
~~~
"""
)
```

</details>