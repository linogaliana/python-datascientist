---
title: "D√©couvrir Git par la pratique: la gymnastique quotidienne"
categories:
  - Tutoriel
  - Git
description: |
  `Git` est un syst√®me de contr√¥le de version qui facilite la
  sauvegarde, la gestion des √©volutions et le partage
  d'un projet informatique. Il s'agit d'un √©l√©ment devenu
  indispensable dans le domaine de la _data science_.
  Ce chapitre pr√©sente quelques concepts qui seront 
  mis en pratique dans le suivant. 
image: https://ensae-reproductibilite.github.io/website/snakedolls.jpg
echo: false
bibliography: ../../reference.bib
---

Le [chapitre d'introduction](/content/git/index.qmd) de la partie a √©voqu√© les enjeux, pr√©sent√©s de mani√®re synth√©tique
dans un [cours d√©di√© fait avec Romain Avouac](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html)

<details>

<summary>
D√©rouler les _slides_ ci-dessous ou [cliquer ici](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html#/partie-1-contr%C3%B4le-de-version-avec-git) pour afficher les slides en plein √©cran.
</summary>

```{=html}
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><iframe class="sourceCode yaml code-with-copy" src="https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html#/partie-1-contr%C3%B4le-de-version-avec-git"></iframe></div>
```

</details>


Ce chapitre va √™tre l'occasion de faire ses premiers pas avec `Git`. Le prochain chapitre sera consacr√© au travail collaboratif. Ce chapitre propose, pour simplifier l'apprentissage, d'utiliser l'extension `Git` de `VSCode` ou de `JupyterLab`. `VSCode` propose
probablement, √† l'heure actuelle, l'extension la plus compl√®te. Certains passages de ce TD n√©cessitent d'utiliser la ligne de commande.

Il est tout √† fait possible de r√©aliser ce TD enti√®rement avec la ligne de commande.
Cependant, pour une personne d√©butante en `Git`, l'utilisation d'une 
interface graphique peut constituer un √©l√©ment important pour
la compr√©hension et l'adoption de `Git`. Une fois √† l'aise avec
`Git`, on peut tout √† fait se passer des interfaces graphiques
pour les routines quotidiennes et ne les utiliser que
pour certaines op√©rations o√π elles s'av√®rent fort pratiques
(notamment la comparaison de deux fichiers avant de devoir fusionner).


Pour comprendre les analogies avec le versionnage artisanal √† la main, rappelons nous le principe de celui-ci avec la @fig-version-control-inferno

![Le contr√¥le de version artisanal](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/fichiers_multiples.png){#fig-version-control-inferno}


::: {.important}
Il est vivement recommand√© de privil√©gier `VSCode` pour l'apprentissage de `Git`. Son extension est tr√®s bien faite, bien meilleure que celle de `Jupyter`. 

`Colab` n'embarque pas, nativement, d'extension `Git`. Des sauvegardes automatiques sont possibles sur `Github` mais ce n'est pas une pratique √† encourager. Pire encore, `Colab` proposera plut√¥t une int√©gration avec `Drive`, un autre produit `Google`. Certes le _notebook_ sera versionn√© puisque `Drive` embarque des sauvegardes de version mais ce n'est pas une technologie faite pour les sauvegardes de code ; elle n'apportera pas les b√©n√©fices de `Git` qui seront √©voqu√©s ult√©rieurement.

Les √©l√®ves de l'ENSAE, et plus globalement l'ensemble des personnes pouvant b√©n√©ficier de l'infrastructure du SSPCloud[^eligibilite],
ont √† disposition des environnements de d√©veloppement `Python` avec `Git` pr√©install√© et accessible par l'interm√©diaire d'interfaces connect√©es aux IDE. Ce _notebook_ est lan√ßable sur cette infrastructure par le biais de ces boutons

[^eligibilite]: Pour savoir si vous √™tes √©ligibles au SSPCloud, vous pouvez cliquer sur [ce lien](https://auth.lab.sspcloud.fr/auth/realms/sspcloud/login-actions/authenticate?client_id=onyxia) et consulter la liste des domaines autoris√©s. 

Si vous n'√™tes pas √©ligibles au `SSPCloud`, le chemin pour obtenir un environnement pr√™t √† l'emploi pour `Git` et `Python` est plus tortueux. Il est recommand√© de t√©l√©charger et installer [`VSCode`](https://code.visualstudio.com/), d'ajouter _a minima_ les [extensions `Python`](https://code.visualstudio.com/docs/languages/python) et [`GitLens`](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens). Il est bien s√ªr possible d'aller plus loin dans la customisation de l'environnement de d√©veloppement mais ce sont les briques minimales pour avoir un environnement local fonctionnel et ergonomique. 

:::

# Avant de d√©marrer: cr√©er un compte `Github` et cr√©er une copie de travail

La premi√®re √©tape se fait sur [`Github`](https://github.com). et consiste √† se cr√©er un compte sur cette plateforme.

::: {.exercise}
## Exercice 1 : Cr√©er un compte `Github`

_Il est important de suivre pas √† pas les consignes, chaque √©tape est importante_

1. Si vous n'en avez pas d√©j√† un, cr√©er un compte sur [github.com](https://github.com)
2. Cr√©er un d√©p√¥t en suivant les consignes ci-dessous.
  + __Cr√©er ce d√©p√¥t priv√©__, cela permettra
dans l'exercice 2 d'activer notre jeton. Vous pourrez le rendre public
apr√®s l'exercice 2, c'est comme vous le souhaitez.
  + __Cr√©er ce d√©p√¥t avec un `README.md`__ en cliquant sur la case `Add a README file`
* Ajouter un `.gitignore` en s√©lectionnant le mod√®le `Python`

*Connexion sur <a href="https://github.com">https://github.com</a> > + (en haut de la page) > New repository > Renseigner le "Repository name" > Cocher "private" > "Create repository"*
[üëâÔ∏è __D√©p√¥t__: arborescence de fichiers dont on veut conserver l'historique dans une place commune.]{.aside}

:::

# Quelques bases sur `Git`

## Version distante, version locale

Nous avons, avec l'exercice pr√©c√©dent, cr√©√© un premier d√©p√¥t. Il s'agit d'un d√©p√¥t centralis√© qui va servir de source de v√©rit√© pour notre projet et par l'interm√©diaire duquel interagissent les contributeurs.trices d'un projet. Mais nous n'avons pas parl√© de comment le faire √©voluer, pour cela il faut cr√©er des copies de travail. 

`Git` est un syst√®me d√©centralis√© de contr√¥le de version[^asynchrone]. Cela signifie que les contributeurs.trices modifient les fichiers dans leur √©diteur de pr√©dilection puis soumettent ceux-ci pour mettre √† jour la source de v√©rit√©, le d√©p√¥t distant.
[üëâÔ∏è __Contr√¥le de version__: pratique consistant √† suivre et √† g√©rer les changements apport√©s √† un projet informatique.]{.aside}

![Le principe d√©centralis√© de `Git`](img/gitremote.png){#fig-local-remote}

Nous reviendrons plus pr√©cis√©ment sur #fig-local-remote par la suite et notamment les nombreux termes techniques indiqu√©s dessus. Mais la compr√©hension de cette distinction fondamentale entre d√©p√¥t distant et d√©p√¥t local √©tait importante pour pouvoir d√©marrer. On appelle __forge__ une plateforme qui stocke des d√©p√¥ts distants. Dans ce cours, nous allons pr√©senter `Github` mais il en existe d'autres, notamment `Gitlab`.
[üëâÔ∏è __Forge__: syst√®me de gestion collaborative de textes ou de codes. `Github` et `Gitlab` sont les deux forges les plus connues mais il en existe de nombreuses autres.]{.aside}

Nous avons cr√©√© notre d√©p√¥t distant √† l'exercice principal. Comme cr√©er une version de travail ? Cette op√©ration s'appelle faire un cl√¥ne (`git clone`). L'objectif du prochain exercice est de faire cette op√©ration, ce qui n√©cessite n√©anmoins la compr√©hension du concept d'authentification avant de pouvoir commencer celui-ci. 
[üëâÔ∏è `clone`: r√©cup√©ration d'un d√©p√¥t distant et de son historique en cr√©ant une copie locale]{.aside}

[^asynchrone]: Plus pr√©cis√©ment, `Git` est un syst√®me d√©centralis√© et asynchrone de contr√¥le de version. Cela signifie qu'outre le fait qu'on √©dite ses fichiers sur des copies locales, on n'a pas besoin d'√™tre connect√© en continu au d√©p√¥t distant. On peut faire les modifications et les soumettre plus tard. 

Bien qu'il soit possible d'avoir une utilisation hors-ligne de `Git`, 
c'est-√†-dire un pur contr√¥le de version local sans d√©p√¥t
distant, cela est une utilisation
rare et qui comporte un int√©r√™t limit√©. L'int√©r√™t de `Git` est
d'offrir une mani√®re robuste et efficace d'interagir avec un 
d√©p√¥t distant facilitant ainsi la collaboration en √©quipe ou en
solitaire. 

::: {.callout-tip}
## Pourquoi `Github` ?

Pour ces exercices, il est propos√©
d'utiliser `Github`, la forge la plus visible[^1]. 
L'avantage de `Github` par rapport √† son principal concurrent, `Gitlab`,
est que le premier est plus visible, car
mieux index√© par `Google` et concentre, en partie pour des raisons historiques, plus
de d√©veloppeurs `Python` et `R` (ce qui est important dans des domaines comme
le code o√π les externalit√©s de r√©seau jouent). 

Etre familiaris√© √† 
l'environnement `Gitlab` reste utile car beaucoup de forges logicielles
internes reposent sur les fonctionalit√©s _open-source_ (l'interface graphique
en faisant parti) de `Gitlab`. Il est donc fort utile de ma√Ætriser 
les fonctionalit√©s coeur de ces deux interfaces qui sont en fait quasi-identiques. Cela tombe bien, c'est l'objet de ce chapitre et du suivant.

:::


### S'authentifier √† `Github` avec un jeton: principe
[üëâÔ∏è __Authentification__: processus permettant √† un syst√®me informatique de s'assurer de l'identit√© d√©sirant effectuer une action.]{.aside}

`Git` est un syst√®me d√©centralis√© de contr√¥le de version :
les codes sont modifi√©s par chaque personne sur son poste de travail,
puis sont mis en conformit√© avec la version collective disponible
sur le d√©p√¥t distant au moment o√π le contributeur le d√©cide.

Il est donc n√©cessaire que la forge connaisse l‚Äôidentit√© de chacun des
contributeurs, afin de d√©terminer qui est l‚Äôauteur d‚Äôune modification apport√©e
aux codes stock√©s dans le d√©p√¥t distant.
Pour que `Github` reconnaisse un utilisateur proposant des modifications,
il est n√©cessaire de s‚Äôauthentifier (un d√©p√¥t distant, m√™me public, ne peut pas √™tre modifi√© par n‚Äôimporte qui). L‚Äôauthentification consiste ainsi √† fournir un √©l√©ment que seul vous et la forge √™tes cens√©s conna√Ætre : un mot de passe, une cl√© compliqu√©e, un jeton d‚Äôacc√®s...

Plus pr√©cis√©ment, il existe deux modalit√©s pour faire conna√Ætre son identit√© √† `Github` :

* une __authentification HTTPS__ (d√©crite ici) : l‚Äôauthentification se fait avec un login et un mot de passe ou avec un _token_ (un mot de passe compliqu√© g√©n√©r√© automatiquement par `Github` et connu exclusivement du d√©tenteur du compte `Github`)  ;
* une __authentification SSH__ : l‚Äôauthentification se fait par une cl√© crypt√©e disponible sur le poste de travail et que `GitHub` ou `GitLab` conna√Æt. Une fois configur√©e, cette m√©thode ne n√©cessite plus de faire conna√Ætre son identit√© : l‚Äôempreinte digitale que constitue la cl√© suffit √† reconna√Ætre un utilisateur. Ce n'est pas la m√©thode que nous appliquerons ici[^ssh-utilitr].

[^ssh-utilitr]: La [documentation collaborative `utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_configurer_git.html#interaction-avec-un-d%C3%A9p%C3%B4t-distant-principe) pr√©sente les raisons pour lesquelles il convient de favoriser
la m√©thode HTTPS sur la m√©thode SSH. 

::: {.note}
## Note sur la double authentification
[üëâÔ∏è __Double authentification__ ou __authentification √† deux facteurs__ (2FA): pratique de s√©curit√© consistant √† autoriser une authentification seulement apr√®s avoir pr√©sent√© deux preuves d'identit√© distinctes √† un m√©canisme d'authentification. Par exemple, sur une application bancaire, fournir un num√©ro client et un code envoy√© par SMS]{.aside}


Depuis Ao√ªt 2021, `Github` n'autorise plus l'authentification par mot de passe
lorsqu'on interagit (`pull`/`push`) avec un d√©p√¥t distant
([raisons ici](https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/)).
Il est n√©cessaire d'utiliser un *token* (jeton d'acc√®s) qui pr√©sente l'avantage
d'√™tre r√©voquable (on peut √† tout moment supprimer un jeton si, par exemple,
on suspecte qu'il a √©t√© diffus√© par erreur) et √† droits limit√©s 
(le jeton permet certaines op√©rations standards mais
n'autorise pas certaines op√©rations d√©terminantes comme la suppression
d'un d√©p√¥t).

GitHub commencera progressivement √† exiger que tous les utilisateurs de GitHub activent une ou plusieurs formes d'authentification √† deux facteurs (2FA). Pour plus d‚Äôinformations sur le d√©ploiement de l‚Äôinscription 2FA, consultez [cet article de blog](https://github.blog/2023-03-09-raising-the-bar-for-software-security-github-2fa-begins-march-13/). Concr√®tement, cela signifie que vous devrez au choix :

- Renseigner votre num√©ro de portable pour valider certaines connexions gr√¢ce √† un code que vous recevrez par sms ;
- Installer une application d'authentification (Ex : Microsoft Authenticator) install√©e sur votre t√©l√©phone qui g√©n√®rera un QR code que vous pourrez scanner depuis github, ce qui ne n√©cessite pas que vous ayez √† fournir votre num√©ro de t√©l√©phone
- Utiliser une clef USB de s√©curit√© 

Pour choisir entre ces diff√©rentes options, vous pouvez vous rendre sur *Settings > Password and authentication > Enable two-factor authentication*.

:::

### Cr√©er un jeton
[üëâÔ∏è __L‚Äôauthentification par jeton__ (_token authentication_) est une forme d‚Äôauthentification qui permet √† un utilisateur d‚Äôacc√©der √† un service en ligne, une application, ou un site web sans qu‚Äôil n‚Äôait √† ressaisir ses identifiants. Les jetons d‚Äôauthentification fonctionnent √† la mani√®re d‚Äôun ticket d‚Äôentr√©e √† validit√© limit√©e : ils accordent un acc√®s en continu pendant leur dur√©e de validit√©. D√®s que l‚Äôutilisateur se d√©connecte ou quitte l‚Äôapplication, le jeton est invalid√©.]{.aside}


La [documentation officielle](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) comporte un certain nombre de captures d'√©cran expliquant
comment proc√©der. En gardant cette documentation ouverte en cas de doute, et les instructions du prochain exercice, nous allons pouvoir cr√©er un jeton d'authentification. 

::: {.exercise}
## Exercice 2 : Cr√©er un _token_

Suivre la
[documentation officielle](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) en ne donnant que les droits `repo` au jeton[^droits].

[^droits]: Comme vous pouvez le voir, il y a de nombreux niveaux de droits diff√©rents. Votre mot de passe a en fait tout ces droits, ce qui illustre bien le pouvoir dangereux de celui-ci s'il est d√©couvert, que ce soit du fait d'une r√©v√©lation par erreur ou d'un _hacking_ de celui-ci par quelqu'un malveillant. L'utilisation de _token_ s√©curise √©norm√©ment votre d√©p√¥t puisqu'il ne peut pas √™tre supprim√© si le _token_ a des droits limit√©s. De plus, si la branche principale est prot√©g√©e, ce qui est le comportement par d√©faut de `Github`, il ne sera pas possible sans mot de passe de d√©truire l'historique du d√©p√¥t. 

Pour r√©sumer les √©tapes devraient √™tre les suivantes :

*Settings (account) > Developers Settings > Personal Access Token > Tokens (classic) > Generate a new token (classic) > "MyToken" > Expiration "90 days" > cocher juste "repo" > Generate token > Le copier*

__‚ö†Ô∏è Gardez la page ouverte__, le _token_ n'appara√Æt qu'une fois et nous n'avons pas encore fait l'effort de le stocker √† un endroit p√©renne. Cela sera l'objet du prochain exercice. N√©anmoins pas d'inqui√©tude si vous avez perdu le _token_ avant de pouvoir le sauvegarder, vous pouvez en reg√©n√©rer un nouveau en suivant √† nouveau la proc√©dure ci-dessus.

:::

Nous avons cr√©√© un _token_ et comme cela est indiqu√© sur la page de `Github` ou dans les consignes de l'exercice, celui-ci n'est pas p√©renne. Il va donc falloir trouver un moyen de conserver celui-ci quelque part. Nous allons proposer plusieurs solutions pour cela. Ecrire celui-ci dans un fichier texte cr√©√© avec le bloc note ne fait pas parti de ces solutions, au contraire c'est une tr√®s mauvaise pratique. 

::: {.important}

Il est important de ne jamais stocker un _token_, et encore moins son mot de passe, dans un projet.
Il est possible de stocker un mot de passe ou *token* de mani√®re s√©curis√©e et durable
avec le *credential helper* de `Git`. Celui-ci est pr√©sent√© par la suite.

S'il n'est pas possible d'utiliser le *credential helper* de `Git`, un mot de passe 
ou _token_ peut √™tre stock√© de mani√®re s√©curis√© dans
un syst√®me de gestion de mot de passe comme [Keepass](https://keepass.fr/).

Ne jamais stocker un jeton `Github`, ou pire un mot de passe, dans un fichier
texte non crypt√©. Les logiciels de gestion de mot de passe
(comme [Keepass](https://keepass.fr/), recommand√© par l'Anssi)
sont simples
d'usage et permettent de ne conserver sur l'ordinateur qu'une version
hash√©e du mot de passe qui ne peut √™tre d√©crypt√©e qu'avec un mot de passe
connu de vous seuls. 

:::



::: {.exercise}
## Exercice 3: stocker son jeton (pour les utilisateurs du `SSPCloud`)

Le `SSPCloud` propose un service de stockage d'un jeton qui peut ensuite servir facilement pour s'authentifier sur `Github` quand on utilise `VSCode` ou `Jupyter`. 

* Copier le jeton qui est affich√© sur la page de `Github` qui a √©t√© ouverte pr√©c√©demment. Ne faites pas la s√©lection des lettres √† la main, utilisez le bouton d√©di√© au copier-coller ({{< fa solid clipboard >}})
* Cliquer sur la section ["Mon Compte"](https://datalab.sspcloud.fr/account/) du `SSPCloud`. Aller dans l'onglet `Git` et coller la valeur pr√©c√©demment copi√©e. 

On peut s'arr√™ter √† ce stade, nous utiliserons ce jeton lors du prochain exercice. 

:::

::: {.exercise}
## Exercice 3bis: stocker son jeton (pour les personnes n'ayant pas l'acc√®s au `SSPCloud`)

La solution recommand√©e est de stocker son jeton dans un un gestionnaire de mot de passe comme 
[Keepass](https://keepass.fr/) (recommand√© par l'Anssi). Il s'agit d'un logiciel qui stocke, de mani√®re chiffr√©e, les mots de passe qui y sont conserv√©s selon la logique du coffre fort num√©rique. 

Au-del√† de l'int√©r√™t pour stocker un jeton Github pour ce cours, ces logiciels sont tr√®s pratiques au quotidien et s√©curisent l'acc√®s √† des services num√©riques sensibles. Ils comportent aussi des g√©n√©rateurs de mot de passe forts qui permettent de r√©duire les risques d'usurpation num√©rique en rendant quasi-impossible des techniques comme [l'attaque par force brute](https://fr.wikipedia.org/wiki/Attaque_par_force_brute).

:::

Maintenant que nous avons stock√© notre jeton dans un endroit s√©curis√©, nous pouvons passer √† l'√©tape suivante qui consiste √† r√©cup√©rer notre d√©p√¥t distant dans une copie de travail, op√©ration qui nous am√®nera √† r√©ellement utiliser le jeton que nous avons mis de c√¥t√© pour le moment. 


::: {.exercise}
## Exercice 4a: cr√©er un service et comprendre le principe du cl√¥ne et de l'authentification (utilisateurs du SSPCloud)

1. Sur le SSPCloud, se rendre dans la page [Mes Services](https://datalab.sspcloud.fr/my-services).

2. Cliquer sur `‚ûï‚Äã Nouveau service` et choisir un service `vscode-python` (ne pas en prendre un autre).

3. Laisser les param√®tres par d√©faut et lancer le service. 

4. Une fois le service pr√™t, cliquer sur le bouton "Cliquez pour copier le mot de passe du service". Cela va stocker le mot de passe du service (g√©n√©r√© al√©atoirement, celui-ci n'a rien √† voir avec votre mot de passe g√©n√©ral du `SSPCloud`) dans le presse papier. Ce mot de passe est √©galement visible en clair dans la partie qui est caviard√©e sur la @fig-readme-sspcloud. 

![](img/README.png){#fig-readme-sspcloud}

5. Coller ce mot de passe dans le champ `Password` qui s'affiche quand vous ouvrez le service. 

6. Dans un autre onglet, r√©cup√©rer, sur la page d'accueil de votre d√©p√¥t, l'url du d√©p√¥t distant qui est accessible en cliquant √† droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

7. Ouvrir le terminal (`‚ò∞ > Terminal > New Terminal`) et commencer √† taper 

```python
git clone # coller votre url de la forme https://github.com/<username>/<reponame>.git 
```

pour coller √† la suite votre URL, si <kbd>CTRL</kbd>+<kbd>V</kbd> est bloqu√© par le navigateur, vous pouvez faire <kbd>MAJ</kbd>+<kbd>Inser</kbd>. Taper <kbd>Entr√©e</kbd>.

8. Une page va s'ouvrir _"The extension 'GitHub' wants to sign in using GitHub"_. Refuser en cliquant sur _"Cancel"_ (les questions optionnelles montrent ce qu'il se passe quand vous acceptez, vous basculez sur un autre mode d'authentification).

9. Dans la fen√™tre en haut, taper votre username d'abord. Puis lorsqu'il vous demande votre mot de passe, **coller votre _token_, pas votre mot de passe `Github`** (si vous avez toujours la page `Github` ouverte, le copier de l√†, sinon en retournant sur la page [Mon compte](https://datalab.sspcloud.fr/account/git) du `SSPCloud`)

8. Observer la mise √† jour de l'explorateur de fichiers sur `VSCode`, votre `README` et votre `.gitignore` visibles sur `Github` doivent maintenant √™tre l√†. 

9. Taper `cd mon-petit-projet` en supposant que le dossier de votre d√©p√¥t s'appelle `mon-petit-projet`. Puis taper `git remote -v`, une commande qui demande √† `Git` de voir o√π pointe `origin`, votre d√©p√¥t distant. La r√©ponse devrait √™tre l'URL que vous avez renseign√© pr√©cedemment

Ceci √©tait une illustration n√©cessaire pour comprendre le principe de l'authentification. Le prochain exercice (4b) proposera une mani√®re plus directe de fonctionner, qu'il est utile de conna√Ætre car elle vous √©vitera d'avoir √† vous authentifier √† chaque interaction avec le d√©p√¥t distant. 

En option, pour comprendre la diff√©rence avec l'authentification d√©l√©gu√©e propos√©e par VSCode, vous pouvez faire, de mani√®re optionnelle, les consignes suivantes:

1. Toujours dans le m√™me VSCode, ouvrir un nouveau terminal (`‚ò∞ > Terminal > New Terminal`)

2. Taper `git clone https://github.com/<username>/<reponame>.git repo-bis` en rempla√ßant `https://github.com/<username>/<reponame>.git` par l'URL de votre d√©p√¥t. Cela cl√¥nera votre d√©p√¥t dans le dossier `repo-bis` quand vous serez effectivement authentifi√©.

3. Cette fois accepter l'authentification d√©l√©gu√©e propos√©e par VSCode. Il s'agit d'une authentification √† deux facteurs:
    * Le premier facteur d'authentification est le code que `Github` vous demande de copier et de renseigner dans la page que `VSCode` d√©sire ouvrir (il faut que vous acceptiez de copier et d'ouvrir la page). Coller ce code √† 8 caract√®res, valider et accepter les droits demand√©s par l'application. 
    * Le deuxi√®me facteur est le code de votre application d'authentification (par exemple `Google Authenticator` ou celui que vous recevez par SMS). Mettre celui-ci et valider, le cl√¥ne devrait d√©marrer

:::

Cet exercice vient de nous illustrer le principe de l'authentification et la mani√®re dont `VSCode` peut attester de votre identit√© gr√¢ce √† un _token_ ou √† une double authentification. L'exercice suivant propose une m√©thode d'authentification par token un peu plus pratique que celle que nous avions mise en oeuvre ‚òùÔ∏è. 


::: {.exercise}
## Exercice 4b: cr√©er un service et comprendre le principe du cl√¥ne et de l'authentification (utilisateurs du SSPCloud)

Cette approche montre comment le SSPCloud injecte lors de la cr√©ation d'un service VSCode le _token_ et le d√©p√¥t que vous d√©sirez cl√¥ner. 

1. Sur le SSPCloud, se rendre dans la page [Mes Services](https://datalab.sspcloud.fr/my-services). Vous pouvez supprimer le service existant, il n'est plus n√©cessaire.

2. Cliquer sur `‚ûï‚Äã Nouveau service` et choisir un service `vscode-python` (ne pas en prendre un autre).

* Dans un autre onglet, r√©cup√©rer, sur la page d'accueil de votre d√©p√¥t, l'url du d√©p√¥t distant qui est accessible en cliquant √† droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

* D√©rouler le menu `Configuration Vscode-python` et chercher l'onglet `Git`

* Dans celui-ci, vous devriez voir votre _token_ pr√©-inject√© dans le formulaire. Ne le changez pas. 

* Dans un autre onglet, r√©cup√©rer, sur la page d'accueil de votre d√©p√¥t, l'url du d√©p√¥t distant qui est accessible en cliquant √† droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

Vous pouvez utiliser l'icone √† droite {{< fa brands clipboard >}} pour copier l'url.

* Coller celle-ci dans le champ `Repository` du formulaire de cr√©ation du service sur le `SSPCloud`.  Lancer le service et attendre qu'il se cr√©e (une vingtaine de secondes).

* Le cl√¥ne du d√©p√¥t distant devrait √™tre visible dans l'aborescence des fichiers. 

* Ouvrir le terminal (`‚ò∞ > Terminal > New Terminal`) et taper `git remote -v`, une commande qui demande √† `Git` de voir o√π pointe `origin`, votre d√©p√¥t distant. La r√©ponse prend la forme:

```python
https://ghp_XXXX@github.com/username/repository.git
```

qui se distingue de l'URL que vous aviez renseign√© dans l'onglet `Git`. 
Comme vous pouvez le voir avec cette m√©thode, le jeton est en clair. C'est pour cette raison qu'on utilise, plut√¥t que des mots de passe, des jetons
puisque, si ces derniers sont r√©v√©l√©s, on peut toujours les r√©voquer et √©viter
les probl√®mes

:::


::: {.exercise collapse="true"}
## Exercice 4 alternatif: quand on ne dispose pas de compte sur le `SSPCloud`

Le mode op√©ratoire est tr√®s proche. En pratique, la seule diff√©rence est qu'il n'y a pas besoin de cr√©er de nouveau service puisqu'une installation de `VSCode` existe d√©j√†. 

1. Sur votre navigateur, r√©cup√©rer, sur la page d'accueil de votre d√©p√¥t, l'url du d√©p√¥t distant qui est accessible en cliquant √† droite sur le bouton vert `<> Code`. L'URL prend la forme suivante

`https://github.com/<username>/<reponame>.git`

7. Ouvrir le terminal (`Terminal > New Terminal`) et commencer √† taper 

```
git clone
```

et coller la valeur copi√©e pr√©c√©demment. Ne validez pas. Avec les touches directionnelles, se placer entre `https://` et `github.com`. R√©cup√©rer dans votre navigateur ou `Keepass` votre jeton `Github`. Coller celui-ci puis ajouter `@`. Cela devrait donner 

```python
https://ghp_XXXX@github.com/username/repository.git
```

Ce qui, dans l'ensemble, fera

```python
git clone https://ghp_XXXX@github.com/username/repository.git
```

* Le cl√¥ne du d√©p√¥t distant devrait √™tre visible dans l'aborescence des fichiers. 

Comme vous pouvez le voir avec cette m√©thode, le jeton est en clair. C'est pour cette raison qu'on utilise, plut√¥t que des mots de passe, des jetons
puisque, si ces derniers sont r√©v√©l√©s, on peut toujours les r√©voquer et √©viter
les probl√®mes

:::



## La _staging area_
[üëâÔ∏è __*Staging area*__: zone d'attente de `Git` avant validation de nouvelles modifications dans l'histoire d'un fichier.]{.aside}

Dans un monde sans `Git`, on √©crit du code, on sauvegarde son script et parfois on consid√®re que cette version vaut le coup d'√™tre consid√©r√©e comme une version de laquelle repartir. Avec `Git` c'est la m√™me chose, seulement se principe sera formalis√© plus proprement. 

Le premier niveau conceptuel est celui de l'index des modifications. Il s'agit des modifications en attente de validation, d'o√π le nom de _staging area_ dans la premi√®re partie de @fig-staging-area. 

![La gymnastique de `Git` dans son ensemble](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/completeworkflow.png){#fig-staging-area}

En principe, quand on √©dite des scripts ou _notebooks_, on enregistre r√©guli√®rement ceux-ci. Le niveau d'implication suivant est de mettre de c√¥t√© une version particuli√®re de ceux-ci, ce qu'√† la main (voir la @fig-version-control-inferno), nous ferions en dupliquant le fichier. Cela implique de mettre une ou plusieurs modifications dans la liste d'attente des modifications √† valider. Cette op√©ration s'appelle `git add` et est l'objet du prochain exercice. 


::: {.exercise}
## Exercice 5 : Indexer des modifications

1. Cr√©er un dossier üìÅ `scripts` dans le dossier de votre d√©p√¥t. Sur `VSCode`, vous pouvez utiliser les ic√¥nes adapt√©es. 
2. Y cr√©er les fichiers `script1.py` et `script2.py`, chacun contenant quelques commandes `Python` de votre choix (le contenu de ces fichiers n'est pas important).

3. Se rendre dans l'extension `Git` de `VSCode`. Vous devriez
retrouver un cadre ayant cet aspect 

::: {#fig-status layout-ncol=2}

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git_vscode_1.png)

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git-status-ensae.png)


Interface graphique Git sous VSCode (√† gauche) et Jupyter (√† droite)
:::

En ligne de commande, c'est l'√©quivalent de 

```shell
git status
```

2. Sur `VSCode`, un bouton `+` figure √† droite du nom
du fichier `.script1.py` et
`.script2.py`. Sur `Jupyter`, en passant votre souris au dessus du nom des fichiers `script1.py` et
`script2.py`, vous devriez voir
un `+` appara√Ætre. Cliquez dessus. 

Si vous aviez privil√©gi√© la ligne de commande, ce que vous avez fait est √©quivalent √† :

~~~shell
git add scripts/script1.py
git add scripts/script2.py
~~~

3. Observer le changement de statut du fichier apr√®s avoir cliqu√© sur `+`. Il est
d√©sormais dans la partie `Staged`. 

En gros, vous venez de dire √† `Git` que vous allez rendre publique une √©volution
du fichier, mais vous ne l'avez pas encore fait (`Staged` est une liste d'attente).

Si vous √©tiez en ligne de commande vous auriez ce r√©sultat apr√®s un `git status`

```raw
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   .gitignore
```


Les nouvelles modifications (en
l'occurrence la cr√©ation du fichier et la validation de son contenu actuel)
ne sont pas encore archiv√©es. Pour cela, il va falloir faire un 
`commit` (on s'engage en rendant publique une modification).

4. Modifier le contenu d'une ligne d√©j√† existante dans le `README.md` et faire la m√™me gymnastique d'ajout √† l'index. 

5. Regardons les modifications qu'on va prochainement
valider. Pour cela, passez la souris au dessus du nom du fichier
`README.md` et cliquer dessus.
Une page s'ouvre et met en regard la version ant√©rieure avec
les ajouts en vert et les suppressions en rouge. Nous retrouverons
cette visualisation avec l'interface `Github`, plus tard. 

Si vous faites la m√™me chose pour `scripts/script1.py`, comme le fichier n'existait pas, normalement nous n'avons que
des ajouts.

Il est √©galement possible d'effectuer cela avec la ligne de commande mais c'est
beaucoup moins pratique. Pour cela, la commande √† appeler est `git diff` et
il est n√©cessaire d'utiliser l'option `cached` pour lui dire d'inspecter les
fichiers pour lesquels on n'a pas encore effectu√© de `commit`. En vert
appara√Ætront les modifications et en rouge les suppressions mais, cette fois,
les r√©sultats ne seront pas mis c√¥te-√†-c√¥te ce qui est beaucoup moins
pratique.

```shell
git diff --cached
```

:::

## Le _commit_


A ce stade, nous avons configur√© `Git` pour √™tre en mesure 
de s'authentifier automatiquement et nous avons clon√© le d√©p√¥t pour avoir une
copie locale de travail. Nous avons fait des modifications, les avons mis dans la file d'attente de notre syst√®me de gestion de version. Il ne reste plus qu'√† finaliser le travail. 

Pour rappel, la @fig-staging-area illustrait la gymnastique pour faire √©voluer l'histoire de son projet. Apr√®s l'ajout dans la file d'attente (la _staging area_), on valide les modifications avec un _commit_. Comme son nom l'indique, il 
s'agit d'une proposition de modification sur laquelle, en quelques
sortes, on s'engage. 
[üëâÔ∏è __*Commit*__: Enregistrement de l'√©volution d'un fichier. Il s'agit de l'unit√© de temps fondamentale en `Git`.]{.aside}

Un _commit_ comporte un titre et √©ventuellement une description. A ces
informations, `Git` ajoutera automatiquement quelques √©l√©ments
suppl√©mentaires, notamment l'auteur du commit (pour identifier la personne
ayant propos√© cette modification) et l'horodatage (pour identifier le moment
o√π cette modification a √©t√© propos√©e). Ces informations permettront d'identifier
de mani√®re unique le `commit` auquel sera ajout√© un identifiant al√©atoire
unique (un num√©ro SHA) qui permettra de faire r√©f√©rence √† celui-ci sans
ambigu√Øt√©.

Le titre est important car il s'agit, pour un humain, du point d'entr√©e
dans l'histoire d'un d√©p√¥t (voir par exemple
[l'histoire du d√©p√¥t du cours](https://github.com/linogaliana/python-datascientist/commits/main).
Les titres vagues 
(*Mise √† jour du fichier*, *Update*...) sont √† bannir car ils
n√©cessiteront un effort inutile pour comprendre les fichiers modifi√©s.

N'oubliez pas que votre premier collaborateur est votre *moi futur* qui,
dans quelques semaines, ne se souviendra pas en quoi consistait
le commit *Update* du 12 janvier et en quoi il se distingue du 
*Update* du 13 mars. 

::: {.exercise}
## Exercice 5: premier commit (enfin !)

Sur `VSCode`, il faut au contraire regarder en haut.

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git_vscode_2.png)

<details>

<summary>
Sur l'interface de `Jupyter`
</summary>

Sur `Jupyter`, √† l'inverse, tout se passe dans la partie inf√©rieure de l'interface graphique.

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git-panel-jupyter.png)

</details>

1Ô∏è‚É£ Entrer le titre `Cr√©ation des premiers scripts üéâ` et ajouter une description
`Fichiers dans le dossier script`.
Sur `VSCode`, le titre du commit correspond √† la
premi√®re ligne du message de commit, les lignes suivantes, apr√®s un saut de ligne, correspondent √† la
description.

2Ô∏è‚É£ Cliquer sur `Commit`. Le fichier a disparu de la liste, c'est normal,
il n'a plus de modification √† valider. Pour le retrouver dans la liste
des fichiers `Changed`, il faudra le modifier √† nouveau

3Ô∏è‚É£ Vous devriez voir la ligne de vie de votre projet s'allonger. Vous pouvez cliquer sur le commit pour retrouver les changements que vous avez valid√©

:::

```{ojs}
containerQuestionGit1
```


```{ojs}
//| echo: false
//| output: false
viewof questionGit1 = Inputs.radio(
  ['Oui', 'Non', 'Je ne sais pas'],
  {disabled: ['Je ne sais pas'], value: 'Je ne sais pas'}
)
```

```{ojs}
//| echo: false
textQuestion = md`__‚ùì Question : √† ce stade, le d√©p√¥t du projet sur \`GitHub\` <i class="fa-brands fa-github"></i> (votre _remote_) a-t-il √©t√© modifi√© ?__`
```

```{ojs}
//| echo: false
containerQuestionGit1 = {
  // The container div for all the elements
  let container = html`<div class="question-container"></div>`;
  
  // Adding the question text to the container
  let questionText = html`<div class="question-text">${textQuestion}</div>`;
  container.appendChild(questionText);

  // Adding the radio input to the container
  let questionInput = html`<div class="question-input">${viewof questionGit1}</div><br>`;
  container.appendChild(questionInput);

  // Adding the response message to the container
  let questionMessage = html`<div class="question-message">${messageQuestion1}</div>`;
  container.appendChild(questionMessage);
  
  return container;
}
```


```{ojs}
//| echo: false
messageQuestion1 = {
  let message ;
  if (questionGit1 == 'Je ne sais pas'){
    return ""
  }
  message = md`__ü§î Vous √™tes s√ªr ? Allez voir votre d√©p√¥t \`Github\` pour v√©rifier !__ üëÄ`
  if (questionGit1 == "Oui"){
    return message    
  }
  return md`__üéâ Absolument ! Allez voir votre d√©p√¥t \`Github\` pour vous en assurer ! üëÄ__`
}
```

::: {.note}
Si vous utilisiez la ligne de commande, la mani√®re √©quivalente de faire
serait

~~~shell
git commit -m "Initial commit" -m "Cr√©ation des premiers fichiers üéâ"
~~~

L'option `m` permet de cr√©er un message, qui sera disponible √† l'ensemble
des contributeurs du projet. Avec la ligne de commande, ce n'est pas toujours
tr√®s pratique. Les interfaces graphiques permettent des messages plus
d√©velopp√©s (la bonne pratique veut qu'on √©crive un message de commit comme un
mail succinct : un titre et un peu d'explications, si besoin).

:::


## Le fichier `.gitignore`

Lorsqu'on utilise `Git`, il y a des fichiers qu'on ne veut pas partager
ou dont on ne veut pas suivre les modifications (typiquement les grosses bases de donn√©es).

C'est le fichier `.gitignore`
qui g√®re les fichiers exclus du contr√¥le de version.
Lors de la cr√©ation du projet sur `GitHub`, nous avons demand√© la cr√©ation d'un fichier `.gitignore`, qui se situe √† la racine du projet. Il sp√©cifie l'ensemble des fichiers qui seront toujours exclus de l'indexation faite par `Git`.
[üëâÔ∏è `.gitignore`: fichier stockant un ensemble de r√®gles de fichiers ne devant pas √™tre suivis par `Git`.]{.aside}


::: {.exercise}
## Exercice 6: le fichier `.gitignore`

1Ô∏è‚É£ Ouvrir le fichier `.gitignore` et observer
quelques r√®gles √©crites dedans

<details>

<summary>
Afficher ce fichier quand on utilise `Jupyter`
</summary>

Par d√©faut, le fichier `.gitignore` n'est pas affich√© car
les fichiers `.*` sont des fichiers de configuration. Il faut activer
une option pour l'afficher. Tout en haut
de `Jupyter`, cliquer sur `View -> Show Hidden Files`

</details>

2Ô∏è‚É£ Cr√©er un dossier `data` √† la racine du projet et cr√©er √† l'int√©rieur de celui-ci un fichier `data/raw.csv` avec une ligne de donn√©es quelconque. Regardez l'onglet `Git` et remarquez la pr√©sence du fichier dans les changements √† valider. __Ne pas ajouter √† la _staging area_ et committer ce fichier__.

3Ô∏è‚É£ Ajouter la ligne `data/` dans le `.gitignore` (c'est un fichier texte modifiable), n'oubliez pas de sauvegarder. Retourner sur l'onglet `Git` et observer le changement. Comprenez-vous ce qu'il se passe ? 

4Ô∏è‚É£ Cr√©er un fichier `raw2.csv` √† la racine et un fichier `data/read_data.py` avec une ligne de code `Python` (le contenu du fichier n'est pas important).  

5Ô∏è‚É£ Retourner sur l'onglet `Git` et observer le changement de votre d√©p√¥t. 

:::


```{ojs}
//| echo: false
html`${containerQuestionGit2}`
```

```{ojs}
//| echo: false
//| output: false
containerQuestionGit2 = {
  // The container div for all the elements
  let container = html`
    <div class="question-container">
    <div class="question-text">${textQuestion2}</div>
    <div class="question-input">${viewof questionGit2}</div><br>
    <div class="question-message">${messageQuestion2Response}</div>
    </div>
  `;
  
  return container;
}
```

```{ojs}
//| output: false
textQuestion2 = md`__‚ùì **Question** : quelle r√®gle faudrait-il mettre dans notre \`.gitignore\`__`
```


```{ojs}
//| echo: false
//| output: false
viewof questionGit2 = Inputs.radio(
  [
    '\`data/\` est une bonne r√®gle pour mon \`.gitignore\`',
    'Il faudrait mettre \`data/*.csv\`',
    'Il faudrait mettre \`*.csv\`',
    'Je ne sais pas'],
  {disabled: ['Je ne sais pas'], value: 'Je ne sais pas', format: x => md`${x}`}
)
```

```{ojs}
//| echo: false
//| output: false
messageQuestion2 = [
  md`‚ùå __Pourtant le fichier \`raw2.csv/\` n'est pas ignor√© et le fichier \`data/read_data.py\` est ignor√©. Certes ils sont plac√©s √† un endroit non logique mais peut-√™tre avez-vous mis ces fichiers √† cette endroit volontairement.__`,
  md`‚ùå __Le fichier \`raw2.csv\` est mal plac√©, pour que cette r√®gle s'applique, il faudrait le d√©placer. Ou faire une r√®gle plus conservatrice__`,
  md`‚úÖ __C'est une bonne r√©ponse ! C'est une r√®gle certes conservatrice mais qui vous √©vitera de divulguer des donn√©es confidentielles sans faire expr√®s (voir üëáÔ∏è)__`,
  md``
]
```

```{ojs}
//| echo: false
//| output: false
messageQuestion2Response = {
  let message;
  
  switch (questionGit2) {
    case '\`data/\` est une bonne r√®gle pour mon \`.gitignore\`':
      message = messageQuestion2[0];
      break;
      
    case "Il faudrait mettre \`data/*.csv\`":
      message = messageQuestion2[1];
      break;
      
    case "Il faudrait mettre \`*.csv\`":
      message = messageQuestion2[2];
      break;

    case 'Je ne sais pas':
      message = messageQuestion2[3];
      break;
      
    default:
      message = md``; // Default case if none match, empty message
  }
  
  return message;
}
```


```{ojs}
textQuestion3
```

```{ojs}
//| output: false
textQuestion3 = md`__‚ùì **Question** : que se passe-t-il lorsque l'on ajoute au \`.gitignore\` des fichiers qui ont d√©j√† √©t√© *commit* sur le projet Git ?__`
```

Il ne faut pas n√©gliger le `.gitignore`. 

`Git` est un syst√®me de contr√¥le de version qui est pens√© pour des fichiers textes, pas des fichiers de donn√©es. Contrairement aux fichiers texte o√π `Git` peut contr√¥ler ligne √† ligne les √©volutions, ce qui en fait un gestionnaire de version utile, les fichiers de donn√©es sont trop complexes pour ce suivi fin, ce qui fait que chaque modification de ces fichiers, souvent lourds (plusieurs M√©ga Octets), revient √† dupliquer le fichier dans la m√©moire de `Git` (plus de d√©tails sur les alternatives dans @tip-data).

Outre cette raison technique qui explique qu'on veuille exclure les fichiers de donn√©es du contr√¥le de version, il ne faut pas oublier que les donn√©es exploit√©es par les _data scientists_ sont souvent confidentielles, collect√©es pour des finalit√©s bien d√©finies ou ayant un int√©r√™t strat√©gique qu'une divulgation √† des concurrents pourait fragiliser. Partager des donn√©es au monde entier peut co√ªter tr√®s cher en vertu du RGPD dont les amendes peuvent aller jusqu'√† 4% du chiffre d'affaires mondial.

Ce fichier `.gitignore` fait ainsi office de garde-fou. Il est utile d'√™tre conservateur avec celui-ci quitte √† autoriser, au cas par cas et de mani√®re consciente, des d√©rogations. Pour cette raison, il est recommand√© d'ajouter de nombreuses extensions classiques de donn√©es √† celui-ci: `*.xlsx`, `*.csv`, `*.parquet`...


::: {#tip-data .callout-tip collapse="true"}
## Si les donn√©es ne vont pas sur `Github`, o√π les stocker ?

Il est plus pertinent de stocker des donn√©es dans des environnements _ad hoc_. Pour cela, l'√©tat de l'art dans les technologies _cloud_ est d'utiliser un syst√®me de stockage sp√©cialis√© qui suit un protocole nomm√© `S3`. Ce dernier a √©t√© d√©velopp√© √† l'origine par Amazon pour son _cloud_ commercial AWS avant d'√™tre rendu _open source_. Cela permet ainsi d'avoir des infrastructures _cloud_ qui utilisent cette technologie ind√©pendamment d'Amazon. 

`Github` appara√Æt certes pratique pour stocker des donn√©es. Mais il n'y a pas de _free lunch_. Ceci a d'abord un co√ªt environnemental : `Git`, et donc _a fortiori_ `Github`, n'√©tant pas des syst√®mes de stockage de bases de donn√©es, ils n'optimisent pas le stockage de celles-ci. Il serait bon de ne pas faire cro√Ætre plus que n√©cessaire, par du gaspillage num√©rique, l'empreinte carbone du num√©rique, d√©j√† en croissance [@arcep2019]. Ensuite, ce choix, √† l'origine pratique, s'av√®re souvent co√ªteux √† long terme. Si la donn√©e archiv√©e avec `Git` √©volue fr√©quemment, la duplication in√©vitable qu'implique celle-ci fera exploser la volum√©trie du d√©p√¥t. A partir d'un certain seuil, il faudra basculer vers des solutions complexes comme `Git large file storage (LFS)` ce qui est clairement √©vitable avec de la discipline. Au contraire, avec des syst√®mes de stockage pens√©s pour de la donn√©e, comme le protocole `S3`, le stockage et le traitement de celle-ci sont optimis√©s. C'est ce qui distingue les syst√®mes de stockage de donn√©es comme `S3` d'autres syst√®mes de stockages pens√©s pour des fichiers, ind√©pendamment de leur format, comme `Drive` qui n'est pas adapt√© aux besoins des _data scientists_.

Stocker de la donn√©e est co√ªteux pour les fournisseurs de _cloud_ et il n'est pas √©tonnant que ces derniers proposent rarement des offres gratuites de volumes importants. Les utilisateurs.trices du `SSPCloud` b√©n√©ficient d'un syst√®me de stockage associ√© √† la plateforme et suivant le protocole S3. Plus d'√©l√©ments dans le [chapitre consacr√©](/modern-ds/s3.qmd) et dans le cours de 3e ann√©e de l'ENSAE de [Mise en production de projets _data science_](https://ensae-reproductibilite.github.io/website/).

:::


# Premi√®res interactions avec `Github` depuis sa copie de travail

Jusqu'√† pr√©sent, apr√®s avoir clon√© le d√©p√¥t, on a travaill√© uniquement
sur notre copie locale. On n'a pas cherch√© √† interagir √† nouveau 
avec `Github`. 

Il est tout √† fait possible de faire du contr√¥le de version sans
mettre en place de d√©p√¥t distant. Cependant, 

* c'est dangereux puisque le d√©p√¥t distant fait office de sauvegarde 
d'un projet. Sans d√©p√¥t distant, on peut tout perdre en cas de probl√®me
sur la copie locale de travail ;
* c'est d√©sirer √™tre moins efficace car, comme nous allons le montrer, les
fonctionalit√©s des plateformes `Github` et `Gitlab` sont √©galement tr√®s 
b√©n√©fiques lorsqu'on travaille tout seul. 


Interagir avec le d√©p√¥t distant consiste √† r√©cup√©rer les nouveaut√©s sur celui-ci ou envoyer nos derni√®res modifications vers ce d√©p√¥t centralisateur. En pratique, on peut donc r√©sumer 95% de la pratique quotidienne de `Git` en trois mots:

* `commit` : je valide les modifications que j'ai faites en local avec un message qui les explique
* `pull` : je r√©cup√®re la derni√®re version des codes du d√©p√¥t distant (op√©ration dite `fetch`) et je la fusionne avec mes changements, si j'en ai fait (op√©ration dite `merge`)
* `push` : je transmets mes modifications valid√©es au d√©p√¥t distant

Nous avons d√©j√† vu le premier, nous allons voir maintenant les deux nouveaux termes. 
Avant cela, on peut revenir sur une commande d√©j√† √©voqu√©e `git remote -v`. Le d√©p√¥t distant s'appelle `remote` en langage Git. L'option `-v` (*verbose*)
permet de lister le(s) d√©p√¥t(s) distant(s). 

En ouvrant un terminal dans `VSCode`, en tapant `git remote -v` dans celui-ci, vous devriez avoir un r√©sultat similaire √† celui-ci:

```shell
origin  https://<PAT>@github.com/<username>/<projectname>.git (fetch)
origin  https://<PAT>@github.com/<username>/<projectname>.git (push)
```

Plusieurs informations sont int√©ressantes dans ce r√©sultat. D'abord on 
retrouve bien l'url qu'on avait renseign√© √† `Git` lors de l'op√©ration
de clonage. Ensuite, on remarque un terme `origin`. C'est un alias
pour l'url qui suit. Cela √©vite d'avoir, √† chaque fois, √† taper l'ensemble
de l'url, ce qui peut √™tre p√©nible et source d'erreur.

`fetch` et `push`
sont l√† pour nous indiquer qu'on r√©cup√®re (`fetch`) des modifications
d'`origin` mais qu'on envoie √©galement (`push`) des modifications vers
celui-ci. G√©n√©ralement, les url de ces deux d√©p√¥ts sont les m√™mes mais cela peut
arriver, lorsqu'on contribue √† des projets opensource qu'on n'a pas cr√©√©, 
qu'ils diff√®rent. Ceci sera expliqu√© dans le prochain chapitre lorsque nous aborderons le sujet de la collaboration. 

## Envoyer des modifications sur le d√©p√¥t distant (`push`)

::: {.exercise}
## Exercice 7 : Interagir avec `Github`

Il convient maintenant d'envoyer les fichiers sur le d√©p√¥t distant. 

1Ô∏è‚É£ Si vous ne l'avez pas d√©j√† fait, ajouter la r√®gle `*.csv` dans votre `.gitignore`. Avec l'interface graphique, ajouter tous les fichiers en attente dans l'index (`git add`) et faites un _commit_ (`git commit`).  
2Ô∏è‚É£ Cliquer sur le bouton <i class="fa-solid fa-arrows-rotate"></i> Sync changes <i class="fa-solid fa-arrow-up"></i>

L'√©quivalent de ces deux questions serait, en ligne de commande:

```{python}
#| eval: false
git add -u
git commit -m "Le titre du commit"
git push origin main #<1>
```
1. Cela signifie: *"git envoie (`push`) mes modifications sur la 
branche `main` (la branche sur laquelle on a travaill√©, on reviendra
dessus) vers mon d√©p√¥t (alias
`origin`)"*


:::


## R√©cup√©rer des modifications depuis le d√©p√¥t distant (`pull`)

La deuxi√®me mani√®re d'interagir avec le d√©p√¥t est de r√©cup√©rer des
r√©sultats disponibles en ligne sur sa copie de travail. On appelle
cela `pull`. 

Pour le moment, vous √™tes tout seul sur le d√©p√¥t. Il n'y a donc pas de 
partenaire pour modifier un fichier dans le d√©p√¥t distant. On va simuler ce
cas en utilisant l'interface graphique de `Github` pour modifier
des fichiers. On rapatriera les r√©sultats en local dans un deuxi√®me temps. 

::: {.exercise}
## Exercice 8: Rapatrier des modifications en local

1Ô∏è‚É£ Se rendre sur votre d√©p√¥t depuis l'interface <https://github.com>

* Se placer sur le fichier `README.md` et cliquer sur le bouton `Edit this file`, qui prend la forme d'un ic√¥ne de crayon.

2Ô∏è‚É£ Changer le titre du `README.md`. Sautez une ligne √† la fin de votre fichier et entrez le texte que vous d√©sirez, sans ponctuation. Par exemple,

~~~markdown
le ch√™ne un jour dit au roseau
~~~

3Ô∏è‚É£ Cliquez sur l'onglet `Preview` pour voir le texte mis en forme au format `Markdown`

4Ô∏è‚É£  R√©diger un titre et un message compl√©mentaire pour faire le `commit`. Conserver
l'option par d√©faut `Commit directly to the main branch`

5Ô∏è‚É£ Editer √† nouveau le `README` en cliquant sur le crayon juste au dessus
de l'affichage du contenu du `README`.

Ajouter une deuxi√®me phrase et corrigez la
ponctuation de la premi√®re. Ecrire un message de commit et valider.

~~~markdown
Le Ch√™ne un jour dit au roseau :
Vous avez bien sujet d'accuser la Nature
~~~

6Ô∏è‚É£ Au dessus de l'aborescence des fichiers, vous devriez voir s'afficher le
titre du dernier commit. Vous pouvez cliquer dessus pour voir la modification
que vous avez faite.

7Ô∏è‚É£ Les r√©sultats sont sur le d√©p√¥t distant mais ne sont pas sur votre
dossier de travail dans `Jupyter` ou `VSCode`. Il faut re-synchroniser votre copie locale
avec le d√©p√¥t distant :

* Sur `VSCode`, cliquez simplement sur `... > Pull` √† c√¥t√© du bouton qui permet
de visualiser le graphe Git.
* Avec l'interface `Jupyter`, si cela est possible, appuyez tout simplement sur la petite
fl√®che vers le bas, qui est celle qui a d√©sormais la pastille orange.
* Si cette fl√®che n'est pas disponible ou si vous travaillez dans un autre
environnement, vous pouvez utiliser la ligne de 
commande et taper

```{python}
#| eval: false
git pull origin main #<1>
```
1. Cela signifie : *"git r√©cup√®re (`pull`) les modifications sur la 
branche `main` vers mon d√©p√¥t (alias
`origin`)"*


8Ô∏è‚É£ Regarder √† nouveau l'historique des commits. Cliquez sur le
dernier commit et affichez les changements sur le fichier. Vous pouvez
remarquer la finesse du contr√¥le de version : `Git` d√©tecte au sein de
la premi√®re ligne de votre texte que vous avez mis des majuscules
ou de la ponctuation. 


:::

L'op√©ration `pull` permet : 

1. A votre syst√®me local de v√©rifier les modifications sur le d√©p√¥t distant
que vous n'auriez pas faites (cette op√©ration s'appelle `fetch`)
2. De les fusionner s'il n'y a pas de conflit de version ou si les conflits de
version sont automatiquement fusionnables (deux modifications d'un fichier mais
qui ne portent pas sur le m√™me emplacement).

# Les branches

Jusqu'√† pr√©sent, nous avons fait √©voluer de mani√®re lin√©aire notre historique, sans prendre de risque. Ceci est d√©j√† tr√®s s√©curisant puisqu'on peut toujours retrouver l'√©tat pass√© d'un code. Mais comment faire quand on d√©sire faire des √©volutions cons√©quentes, impliquant plusieurs √©tapes interm√©diaires ayant vocation √† √™tre chacune un _commit_, sans risque de d√©stabiliser notre version dont on √©tait, jusqu'√† pr√©sent, satisfait. 

`Git` propose un syst√®me extr√™mement pratique pour cela: les branches. Une branche est une version parall√®le du projet qui coexiste avec la version principale, sur `main`. Cela veut dire qu'avec `Git`, on peut avoir un m√™me fichier qui coexiste sous plusieurs versions diff√©rentes ce qui constitue un terreau fertile pour l'exp√©rimentation. Une version sera active (la branche active) mais les autres seront disponibles, activables si besoin. 

On peut voir l'historique de `Git` comme un arbre raffin√©. La branche `main` est le tronc. Les autres branches partent de ce tronc et divergent. Le tronc peut tr√®s bien √©voluer en parall√®le de ces branches. L'arbre de `Git` est n√©anmoins sp√©cial, quelques peu noueux : les branches peuvent revenir et fusionner avec le tronc. Nous verrons cela de mani√®re plus illustr√©e dans le prochain exercice et dans le prochain chapitre puisque c'est l'une des bases du travail collaboratif avec `Git`.

Voici quelques exemples o√π les branches sont utilis√©es pour des travaux significatifs :

- vous travaillez seul sur une t√¢che qui va vous prendre plusieurs heures ou jours de travail (vous ne devez pas pousser sur `main` des travaux non aboutis);
- vous travaillez sur une fonctionnalit√© nouvelle et vous souhaiterez recueillir l'avis de vos collaborateurs avant de modifier `main`;
- vous n'√™tes pas certain de r√©ussir vos modifications du premier coup et pr√©f√©rez faire des tests en parall√®le.

Il est commun, dans un cadre collaboratif, d'utiliser √† foison les branches. Comme nous le verrons dans le prochain chapitre, cela peut en effet faire √©conomiser un temps pr√©cieux si l'organisation du projet est mal d√©finie. N√©anmoins, les branches ne sont pas un rem√®de magique car leur gestion demande de la rigueur et peut entra√Æner de la d√©sorganisation sans celle-ci. `Git` est une solution technique qui fluidifie l'organisation mais en cas de r√¥les mal d√©finis, il va rapidement vous r√©v√©ler les probl√®mes, mais ne vous offrira pas la solution sans un effort de r√©flexion sur l'organisation du travail.

::: {.caution}

Les branches ne sont pas personnelles, ce n'est pas parce que vous avez cr√©√© une branche qu'une des personnes collaborant avec vous sur le projet `Git` ne pourra pas modifier cette branche. 

L'utilisation des branches est une fonctionnalit√© d√©j√† avanc√©e de `Git`. Ce dernier est un outil technique formidable mais ne r√©sout pas les probl√®mes organisationnels. Au contraire, avec `Git`, ils se r√©v√®leront beaucoup plus vite. `Git` est vraiment le socle minimal des bonnes pratiques, un outil qui va inciter √† toujours mieux travailler. 

Parmi les pratiques techniquement possibles mais non recommandables, il faut **absolument** bannir les usages de `push force` qui peuvent d√©stabiliser les copies locales des collaborateurs. S'il est n√©cessaire de faire un `push force`, c'est qu'il y a un probl√®me dans la branche, √† identifier et r√©gler **sans** faire `push force`.

![](https://miro.medium.com/max/400/0*XaLzNzYkA6PZjbl9.jpg)

:::

Les branches sont g√©n√©ralement associ√©es au syst√®me des [_issues_](https://docs.github.com/fr/issues/tracking-your-work-with-issues/about-issues) sur `Github`. Les _issues_ ne sont pas des fonctionnalit√©s natives de `Git` mais apport√©es par `Github` qui vise √† simplifier le suivi d'un projet et les retours des autres collaborateurs.trices ou utilisateurs.trices d'un projet. 

On peut voir les _issues_ comme un syst√®me de discussion o√π peuvent √©changer les personnes int√©ress√©es par le projet. L'int√©r√™t d'utiliser ceci par le biais de `Github` plut√¥t qu'une boucle de mail et que cela permet de centraliser au m√™me endroit que le code les √©changes et la documentation utiles √† son √©volution. La finalit√© des _issues_ est tr√®s large: cela peut √™tre pour discuter de nouvelles fonctionnalit√©s qui finalement ne seront pas mises en oeuvre, signaler des bugs, se r√©partir le travail, etc. Une utilisation intensive des *issues*, avec des labels ad√©quats, peut m√™me amener √† se passer d'outils de gestion de projets comme `Trello`. 

Le prochain exercice vise √† illustrer le principe des branches en inventant un exemple de demande passant par une _issue_ et proposant une nouvelle fonctionnalit√© dans le projet. 

::: {.exercise}
## Exercice 8: Cr√©er une nouvelle branche et l'int√©grer dans `main`

1Ô∏è‚É£ Ouvrir une *issue* sur `Github`. Signaler qu'il serait bien d'ajouter un emoji chat dans le README. Dans la partie de droite, cliquer sur la petite roue √† c√¥t√© de `Label` et cliquer sur `Edit Labels`. Cr√©er un label `Markdown`. Normalement, le label a √©t√© ajout√©.

2Ô∏è‚É£ Retournez sur votre d√©p√¥t local. Vous allez cr√©er une branche nomm√©e
`issue-1`

<details>
<summary>

Comment faire dans `VSCode` ?

</summary>

Sur VSCode, cliquez sur `... > Branch > Create Branch` et entrez le nom `issue-1`.
</details>


<details>
<summary>

Comment faire dans `Jupyter` ?

</summary>

Avec l'interface graphique de `JupyterLab`, cliquez sur `Current Branch - Main`
puis sur le bouton `New Branch`. Rentrez `issue-1` comme nom de branche
(la branche doit √™tre cr√©√©e depuis `main`, ce qui est normalement le choix
par d√©faut) et cliquez sur `Create Branch`.

</details>

<details>
<summary>

Comment faire en ligne de commande ?

</summary>

Si vous n'utilisez pas l'interface graphique mais la ligne de commande, la
mani√®re √©quivalente de faire est

```{python}
#| eval: false
git checkout -b issue-1 #<1>
```
1. La commande `checkout` est un couteau-suisse de la gestion de branche en `Git`. Elle permet en effet de basculer d'une branche √† l'autre, mais aussi d'en cr√©er, etc. 


</details>

3Ô∏è‚É£ Ouvrez `README.md` et ajoutez un emoji chat (`:cat:`) √† la suite du titre.
Faites un commit en refaisant les √©tapes vues dans les exercices
pr√©c√©dents. N'oubliez pas, cela se fait en deux √©tapes:

1. Ajoute les modifications √† l'index en d√©placant le fichier `README` dans
la partie `Staged`
2. Validation des modifications avec un `commit`

Si vous passez par la ligne de commande, cela donnera :

~~~shell
git add .
git commit -m "ajout emoji chat"
~~~


4Ô∏è‚É£ Faire un **deuxi√®me commit** pour ajouter un emoji koala (:koala:) puis
pousser les modifications locales: 
    + Sur `VSCode`, cliquez sur le bouton `Publish Branch`.
    + Sinon, si vous utilisez la ligne de commande, vous devrez taper `git push origin issue-1`


5Ô∏è‚É£ Dans `Github`, devrait appara√Ætre 

> `issue-1 had recent pushes XX minutes ago`. 

Cliquer sur `Compare & Pull Request`. Donner un titre informatif √† votre *pull request* 
Dans le message en dessous, taper

> `- close #1`

Le tiret est une petite astuce pour que `Github` 
remplace le num√©ro de l'issue par le titre.

Cliquez sur `Create Pull Request` mais 
**ne validez pas la fusion**, on le fera dans un second temps.

Le fait d'avoir mis un message `close` suivi d'un num√©ro d'issue `#1`
permettra de fermer automatiquement l'*issue 1* lorsque vous ferez le *merge*.
En attendant, vous avez cr√©√© un lien entre l'*issue* et la *pull request*

Au passage, vous pouvez ajouter le label `Markdown` sur la droite. 

6Ô∏è‚É£ En local, retourner sur `main`. Dans l'interface `Jupyter`, il suffit
de cliquer sur `main` dans la liste des branches. Sur `VSCode`, la liste des branches
appara√Æt en cliquant sur le nom de la branche actuelle (`issue-1` en th√©orie √† ce stade).
Si vous √™tes en ligne de commande, il faut faire

~~~shell
git checkout main
~~~~

`checkout` est une commande `Git` qui permet de naviguer d'une branche √† l'autre
(voire d'un commit √† l'autre). 

Ajouter une phrase √† la suite de votre texte dans le `README.md` 
(ne touchez pas au titre !). Vous pouvez remarquer que les emojis
ne sont pas dans le titre, c'est normal vous n'avez pas encore fusionn√© les versions

7Ô∏è‚É£ Faire un commit et un push. En ligne de commande, cela donne

~~~shell
git add .
git commit -m "ajoute un troisi√®me vers"
git push origin main
~~~


8Ô∏è‚É£ Sur `Github`, cliquer sur `Insights` en haut du d√©p√¥t puis, √† gauche sur `Network` (cela n'est
possible que si vous avez rendu public votre d√©p√¥t).

Vous devriez voir appara√Ætre l'arborescence de votre d√©p√¥t. On peut voir `issue-1` comme une ramification et `main` comme le tronc.

L'objectif est maintenant de ramener les modifications faites dans `issue-1` dans la branche principale. Retournez dans l'onglet `Pull Requests`. L√†, changer le type de `merge` pour `Squash and Merge`, comme ci-dessous (petit conseil : choisissez toujours cette m√©thode de *merge*).

Une fois que cela est fait, vous pouvez retourner dans `Insights` puis `Network` pour v√©rifier que tout s'est bien pass√© comme pr√©vu. 


![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/squashmerge.png)


9Ô∏è‚É£ Supprimer la branche (*branch > delete this branch*). Puisqu'elle est merg√©e, elle ne servira plus. La conserver risque d'amener √† des `push` involontaires dessus. 

:::

::: {.tip}
L'option de fusion *Squash and Merge* permet de regrouper tous les commits d'une branche (potentiellement tr√®s nombreux) en un seul dans la branche de destination. Cela √©vite, sur les gros projets, des branches avec des milliers de *commits*.

Je recommande de toujours utiliser cette technique et non les autres. 
Pour d√©sactiver les autres techniques, vous pouvez aller dans
`Settings` et dans la partie `Merge button` ne conserver coch√©e que la
m√©thode `Allow squash merging`
:::


Nous avons toutes les bases n√©cessaires pour passer √† l'√©tape suivante dans notre p√©riple `Git`: le travail collaboratif. N√©anmoins, `Git` ne doit pas √™tre utilis√© que dans des projets collectifs. M√™me tout seul, les gains de qualit√© √† l'utilisation de `Git` sont sans √©quivalents. 

