---
title: "Git : un élément essentiel au quotidien"
weight: 10
slug: introgit
categories:
  - Tutoriel
  - Git
description: |
  `Git` est un système de contrôle de version qui facilite la
  sauvegarde, la gestion des évolutions et le partage
  d'un projet informatique. Il s'agit d'un élément devenu
  indispensable dans le domaine de la _data science_.
  Ce chapitre présente quelques concepts qui seront 
  mis en pratique dans le suivant. 
image: https://ensae-reproductibilite.github.io/website/snakedolls.jpg
---


::: {.content-visible when-format="html"}
{{< include "../../build/_printBadges.qmd" >}}
:::

# Quelques bases sur `Git`

## Copies de travail et dépôt collectif

`Git` est un système décentralisé et asynchrone de gestion de version. 
Cela signifie que:

* Chaque membre d'un projet travaille sur une copie locale du dépôt
(système *decentralisé*). Cette copie de travail s'appelle un `clone`.
Cela signifie qu'on n'a pas une cohérence en continu de notre version
de travail avec le dépôt ; on peut très bien ne jamais vouloir les
mettre en cohérence (par exemple, si on teste une piste qui s'avère
infructueuse) ;
* C'est lorsqu'on propose la publication de modifications sur le dépôt
collectif qu'on doit s'assurer de la cohérence avec la version disponible
en ligne (système *asynchrone*).

Le dépôt distant est généralement stocké sur
une **forge  logicielle** (`Github` ou `Gitlab`) et sert à centraliser la version
collective d'un projet. Les copies locales sont des copies de travail
qu'on utilise pour faire évoluer un projet :


Il est tout à fait possible de faire du contrôle de version sans
mettre en place de dépôt distant. Cependant, 

* c'est dangereux puisque le dépôt distant fait office de sauvegarde 
d'un projet. Sans dépôt distant, on peut tout perdre en cas de problème
sur la copie locale de travail ;
* c'est désirer être moins efficace car, comme nous allons le montrer, les
fonctionalités des plateformes `Github` et `Gitlab` sont également très 
bénéfiques lorsqu'on travaille tout seul. 

## Principe


Les trois manipulations les plus courantes sont les suivantes et représentées sur le diagramme ci-après :

* `commit` : je valide les modifications que j'ai faites en local avec un message qui les explique
* `pull` : je récupère la dernière version des codes du dépôt distant
* `push` : je transmets mes modifications validées au dépôt distant

![](https://gitlab.com/linogaliana/collaboratif/-/raw/main/pics/03_git/push_pull_Drees.png)

Les deux dernières manipulations correspondent aux interactions (notamment
la mise en cohérence) avec
le dépôt commun alors que la première manipulation `commit` correspond à
la modification des fichiers faite pour faire évoluer un projet. 

De manière plus précise, il y a trois étapes avant d'envoyer les modifications validées (`commit`) au dépôt. Elles se définissent en fonction des commandes qui permettent de les appliquer quand Git est utilisé en lignes de commandes :

* `diff` : inspection des modifications. Cela permet de comparer les fichiers modifiés et de distinguer les fichiers ajoutés ou supprimés.
* `staging area` : sélection des modifications.
* `commit` : validation des modifications sélectionnées (avec commentaire).

![](https://gitlab.com/linogaliana/collaboratif/-/raw/main/pics/03_git/trois_%C3%A9tats_fichier.png)


Lors des étapes de `push` et `pull`, des **conflits** peuvent apparaître, par exemple lorsque deux personnes ont modifié le même programme simultanément. Le terme conflit peut faire peur mais en fait c'est 
l'un des apports principaux de `Git` que de faciliter énormément la gestion
de versions différentes. Les exercices du chapitre suivant l'illustreront.  

## Les branches


C'est une des fonctionnalités les plus pratiques de la gestion de version. 
La création de `branches` dans un projet (qui devient ainsi un arbre)
permet de développer en parallèle des correctifs ou une nouvelle fonctionnalité
sans modifier le dépôt commun.

Cela permet de séparer le nouveau développement et de faire cohabiter plusieurs versions, pouvant évoluer séparément ou pouvant être facilement rassemblées. Git est optimisé pour le travail sur les branches.

Dans un projet collaboratif, une branche dite **master** joue le rôle du tronc.
C'est autour d'elle que vont pousser ou se greffer les branches.
L'un des avantages de `Git` est qu'on peut toujours revenir en arrière. Ce
filet de sécurité permet d'oser des expérimentations, y compris au sein
d'une branche. Il faut être prêt à aller dans la ligne de commande pour cela
mais c'est extrêmement confortable. 

::: {.cell .markdown}
```{=html}
<div class="alert alert-info" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-comment"></i> Note</h3>
```

Comment nommer les branches ? Là encore, il y a énormément de conventions différentes. Une fréquemment observée est :

- pour les nouvelles fonctionnalités : `feature/nouvelle-fonctionnalite` où `nouvelle-fontionnalite` est un nom court résumant la fonctionnalité
- pour les corrections de bug : `issue-num` où `num` est le numéro de l'issue

N'hésitez pas à aller encore plus loin dans la normalisation  !

```{=html}
</div>
```
:::



# Conseil de praticien : ne pas négliger le `.gitignore`

Un fichier à ne pas négliger est le `.gitignore`. Il s'agit d'un garde-fou car tous les fichiers (notamment des
données, potentiellement volumineuses ou confidentielles) n'ont pas vocation
à être partagés.

Le site [gitignore.io](https://www.toptal.com/developers/gitignore) est très pratique. Le fichier
suivant est par exemple proposé pour les utilisateurs de `Python`, auquel on peut ajouter
quelques lignes adaptées aux utilisateurs de données :

<details>
<summary>

Exemple de `.gitignore` pour les utilisateurs de données

</summary>

```markdown
"""
~~~raw
*.html
*.pdf
*.csv
*.tsv
*.json
*.xml
*.shp
*.xls
*.xlsx

### Python ###
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a Python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/
~~~
"""
)
```

</details>