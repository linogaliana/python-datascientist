---
title: "Découvrir Git par la pratique: la gymnastique quotidienne"
categories:
  - Tutoriel
  - Git
description: |
  `Git` est un système de contrôle de version qui facilite la
  sauvegarde, la gestion des évolutions et le partage
  d'un projet informatique. Il s'agit d'un élément devenu
  indispensable dans le domaine de la _data science_.
  Ce chapitre présente quelques concepts qui seront 
  mis en pratique dans le suivant. 
image: https://ensae-reproductibilite.github.io/website/snakedolls.jpg
echo: false
---

{{< badges >}}

Le [chapitre d'introduction](/content/git/index.qmd) de la partie a évoqué les enjeux, présentés de manière synthétique
dans un [cours dédié fait avec Romain Avouac](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html)

:::{.cell .markdown}
Dérouler les _slides_ ci-dessous ou [cliquer ici](/slides/ggplot.qmd)
pour afficher les slides en plein écran.

```{=html}
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><iframe class="sourceCode yaml code-with-copy" src="https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/complete.html#/partie-1-contr%C3%B4le-de-version-avec-git"></iframe></div>
```

:::

Ce chapitre va être l'occasion de faire ses premiers pas avec `Git`. Le prochain chapitre sera consacré au travail collaboratif. 

Pour comprendre les analogies avec le versionnage artisinal à la main, rappelons nous le principe de celui-ci avec la @version-control-inferno

![Le contrôle de version artisanal](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/fichiers_multiples.png){#version-control-inferno}


::: {.important}
Il est vivement recommandé de privilégier `VSCode` pour l'apprentissage de `Git`. Son extension est très bien faite, bien meilleure que celle de `Jupyter`. 

`Colab` n'embarque pas, nativement, d'extension `Git`. Des sauvegardes automatiques sont possibles sur `Github` mais ce n'est pas une pratique à encourager. Pire encore, `Colab` proposera plutôt une intégration avec `Drive`, un autre produit `Google`. Certes le _notebook_ sera versionné puisque `Drive` embarque des sauvegardes de version mais ce n'est pas une technologie faite pour les sauvegardes de code ; elle n'apportera pas les bénéfices de `Git` qui seront évoqués ultérieurement.

Les élèves de l'ENSAE, et plus globalement l'ensemble des personnes pouvant bénéficier de l'infrastructure du SSPCloud[^eligibilite],
ont à disposition des environnements de développement `Python` avec `Git` préinstallé et accessible par l'intermédiaire d'interfaces connectées aux IDE. Ce _notebook_ est lançable sur cette infrastructure par le biais de ces boutons

[^eligibilite]: Pour savoir si vous êtes éligibles au SSPCloud, vous pouvez cliquer sur [ce lien](https://auth.lab.sspcloud.fr/auth/realms/sspcloud/login-actions/authenticate?client_id=onyxia) et consulter la liste des domaines autorisés. 

{{< badges
    printMessage="false"
    onyxiaOnly="true"
>}}

Si vous n'êtes pas éligibles au `SSPCloud`, le chemin pour obtenir un environnement prêt à l'emploi pour `Git` et `Python` est plus tortueux. Il est recommandé de télécharger et installer [`VSCode`](https://code.visualstudio.com/), d'ajouter _a minima_ les [extensions `Python`](https://code.visualstudio.com/docs/languages/python) et [`GitLens`](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens). Il est bien sûr possible d'aller plus loin dans la customisation de l'environnement de développement mais ce sont les briques minimales pour avoir un environnement local fonctionnel et ergonomique. 

:::

# Avant de démarrer: créer un compte `Github` et créer une copie de travail

La première étape se fait sur [`Github`](https://github.com). et consiste à se créer un compte sur cette plateforme.

::: {.exercise}
## Exercice 1 : Créer un compte `Github`

_Il est important de suivre pas à pas les consignes, chaque étape est importante_

1. Si vous n'en avez pas déjà un, créer un compte sur [github.com](https://github.com)
2. Créer un dépôt en suivant les consignes ci-dessous.
  + __Créer ce dépôt privé__, cela permettra
dans l'exercice 2 d'activer notre jeton. Vous pourrez le rendre public
après l'exercice 2, c'est comme vous le souhaitez.
  + __Créer ce dépôt avec un `README.md`__ en cliquant sur la case `Add a README file`
* Ajouter un `.gitignore` en sélectionnant le modèle `Python`

*Connexion sur <a href="https://github.com">https://github.com</a> > + (en haut de la page) > New repository > Renseigner le "Repository name" > Cocher "private" > "Create repository"*

:::


# Quelques bases sur `Git`

## Version distante, version locale

Nous avons, avec l'exercice précédent, créé un premier dépôt. Il s'agit d'un dépôt centralisé qui va servir de source de vérité pour notre projet et par l'intermédiaire duquel interagissent les contributeurs.trices d'un projet. Mais nous n'avons pas parlé de comment le faire évoluer, pour cela il faut créer des copies de travail. 

`Git` est un système décentralisé de contrôle de version[^asynchrone]. Cela signifie que les contributeurs.trices modifient les fichiers dans leur éditeur de prédilection puis soumettent ceux-ci pour mettre à jour la source de vérité, le dépôt distant

![Le principe décentralisé de `Git`](img/gitremote.png){#fig-local-remote}

Nous reviendrons plus précisément sur #fig-local-remote par la suite et notamment les nombreux termes techniques indiqués dessus. Mais la compréhension de cette distinction fondamentale entre dépôt distant et dépôt local était importante pour pouvoir démarrer. On appelle __forge__ une plateforme qui stocke des dépôts distants. Dans ce cours, nous allons présenter `Github` mais il en existe d'autres, notamment `Gitlab`.

Nous avons créé notre dépôt distant à l'exercice principal. Comme créer une version de travail ? Cette opération s'appelle faire un clône (`git clone`). L'objectif du prochain exercice est de faire cette opération, ce qui nécessite néanmoins la compréhension du concept d'authentification avant de pouvoir commencer celui-ci. 

[^asynchrone]: Plus précisément, `Git` est un système décentralisé et asynchrone de contrôle de version. Cela signifie qu'outre le fait qu'on édite ses fichiers sur des copies locales, on n'a pas besoin d'être connecté en continu au dépôt distant. On peut faire les modifications et les soumettre plus tard. 

Bien qu'il soit possible d'avoir une utilisation hors-ligne de `Git`, 
c'est-à-dire un pur contrôle de version local sans dépôt
distant, cela est une utilisation
rare et qui comporte un intérêt limité. L'intérêt de `Git` est
d'offrir une manière robuste et efficace d'interagir avec un 
dépôt distant facilitant ainsi la collaboration en équipe ou en
solitaire. 

::: {.tip}
## Pourquoi `Github` ?

Pour ces exercices, il est proposé
d'utiliser `Github`, la forge la plus visible[^1]. 
L'avantage de `Github` par rapport à son principal concurrent, `Gitlab`,
est que le premier est plus visible, car
mieux indexé par `Google` et concentre, en partie pour des raisons historiques, plus
de développeurs `Python` et `R` (ce qui est important dans des domaines comme
le code où les externalités de réseau jouent). 

[^1]: L'avantage que comportait `Gitlab` par rapport à `Github` 
à une époque, à savoir la possibilité de disposer gratuitement de ressources
pour faire de l'intégration continue, n'existe plus depuis que `Github`
a lancé son service `Github Actions`. Cependant, être familiarisé à 
l'environnement `Gitlab` reste utile car beaucoup de forges logicielles
internes reposent sur les fonctionalités _open-source_ (l'interface graphique
en faisant parti) de `Gitlab`. Il est donc fort utile de maîtriser 
les fonctionalités coeur de ces deux interfaces qui sont en fait quasi-identiques. Cela tombe bien, c'est l'objet de ce chapitre et du suivant.
:::


### S'authentifier à `Github` avec un jeton: principe

`Git` est un système décentralisé de contrôle de version :
les codes sont modifiés par chaque personne sur son poste de travail,
puis sont mis en conformité avec la version collective disponible
sur le dépôt distant au moment où le contributeur le décide.

Il est donc nécessaire que la forge connaisse l’identité de chacun des
contributeurs, afin de déterminer qui est l’auteur d’une modification apportée
aux codes stockés dans le dépôt distant.
Pour que `Github` reconnaisse un utilisateur proposant des modifications,
il est nécessaire de s’authentifier (un dépôt distant, même public, ne peut pas être modifié par n’importe qui). L’authentification consiste ainsi à fournir un élément que seul vous et la forge êtes censés connaître : un mot de passe, une clé compliquée, un jeton d’accès...

Plus précisément, il existe deux modalités pour faire connaître son identité à `Github` :

* une __authentification HTTPS__ (décrite ici) : l’authentification se fait avec un login et un mot de passe ou avec un _token_ (un mot de passe compliqué généré automatiquement par `Github` et connu exclusivement du détenteur du compte `Github`)  ;
* une __authentification SSH__ : l’authentification se fait par une clé cryptée disponible sur le poste de travail et que `GitHub` ou `GitLab` connaît. Une fois configurée, cette méthode ne nécessite plus de faire connaître son identité : l’empreinte digitale que constitue la clé suffit à reconnaître un utilisateur. Ce n'est pas la méthode que nous appliquerons ici[^ssh-utilitr].

[^ssh-utilitr]: La [documentation collaborative `utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_configurer_git.html#interaction-avec-un-d%C3%A9p%C3%B4t-distant-principe) présente les raisons pour lesquelles il convient de favoriser
la méthode HTTPS sur la méthode SSH. 

::: {.note}
## Note sur la double authentification

Depuis Août 2021, `Github` n'autorise plus l'authentification par mot de passe
lorsqu'on interagit (`pull`/`push`) avec un dépôt distant
([raisons ici](https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/)).
Il est nécessaire d'utiliser un *token* (jeton d'accès) qui présente l'avantage
d'être révoquable (on peut à tout moment supprimer un jeton si, par exemple,
on suspecte qu'il a été diffusé par erreur) et à droits limités 
(le jeton permet certaines opérations standards mais
n'autorise pas certaines opérations déterminantes comme la suppression
d'un dépôt).

GitHub commencera progressivement à exiger que tous les utilisateurs de GitHub activent une ou plusieurs formes d'authentification à deux facteurs (2FA). Pour plus d’informations sur le déploiement de l’inscription 2FA, consultez [cet article de blog](https://github.blog/2023-03-09-raising-the-bar-for-software-security-github-2fa-begins-march-13/). Concrètement, cela signifie que vous devrez au choix :

- Renseigner votre numéro de portable pour valider certaines connexions grâce à un code que vous recevrez par sms ;
- Installer une application d'authentification (Ex : Microsoft Authenticator) installée sur votre téléphone qui génèrera un QR code que vous pourrez scanner depuis github, ce qui ne nécessite pas que vous ayez à fournir votre numéro de téléphone
- Utiliser une clef USB de sécurité 

Pour choisir entre ces différentes options, vous pouvez vous rendre sur *Settings > Password and authentication > Enable two-factor authentication*.

:::

::: {.important}

Il est important de ne jamais stocker un _token_, et encore moins son mot de passe, dans un projet.
Il est possible de stocker un mot de passe ou *token* de manière sécurisée et durable
avec le *credential helper* de `Git`. Celui-ci est présenté par la suite.

S'il n'est pas possible d'utiliser le *credential helper* de `Git`, un mot de passe 
ou _token_ peut être stocké de manière sécurisé dans
un système de gestion de mot de passe comme [Keepass](https://keepass.fr/).

Ne jamais stocker un jeton `Github`, ou pire un mot de passe, dans un fichier
texte non crypté. Les logiciels de gestion de mot de passe
(comme [Keepass](https://keepass.fr/), recommandé par l'Anssi)
sont simples
d'usage et permettent de ne conserver sur l'ordinateur qu'une version
hashée du mot de passe qui ne peut être décryptée qu'avec un mot de passe
connu de vous seuls. 

:::

### Créer un jeton



## La _staging area_

Dans un monde sans `Git`, on écrit du code, on sauvegarde son script et parfois on considère que cette version vaut le coup d'être considérée comme une version de laquelle repartir. Avec `Git` c'est la même chose, seulement se principe sera formalisé plus proprement. 

Le premier niveau conceptuel est celui de l'index des modifications. Il s'agit des modifications en attente de validation, d'où le nom de _staging area_ dans la première partie de @fig-staging-area. 

![La gymnastique de `Git` dans son ensemble](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/completeworkflow.png){#fig-staging-area}

En principe, quand on édite des scripts ou _notebooks_, on enregistre régulièrement ceux-ci. Le niveau d'implication suivant est de mettre de côté une version particulière de ceux-ci, ce qu'à la main (voir la @version-control-inferno), nous ferions en dupliquant le fichier. Cela implique de mettre une ou plusieurs modifications dans la liste d'attente des modifications à valider. Cette opération s'appelle `git add` et est l'objet du prochain exercice. 


::: {.exercise}
## Exercice 3 : Indexer des modifications

1. Créer un dossier 📁 `scripts` depuis l'interface de `Jupyter`
2. Y créer les fichiers `script1.py` et `script2.py`, chacun contenant quelques commandes `Python` de votre choix (le contenu de ces fichiers n'est pas important).

Sur la session `Jupyter` d'`Onyxia`, si le `Clic Droit > rename` ne fonctionne pas, vous pouvez faire : `File > New > Text file` après vous être assurés que vous vous situez bien dans le dossier <nom_du_projet> de l'arborescence. Un fichier `untitled.txt` se crée. Vous pouvez le renommer,
en n'oubliant pas de changer l'extension en `.py`.

3. Se rendre dans l'extension `Git` de `Jupyter` ou de `VSCode`. Vous devriez
retrouver un cadre ayant cet aspect (à gauche pour `Jupyter` et à droite pour `VSCode`).

::: {#fig-status layout-ncol=2}

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git-status-ensae.png)

![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/git_vscode_1.png)

Interface graphique Git sous Jupyter (à gauche) et VSCode (à droite)
:::

En ligne de commande, c'est l'équivalent de 

```shell
git status
```

2. Sur `Jupyter`, en passant votre souris au dessus du nom des fichiers `script1.py` et
`script2.py`, vous devriez voir
un `+` apparaître. Cliquez dessus. Sur `VSCode`, un bouton `+` figure à droite du nom
du fichier `.script1.py` et
`.script2.py`.

Si vous aviez privilégié la ligne de commande, ce que vous avez fait est équivalent à :

~~~shell
git add scripts/script1.py
git add scripts/script2.py
~~~

Pour se remémorer ce que signifie `git add`, vous pouvez vous rendre
sur [ce cours dédié à `Git`](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/).

3. Observer le changement de statut du fichier après avoir cliqué sur `+`. Il est
désormais dans la partie `Staged`
En gros, vous venez de dire à Git que vous allez rendre publique une évolution
du fichier, mais vous ne l'avez pas encore fait (`Staged` est une liste d'attente).

Si vous étiez en ligne de commande vous auriez ce résultat après un `git status`

```raw
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   .gitignore
```


Les nouvelles modifications (en
l'occurrence la création du fichier et la validation de son contenu actuel)
ne sont pas encore archivées. Pour cela, il va falloir faire un 
`commit` (on rend publique une modification)

4. Avant cela, regardons les modifications qu'on va prochainement
valider. Pour cela, passez la souris au dessus du nom du fichier
`.gitignore` et cliquer sur le bouton `Diff this file` (+ -).
Une page s'ouvre et met en regard la version antérieure avec
les ajouts en vert et les suppressions en rouge. Nous retrouverons
cette visualisation avec l'interface `Github`, plus tard. 

En l'occurrence, comme le fichier n'existait pas, normalement nous n'avons que
des ajouts.

Il est également possible d'effectuer cela avec la ligne de commande mais c'est
beaucoup moins pratique. Pour cela, la commande à appeler est `git diff` et
il est nécessaire d'utiliser l'option `cached` pour lui dire d'inspecter les
fichiers pour lesquels on n'a pas encore effectué de `commit`. En vert
apparaîtront les modifications et en rouge les suppressions mais, cette fois,
les résultats ne seront pas mis côte-à-côte ce qui est beaucoup moins
pratique.

```shell
git diff --cached
```


:::





## Dépôt local et distant

Pour comprendre le principe de `Git`, il est utile de distinguer
deux niveaux: le dépôt 

`Git` est un système décentralisé et asynchrone de gestion de version. 
Cela signifie que:

* Chaque membre d'un projet travaille sur une copie locale du dépôt
(système *decentralisé*). Cette copie de travail s'appelle un `clone`.
Cela signifie qu'on n'a pas une cohérence en continu de notre version
de travail avec le dépôt ; on peut très bien ne jamais vouloir les
mettre en cohérence (par exemple, si on teste une piste qui s'avère
infructueuse) ;
* C'est lorsqu'on propose la publication de modifications sur le dépôt
collectif qu'on doit s'assurer de la cohérence avec la version disponible
en ligne (système *asynchrone*).

Le dépôt distant est généralement stocké sur
une **forge  logicielle** (`Github` ou `Gitlab`) et sert à centraliser la version
collective d'un projet. Les copies locales sont des copies de travail
qu'on utilise pour faire évoluer un projet :


Il est tout à fait possible de faire du contrôle de version sans
mettre en place de dépôt distant. Cependant, 

* c'est dangereux puisque le dépôt distant fait office de sauvegarde 
d'un projet. Sans dépôt distant, on peut tout perdre en cas de problème
sur la copie locale de travail ;
* c'est désirer être moins efficace car, comme nous allons le montrer, les
fonctionalités des plateformes `Github` et `Gitlab` sont également très 
bénéfiques lorsqu'on travaille tout seul. 

## Principe


Les trois manipulations les plus courantes sont les suivantes et représentées sur le diagramme ci-après :

* `commit` : je valide les modifications que j'ai faites en local avec un message qui les explique
* `pull` : je récupère la dernière version des codes du dépôt distant
* `push` : je transmets mes modifications validées au dépôt distant

![](https://gitlab.com/linogaliana/collaboratif/-/raw/main/pics/03_git/push_pull_Drees.png)

Les deux dernières manipulations correspondent aux interactions (notamment
la mise en cohérence) avec
le dépôt commun alors que la première manipulation `commit` correspond à
la modification des fichiers faite pour faire évoluer un projet. 

De manière plus précise, il y a trois étapes avant d'envoyer les modifications validées (`commit`) au dépôt. Elles se définissent en fonction des commandes qui permettent de les appliquer quand Git est utilisé en lignes de commandes :

* `diff` : inspection des modifications. Cela permet de comparer les fichiers modifiés et de distinguer les fichiers ajoutés ou supprimés.
* `staging area` : sélection des modifications.
* `commit` : validation des modifications sélectionnées (avec commentaire).

![](https://gitlab.com/linogaliana/collaboratif/-/raw/main/pics/03_git/trois_%C3%A9tats_fichier.png)


Lors des étapes de `push` et `pull`, des **conflits** peuvent apparaître, par exemple lorsque deux personnes ont modifié le même programme simultanément. Le terme conflit peut faire peur mais en fait c'est 
l'un des apports principaux de `Git` que de faciliter énormément la gestion
de versions différentes. Les exercices du chapitre suivant l'illustreront.  

## Les branches


C'est une des fonctionnalités les plus pratiques de la gestion de version. 
La création de `branches` dans un projet (qui devient ainsi un arbre)
permet de développer en parallèle des correctifs ou une nouvelle fonctionnalité
sans modifier le dépôt commun.

Cela permet de séparer le nouveau développement et de faire cohabiter plusieurs versions, pouvant évoluer séparément ou pouvant être facilement rassemblées. Git est optimisé pour le travail sur les branches.

Dans un projet collaboratif, une branche dite **master** joue le rôle du tronc.
C'est autour d'elle que vont pousser ou se greffer les branches.
L'un des avantages de `Git` est qu'on peut toujours revenir en arrière. Ce
filet de sécurité permet d'oser des expérimentations, y compris au sein
d'une branche. Il faut être prêt à aller dans la ligne de commande pour cela
mais c'est extrêmement confortable. 

::: {.cell .markdown}
```{=html}
<div class="alert alert-info" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-comment"></i> Note</h3>
```

Comment nommer les branches ? Là encore, il y a énormément de conventions différentes. Une fréquemment observée est :

- pour les nouvelles fonctionnalités : `feature/nouvelle-fonctionnalite` où `nouvelle-fontionnalite` est un nom court résumant la fonctionnalité
- pour les corrections de bug : `issue-num` où `num` est le numéro de l'issue

N'hésitez pas à aller encore plus loin dans la normalisation  !

```{=html}
</div>
```
:::



# Conseil de praticien : ne pas négliger le `.gitignore`

Un fichier à ne pas négliger est le `.gitignore`. Il s'agit d'un garde-fou car tous les fichiers (notamment des
données, potentiellement volumineuses ou confidentielles) n'ont pas vocation
à être partagés.

Le site [gitignore.io](https://www.toptal.com/developers/gitignore) est très pratique. Le fichier
suivant est par exemple proposé pour les utilisateurs de `Python`, auquel on peut ajouter
quelques lignes adaptées aux utilisateurs de données :

<details>
<summary>

Exemple de `.gitignore` pour les utilisateurs de données

</summary>

```markdown
"""
~~~raw
*.html
*.pdf
*.csv
*.tsv
*.json
*.xml
*.shp
*.xls
*.xlsx

### Python ###
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a Python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/
~~~
"""
)
```

</details>