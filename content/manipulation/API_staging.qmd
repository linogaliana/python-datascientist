

::: {.content-visible when-profile="fr"}
# Gestion des secrets et des exceptions

Nous avons déjà utilisé plusieurs API. Néanmoins ces dernières étaient toutes sans authentification et présentent peu de restrictions, hormis le nombre d'échos. Ce n'est pas le cas de toutes les API. Il est fréquent que les API qui permettent d'aspirer plus de données ou d'accéder à des données confidentielles nécessitent une authentification pour tracer les utilisateurs de données.

Cela se fait généralement par le biais d'un _token_. Ce dernier est une sorte de mot de passe, souvent utilisé dans les systèmes modernes d'authentification pour certifier de l'identité d'un utilisateur.trice (cf. [chapitre `Git`](/content/git/introgit.qmd)).

Pour illustrer l'usage des _tokens_, nous allons utiliser une API de l'Insee. Nous allons utiliser cette API pour récupérer des informations supplémentaires sur nos établissements à partir de leur code SIREN.

Avant d'en arriver là, nous allons faire un aparté sur la confidentialité des tokens et la manière d'éviter de révéler ceux-ci dans votre code.
:::

::: {.content-visible when-profile="en"}
# Managing Secrets and Exceptions

We have already used several APIs. However, these APIs were all without authentication and had few restrictions, except for the number of calls. This is not the case for all APIs. It is common for APIs that allow access to more data or confidential information to require authentication to track data users.

This is usually done through a _token_. A token is a kind of password often used in modern authentication systems to certify a user's identity (see [Git chapter](/content/git/introgit.qmd)).

To illustrate the use of _tokens_, we will use an API from Insee, French national statistical institute. We will use this API to retrieve entreprise level data from an exhaustive registry.  

Before diving into this, we will take a detour to discuss token confidentiality and how to avoid exposing tokens in your code.
:::

:::: {.content-visible when-profile="fr"}
## Utiliser un token dans un code sans le révéler

Les tokens sont des informations personnelles qui ne doivent pas être partagées. Ils n'ont pas vocation à être présent dans le code. Comme ceci est évoqué à plusieurs reprises dans le cours de [mise en production](https://ensae-reproductibilite.github.io/website/) que Romain Avouac et moi donnons en 3e année, il est important de séparer le code des éléments de configuration

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/environment_clean.png)

L'idée est de trouver une recette pour apporter les éléments de configuration avec le code mais sans mettre ceux-ci en clair dans le code. L'idée générale sera de stocker la valeur du _token_ dans une variable mais ne jamais révéler celle-ci dans le code. Comment faire dès lors pour déclarer la valeur du jeton sans que celui-ci soit apparent dans le code ?

* Pour un code amené à fonctionner de manière interactive (par exemple par le biais d'un _notebook_), il est possible de créer une boite de dialogue qui injectera la valeur renseignée dans une variable. Cela se fait par le biais du package `getpass`.
* Pour le code qui tourne en non interactif, par exemple par le biais de la ligne de commande, l'approche par variable d'environnement est la plus fiable, à condition de faire attention à ne pas mettre le fichier de mot de passe dans `Git` {{< fa brands git-alt >}}. Pour cela, le plus simple est d'utiliser [`dotenv`](https://pypi.org/project/python-dotenv/) si vous faites tourner votre code ou des [secrets](https://docs.github.com/fr/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions) si votre code tourne de manière automatisée sur des serveurs _cloud_.

::: {.important}
Il ne faut jamais mettre de _token_ dans `Git`. Sinon, vous courrez le risque d'avoir votre identité usurpée : des robots scannent en continu  `Github` à la recherche de jetons pour ensuite lancer des dénis de service en se faisant passer pour vous.

Si vous avez partagé par erreur un jeton : pas de panique, cela peut arriver ! L'avantage des jetons est qu'ils sont révocables : vous pouvez l'invalider et en créer un nouveau pour continuer à utiliser le service désiré. La bonne réaction consiste à révoquer le jeton le plus vite possible, une fois la fuite constatée. La meilleure parade pour éviter ce type de fuite est d'ajouter tout de suite le `.env` au `.gitignore`.
:::

L'exercice suivant permettra de découvrir comment ajouter de manière confidentielle un _payload_ à des requêtes d'authentification, c'est-à-dire des informations confidentielles identifiantes en complément d'une requête.
::::


## Comprendre le principe avec une documentation interactive


Pour illustrer l'utilisation des API authentifiées, nous proposons d'explorer le [portail des API](https://api.insee.fr/catalogue/) de l'Insee.

Nous allons nous concentrer sur l'API Sirene mais, sur ce portail, il en existe d'autres, notamment l'API Melodi consacrée à la récupération d'un certain nombre de sources _open data_ de l'Insee. L'API Sirene est une version interrogeable des données [Sirene _open data_](https://www.insee.fr/fr/information/3591226).

Avant d'aller dans `Python`, utilisons notre navigateur pour comprendre le principe de l'authentification. 

{{< include "04c_api/_exo4.qmd" >}}


## Récupération des données via `Python` {{< fa brands python >}}


Pour cette application, à partir de la question 4, nous allons avoir besoin de créer une classe spéciale permettant à `requests` de surcharger notre requête d'un jeton d'authentification. Comme elle n'est pas triviale à créer sans connaissance préalable, la voici:
:::

::: {.content-visible when-profile="en"}
## Using a Token in Code Without Revealing It

Tokens are personal information that should not be shared. They are not meant to be present in the code. As mentioned multiple times in the [production deployment course](https://ensae-reproductibilite.github.io/website/) taught by Romain Avouac and myself in the third year, it is crucial to separate the code from configuration elements.

![](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/slides/img/environment_clean.png)

The idea is to find a way to include configuration elements with the code without exposing them directly in the code. The general approach is to store the token value in a variable without revealing it in the code. How can we declare the token value without making it visible in the code?

* For interactive code (e.g., via a _notebook_), it is possible to create a dialog box that injects the provided value into a variable. This can be done using the `getpass` package.
* For non-interactive code, such as command-line scripts, the environment variable approach is the most reliable, provided you are careful not to include the password file in `Git`.

The following exercise will demonstrate these two methods. These methods will help us confidentially add a _payload_ to authentication requests, i.e., confidential identifying information as part of a request.

## Application

For this application, starting from question 4, we will need to create a special class that allows `requests` to override our request with an authentication token. Since it is not trivial to create without prior knowledge, here it is:
:::

```{python}
#| echo: true
#| label: bearer-token
class BearerAuth(requests.auth.AuthBase):
    def __init__(self, token):
        self.token = token
    def __call__(self, r):
        r.headers["authorization"] = "Bearer " + self.token
        return r
```

::: {.content-visible when-profile="fr"}
Nous allons aussi avoir besoin de cette variable qui correspond au Siren de Decathlon
:::

::: {.content-visible when-profile="en"}
We will also need this variable, which corresponds to Decathlon's Siren.
:::

```{python}
#| echo: true
siren = "500569405"
```

:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice 4: ajouter un _payload_ à une requête

1. Se créer un compte pour l'API de l'INPI (Institut national de la protection intellectuelle) qui nous servira à récupérer des bilans des comptes sociaux d'entreprises au format PDF.
2. Créer les variables `username` et `password` avec `getpass` en faisant en sorte de ne pas rentrer les valeurs dans le code.
3. En utilisant la [documentation de l'API](https://www.inpi.fr/sites/default/files/documentation%20technique%20API_comptes_annuels%20v4_0.pdf), l'argument `json` de `requests.post`, récupérer un jeton d'authentification et le stocker dans une variable `token`.
4. Récupérer les données en utilisant la _f-string_ `f'https://registre-national-entreprises.inpi.fr/api/companies/{siren}/attachments'` et en donnant à `requests` l'argument `auth=BearerAuth(token)`
5. Créer `identifier = documents.get('bilans')[0]['id']` et utiliser `requests` avec l'URL `f'https://registre-national-entreprises.inpi.fr/api/bilans/{identifier}/download'`, sans argument, pour récupérer un PDF. Cela a-t-il fonctionné ? Vérifier le _status code_. A quoi correspond-il ? Comment éviter cela ?
6. En supposant que l'objet `requests.get` créé s'appelle `r`, écrire l'output de notre API dans un PDF de la manière suivante:

```{.python}
binary_file_path = 'decathlon.pdf'
with open(binary_file_path, 'wb') as f:
    f.write(r.content)
```

7. Remplacer l'utilisation de `getpass` par l'approche variable d'environnement grâce à [`dotenv`](https://pypi.org/project/python-dotenv/)
:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Exercise 4: Adding a _payload_ to a request

1. Create an account for the INPI API (National Institute of Intellectual Property), which we will use to retrieve financial statements of companies in PDF format.
2. Create the `username` and `password` variables using `getpass`, ensuring the values are not hardcoded.
3. Using the [API documentation](https://www.inpi.fr/sites/default/files/documentation%20technique%20API_comptes_annuels%20v4_0.pdf) and the `json` argument of `requests.post`, retrieve an authentication token and store it in a variable `token`.
4. Retrieve the data using the _f-string_ `f'https://registre-national-entreprises.inpi.fr/api/companies/{siren}/attachments'` and provide `requests` with the argument `auth=BearerAuth(token)`.
5. Create `identifier = documents.get('bilans')[0]['id']` and use `requests` with the URL `f'https://registre-national-entreprises.inpi.fr/api/bilans/{identifier}/download'`, without arguments, to retrieve a PDF. Did it work? Check the _status code_. What does it mean? How can this be avoided?
6. Assuming the `requests.get` object created is named `r`, write the API output to a PDF as follows:

```{.python}
binary_file_path = 'decathlon.pdf'
with open(binary_file_path, 'wb') as f:
    f.write(r.content)
```

7. Replace the use of `getpass` with the environment variable approach using [`dotenv`](https://pypi.org/project/python-dotenv/).
:::

::::


```{python}
#| output: false
#| label: load-dotenv
import os
from dotenv import load_dotenv
load_dotenv()
```

```{python}
#| label: envvar
username = os.getenv("API_INPI_USERNAME")
password = os.getenv("API_INPI_PASSWORD")
```

```{python}
#| label: payload
import requests

url_login_api = "https://registre-national-entreprises.inpi.fr/api/sso/login"

payload = {
    "username": username,
    "password": password
}

response = requests.post(url_login_api, json=payload)
token = response.json().get('token')
```

```{python}
r = requests.get(
    f'https://registre-national-entreprises.inpi.fr/api/companies/{siren}/attachments',
    auth=BearerAuth(token)
)
documents = r.json()
```

```{python}
identifier = documents.get('bilans')[0]['id']
```

::: {.content-visible when-profile="fr"}
A la question 5, sans identifiant, on récupère le code erreur 401, qui correspond à _"Unauthorized"_, c'est-à-dire à une requête refusée. Néanmoins, si on ajoute le token comme précédemment, tout se passe bien, on récupère le bilan de Decathlon.
:::

::: {.content-visible when-profile="en"}
For question 5, without an identifier, we get the error code 401, which corresponds to _"Unauthorized"_, meaning the request is denied. However, if we add the token as before, everything works fine, and we retrieve Decathlon's financial statement.
:::

```{python}
#| output: false
#| label: request-get-status
r = requests.get(
    f'https://registre-national-entreprises.inpi.fr/api/bilans/{identifier}/download'
)
r.status_code
```

```{python}
#| label: request-get-authtoken
r = requests.get(
    f'https://registre-national-entreprises.inpi.fr/api/bilans/{identifier}/download',
    auth=BearerAuth(token)
)
```

```{python}
#| output: false
binary_file_path = 'decathlon.pdf'
with open(binary_file_path, 'wb') as f:
    f.write(r.content)
```

<details>

::: {.content-visible when-profile="fr"}
<summary>
Le PDF récupéré
</summary>
:::

::: {.content-visible when-profile="en"}
<summary>
The retrieved PDF
</summary>
:::

{{< pdf decathlon.pdf height="500px" width="800px">}}

</details>

:::: {.content-visible when-profile="fr"}

::: {.callout-important}
L'approche par variable d'environnement est la plus générale et malléable. Il faut néanmoins bien faire attention à ne pas oublier d'ajouter le `.env` stockant les identifiants dans `Git`. Autrement, vous risquez de révéler des informations identifiantes ce qui annule tout effet positif des bonnes pratiques mises en oeuvre avec `dotenv`.

Pour cela, la solution est simple : ajouter la ligne `.env` au `.gitignore` et par sécurité `*.env` au cas où le fichier ne soit pas à la racine du dépôt. Pour en savoir plus sur ce fichier `.gitignore`, se rendre sur les [chapitres `Git`](/content/git/index.qmd).
:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-important}
The environment variable approach is the most general and flexible. However, it is crucial to ensure that the `.env` file storing the credentials is not added to `Git`. Otherwise, you risk exposing identifying information, which negates any benefits of the good practices implemented with `dotenv`.

The solution is simple: add the `.env` line to `.gitignore` and, for extra safety, include `*.env` in case the file is not at the root of the repository. To learn more about the `.gitignore` file, refer to the [Git chapters](/content/git/index.qmd).
:::

::::


::: {.content-visible when-profile="fr"}
# Ouverture aux API de modèles

Nous avons vu jusqu'à présent des API de données. Celles-ci permettent de récupérer du code. Ce n'est néanmoins pas la seule utilisation des API intéressantes pour les utilisateurs de `Python`.

Il existe de nombreux autres types d'API. Parmi celles-ci, les API de modèles sont intéressantes. Elles permettent de récupérer des modèles pré-entraînés voire effectuer une phase d'inférence sur des serveurs spécialisés ayant plus de ressources que son ordinateur local (plus d'éléments dans les parties _machine learning_ et NLP). La librairie la plus connue dans ce domaine est la librairie [`transformers`](https://pypi.org/project/transformers/) développée par `HuggingFace`.

L'un des objectifs du [cours de 3A de mise en production](https://ensae-reproductibilite.github.io/website/) est de montrer comment ce type d'architecture logicielle fonctionne et comment celle-ci peut être créée sur des modèles que vous auriez vous-mêmes créés.
:::

::: {.content-visible when-profile="en"}
# Opening Up to Model APIs

So far, we have explored data APIs, which allow us to retrieve data. However, this is not the only interesting use case for APIs among `Python` users.

There are many other types of APIs, and model APIs are particularly noteworthy. They allow access to pre-trained models or even perform inference on specialized servers with more resources than a local computer (more details in the _machine learning_ and NLP sections). The most well-known library in this field is the [`transformers`](https://pypi.org/project/transformers/) library developed by `HuggingFace`.

One of the objectives of the [3rd-year production deployment course](https://ensae-reproductibilite.github.io/website/) is to demonstrate how this type of software architecture works and how it can be implemented for models you have created yourself.
:::



:::: {.content-visible when-profile="fr"}
# Exercices supplémentaires

::: {.callout-tip}
## Exercice bonus 1: et si on ajoutait des informations sur la valeur ajoutée des lycées ?

Dans notre exemple sur les écoles, se restreindre aux lycées et ajouter les informations sur la valeur ajoutée des lycées disponibles [ici](https://data.education.gouv.fr/explore/dataset/fr-en-indicateurs-de-resultat-des-lycees-denseignement-general-et-technologique/table/?sort=-annee).
:::

::::

:::: {.content-visible when-profile="en"}
# Additional Exercises: et si on ajoutait des informations sur la valeur ajoutée des lycées ?

::: {.callout-tip}
## Bonus Exercise

In our example on schools, limit the scope to high schools and add information on the added value of high schools available [here](https://data.education.gouv.fr/explore/dataset/fr-en-indicateurs-de-resultat-des-lycees-denseignement-general-et-technologique/table/?sort=-annee).
:::

::::


:::: {.content-visible when-profile="fr"}

::: {.callout-tip}
## Exercice bonus 2: on sort où ce soir ?

Trouver un lieu commun où se retrouver entre amis est toujours l'objet d'âpres négociations: et si on laissait guider par la géographie ?

1. Créer un `DataFrame` enregistrant une série d'adresses et de codes postaux comme l'exemple ci-dessous
2. Adapter le code de l'exercice sur l'API BAN, avec l'appui de la documentation, pour géolocaliser ces adresses
3. En supposant que vos données géolocalisées se nomment `adresses_geocoded`, utiliser le code proposé pour transformer celles-ci en polygone
4. Calculer le centroid et représenter sur une carte interactive `Folium` comme précédemment

Vous aviez oublié qu'il y avait un couple dans le groupe... Tenir compte de la variable `poids` pour calculer le barycentre et trouver où vous retrouver ce soir.

<details>

<summary>
Créer le polygone à partir des géolocalisations
</summary>

```{.python}
from shapely.geometry import Polygon
coordinates = list(zip(adresses_geocoded["longitude"], adresses_geocoded["latitude"]))
polygon = Polygon(coordinates)

polygon = gpd.GeoDataFrame(index=[0], crs="epsg:4326", geometry=[polygon])
polygon
```

</details>

:::

::::

:::: {.content-visible when-profile="en"}

::: {.callout-tip}
## Bonus Exercise 2: Where are we going out tonight?

Finding a common place to meet friends is always a subject of tough negotiations. What if we let geography guide us?

1. Create a `DataFrame` recording a series of addresses and postal codes, like the example below.
2. Adapt the code from the exercise on the BAN API, using its documentation, to geolocate these addresses.
3. Assuming your geolocated data is named `adresses_geocoded`, use the proposed code to transform them into a polygon.
4. Calculate the centroid and display it on an interactive `Folium` map as before.

You forgot there’s a couple in the group... Take into account the `poids` variable to calculate the barycenter and find out where to meet tonight.

<details>
<summary>
Create the polygon from the geolocations
</summary>

```{.python}
from shapely.geom
etry import Polygon
coordinates = list(zip(adresses_geocoded['longitude'], adresses_geocoded['latitude']))
polygon = Polygon(coordinates)

polygon = gpd.GeoDataFrame(index=[0], crs='epsg:4326', geometry=[polygon])
polygon
```

</details>

:::

::::

::: {.content-visible when-profile="fr"}
Le DataFrame d'exemple:
:::

::: {.content-visible when-profile="en"}
The example DataFrame:
:::

```{python}
#| echo: true
adresses_text = pd.DataFrame(
  {
    "adresse": [
        "10 Rue de Rivoli",
        "15 Boulevard Saint-Michel",
        "8 Rue Saint-Honoré",
        "20 Avenue des Champs-Élysées",
        "Place de la Bastille",
    ],
    "cp": ["75004", "75005", "75001", "75008", "75011"],
    "poids": [2, 1, 1, 1, 1]
})
adresses_text
```

```{python}
#| label: location-api-send
import pathlib
output_path = pathlib.Path("data/output")
output_path.mkdir(parents=True, exist_ok=True)
csv_file = output_path / "bpe_before_geoloc.csv"

adresses_text.loc[:, ["adresse", "poids", "cp"]].to_csv(csv_file, index=False)

params = {
    "columns": ["adresse"],
    "postcode": "cp",
    "result_columns": ["result_score", "latitude", "longitude"],
}

response = requests.post(
        "https://api-adresse.data.gouv.fr/search/csv/",
        data=params,
        files={"data": open(csv_file, "rb")},
    )
```

```{python}
adresses_geocoded = pd.read_csv(io.StringIO(response.text))
adresses_geocoded
```

::: {.content-visible when-profile="fr"}
La géolocalisation obtenue pour cet exemple
:::

::: {.content-visible when-profile="en"}
The geolocation obtained for this example
:::


```{python}
#| label: compute-barycenter
from shapely.geometry import Polygon
coordinates = list(zip(adresses_geocoded['longitude'], adresses_geocoded['latitude']))
polygon = Polygon(coordinates)

polygon = gpd.GeoDataFrame(index=[0], crs='epsg:4326', geometry=[polygon])
```

```{python}
#| output: false
import folium

gdf_points = gpd.GeoDataFrame(
    adresses_geocoded,
    geometry=gpd.points_from_xy(adresses_geocoded.longitude, adresses_geocoded.latitude), crs="EPSG:4326"
)

total_weight = adresses_geocoded['poids'].sum()
barycenter_x = (adresses_geocoded['longitude'] * adresses_geocoded['poids']).sum() / total_weight
barycenter_y = (adresses_geocoded['latitude'] * adresses_geocoded['poids']).sum() / total_weight

# Affichage des coordonnées du barycentre
barycenter = (barycenter_x, barycenter_y)
barycenter

# Calculate the centroid of the polygon
polygon_centroid = polygon.centroid

# Initialize a Folium map centered on the centroid
map_center = [polygon_centroid.y, polygon_centroid.x]
m = folium.Map(location=map_center, zoom_start=13)

# Add the polygon to the map
folium.GeoJson(polygon, name="Polygon").add_to(m)

# Add the points to the map
for _, row in gdf_points.iterrows():
    folium.Marker(
        location=[row.geometry.y, row.geometry.x],
        popup=row['adresse'],
    ).add_to(m)

# Add the centroid in red
folium.Marker(
    location=[barycenter_y, barycenter_x],
    popup="Barycentre",
    icon=folium.Icon(color="red")
).add_to(m)

# Met à jour le centroïde pour qu'il soit vert
folium.Marker(
    location=[polygon.centroid.y, polygon.centroid.x],
    popup="Centroid",
    icon=folium.Icon(color="green")
).add_to(m)
```

::: {.content-visible when-profile="fr"}
Voici la carte obtenue sur le jeu d'exemple. On sera peut-être plus au centre avec le barycentre qu'avec le centroid.
:::

::: {.content-visible when-profile="en"}
Here is the map obtained from the example dataset. We might have a better location with the barycenter than with the centroid.
:::

```{python}
m
```





