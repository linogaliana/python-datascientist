---
title: "Données spatiales : découverte de geopandas"
draft: false
weight: 40
slug: geopandas
tags:
  - geopandas
  - Velib
  - Tutoriel
  - Cartographie
  - Manipulation
categories:
  - Tutoriel
  - Manipulation
type: book
description: |
  Les données géolocalisées se sont multipliées depuis quelques années, qu'il
  s'agisse de données open-data ou de traces numériques géolocalisées de
  type _big-data_. Pour les données spatiales, le package `GeoPandas`
  étend les fonctionalités de l'écosystème `Pandas` afin de permettre
  de manipuler des données géographiques complexes de manière simple.
image: featured_geopandas_tutorial.png
eval: true
---




# Importer des données spatiales

Les formats les plus communs de données spatiales sont les suivants :

* _shapefile_ (`.shp`) : format (**propriétaire**) le plus commun de données géographiques.
La table de données (attributs) est stockée dans un fichier séparé des
données spatiales. En faisant `geopandas.read_file("monfichier.shp")`, le
package fait lui-même le lien entre les observations et leur représentation spatiale.
* _geopackage_ (`.gpkg`) : ce (relativement) nouveau format **libre** en un seul fichier également (lui recommandé par l'OGC) vise progressivement à se substituer au shapefile. Il est par exemple le format par défaut dans QGIS. 
* _geojson_ (`.json`) : ce format, non préconisé par l'OGC, est largement utilisé pour le développement _web_
comme dans la librairie `leaflet.js`.
La dimension spatiale est stockée dans le même fichier que les attributs.
Ces fichiers sont généralement beaucoup plus légers que les *shapefiles* mais possèdent des limites s'agissant de gros jeux de données. 
* _topojson_ (`.json`) : une variante du `geojson` qui se développe progressivement pour assister les visualisations _web_. Au lieu de stocker l'ensemble des points permettant de représenter une 
géométrie, seuls les arcs sont conservés. Cela allège substantiellement le poids du fichier et
permet, avec une librairie adaptée, de reconstruire l'ensemble des contours géographiques.

Cette [page](https://si.ecrins-parcnational.com/blog/2020-02-geojson-shapefile-geopackage.html) compare plus en détail les principes formats de données géographiques. 
L'aide de [`Geopandas`](https://geopandas.org/io.html) propose des bouts de code en fonction des différentes situations dans lesquelles on se trouve.

## Exemple : récupérer les découpages territoriaux

L'un des fonds de carte les plus fréquents qu'on utilise est celui des
limites administratives des communes.
Celui-ci peut être récupéré de plusieurs manières. 
En premier lieu, pour récupérer 
le fond de carte officiel, produit par l'IGN, sous 
le nom d'[`AdminExpress`](https://geoservices.ign.fr/adminexpress#telechargementCog)[^1],
il est possible de se rendre sur le site de l'IGN et de le télécharger. 
Il est également possible d'utiliser l'une des [API de l'IGN](https://api.gouv.fr/les-api/api_carto_cadastre)
mais ces dernières ne sont pas encore très documentées pour des utilisateurs
de `Python`.
Le package [`cartiflette`](https://github.com/InseeFrLab/cartiflette.git), issu
d'un projet interministériel, propose
une récupération 
facilitée de fonds de carte officiels de l'IGN. 
Ce projet vise à faciliter la récupération des sources officielles, notamment
celles de l'IGN, et leur association à des jeux de données géographiques.

::: {.cell .markdown}
```{=html}
<div class="alert alert-info" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-comment"></i> Note</h3>
```

Le package `cartiflette` est expérimental 
et n'est disponible que sur
[`Github`](https://github.com/InseeFrLab/cartiflette), pas sur `PyPi`.
Il est amené à évoluer rapidement et cette page sera mise à jour
quand de nouvelles fonctionalités (notamment l'utilisation d'`API`)
seront disponibles pour encore simplifier la récupération de
contours géographiques.

Pour installer `cartiflette`, il est nécessaire d'utiliser les commandes suivantes
depuis un `Jupyter Notebook` (si vous utilisez la ligne de commande directement,
vous pouvez retirer les `!` en début de ligne):

```{python}
#| eval: false
!pip install requests py7zr geopandas openpyxl tqdm s3fs PyYAML xlrd
!pip install git+https://github.com/inseefrlab/cartiflette
```

Ces commandes permettent de récupérer l'ensemble du code 
source depuis [`Github`](https://github.com/InseeFrLab/cartiflette)

```{=html}
</div>
```
:::


Ici, nous sommes intéressés par les contours des communes 
de la petite couronne. On pourrait désirer récupérer
l'ensemble de la région Ile-de-France mais nous
allons nous contenter de l'analyse de Paris intra-muros
et des départements limitrophes. 
C'est l'un des avantage de `cartiflette` que de faciliter
la récupération de fonds de carte sur un ensemble de département.
Cela évite la récupération d'un fond de carte très
volumineux (plus de 500Mo) pour une analyse restreinte (quelques départements).
Un autre avantage de `cartiflette` est de faciliter la récupération de fonds
de carte consolidés comme celui dont on a besoin ici : arrondissements 
dans Paris, communes ailleurs. Comme cela est expliqué dans un encadré à part,
il s'agirait d'une opération pénible à mettre en oeuvre sans `cartiflette`. 

Les contours de cet espace peuvent être récupérés de la manière suivante :

```{python}
#| output: false
from cartiflette import carti_download

shp_communes = carti_download(
    crs = 4326,
    values = ["75", "92", "93", "94"],
    borders="COMMUNE_ARRONDISSEMENT",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

```{python}
shp_communes.head(3)
```


On reconnaît la structure d'un `DataFrame` `Pandas`. A cette structure s'ajoute 
une colonne `geometry` qui enregistre la position des limites des polygones de chaque
observation. 

Comme vu précédemment, le système de projection est un élément important. Il permet à `Python`
d'interpréter les valeurs des points (deux dimensions) en position sur 
la terre, qui n'est pas un espace plan.

```{python}
shp_communes.crs
```

Ici, les données sont dans le système WGS84 (code EPSG 4326).
Ce n'est pas le
Lambert-93 comme on pourrait s'y attendre, ce dernier
étant le système légal de projection pour la France
métropolitaine. 

Pour s'assurer qu'on a bien récupéré les contours voulus, 
on peut représenter graphiquement
les contours grâce à la méthode `plot` sur laquelle nous
reviendrons :
 
```{python}
ax = shp_communes.boundary.plot()
ax.set_axis_off()
```

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Note</h3>
```

Si on ne désire pas utiliser le niveau `COMMUNE_ARRONDISSEMENT`,
il est nécessaire de mettre en oeuvre une construction du fond de
carte en plusieurs phases. C'est une opération un petit peu pénible, source d'erreur potentielle. Elle est illustrée ci-dessous mais il est donc recommandé de privilégier le niveau
`COMMUNE_ARRONDISSEMENT` qui a été construit pour cela. 

En premier lieu, il est nécessaire de récupérer le niveau des communes. 

```{python}
#| output: false
shp_communes = carti_download(
    crs = 4326,
    values = ["75", "92", "93", "94"],
    borders="COMMUNE",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

```{python}
shp_communes.head(4)
```

```{python}
ax = shp_communes.boundary.plot()
ax.set_axis_off()
```

On peut remarquer que la ville de Paris ne comporte pas d'arrondissements
sur cette carte. Pour vous en convaincre, vous pouvez exécuter la 
commande :

```{python}
ax = shp_communes.loc[shp_communes['INSEE_DEP']=="75"].boundary.plot()
ax.set_axis_off()
```

Il faut donc utiliser une source complémentaire.
Le contour officiel des arrondissements est
produit par l'IGN séparemment des contours de communes.
Les contours d'arrondissements sont également
disponibles 
grâce à `cartiflette`:

```{python}
arrondissements = carti_download(
    crs = 4326,
    values = ["75"],
    borders="COMMUNE_ARRONDISSEMENT",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

```{python}
ax = arrondissements.boundary.plot(alpha = 0.8, edgecolor = "k")
ax.set_axis_off()
```

Il ne reste plus qu'à remplacer Paris par
ses arrondissements dans `shp_communes`. 
Pour cela, on peut utiliser les méthodes
vues dans le chapitre `Pandas` relatives
aux filtres et à la concaténation
de plusieurs `DataFrames`:

```{python}
#| echo: true
import pandas as pd

shp_communes = pd.concat(
  [
    shp_communes.loc[shp_communes['INSEE_DEP'] != "75"].to_crs(2154),
    arrondissements.to_crs(2154)
  ])
```

```{python}
ax = shp_communes.boundary.plot(alpha = 0.8, edgecolor = "k")
ax.set_axis_off()
```

Cette approche fonctionne mais elle nécessite un certain nombre
de gestes, qui sont autant de risques d'erreurs. Il est
donc recommandé de privilégier le niveau `COMMUNE_ARRONDISSEMENT`
qui fait exactement ceci mais de manière fiable. 

```{=html}
</div>
```
:::

# Opérations sur les attributs et les géométries

## Import des données vélib

Souvent, le découpage communal ne sert qu'en fond de cartes, pour donner des
repères. En complément de celui-ci, on peut désirer exploiter
un autre jeu de données. On va partir des données de localisation des
stations velib, 
disponibles [sur le site d'open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/table/) et 
requêtables directement par l'url
<https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr>

```{python}
#| echo: true

velib_data = 'https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr'
stations = gpd.read_file(velib_data)
stations.crs
```

Les données sont dans le système de projection WGS84 qui est celui du
système GPS. Celui-ci s'intègre bien avec les fonds de carte 
`OpenStreetMap` ou `Google Maps`. En toute rigueur, si on
désire effectuer certains calculs géométriques (mesurer des surfaces...), il est
nécessaire de re-projeter les données dans un système qui préserve la géométrie
(c'est le cas du Lambert 93). 

Pour avoir une intuition de la localisation des stations, et notamment de la
densité hétérogène de celles-ci, 
on peut afficher les données sur la carte des communes
de la petite couronne. Il s'agit donc d'enrichir la carte
précédente d'une couche supplémentaire, à savoir la localisation
des stations. Au passage, on va utiliser un fond de carte
plus esthétique:

```{python}
#| echo: true

fig,ax = plt.subplots(figsize=(10, 10))
stations.sample(200).to_crs(3857).plot(ax = ax, color = 'red', alpha = 0.4, zorder=2)
shp_communes.to_crs(3857).plot(ax = ax, zorder=1, edgecolor = "black", facecolor="none",
                                                           color = None)
ctx.add_basemap(ax, source = ctx.providers.OpenStreetMap.Mapnik)
ax.set_axis_off()
```

```{python}
#| echo: false

fig = ax.get_figure()
fig.savefig("featured_geopandas_tutorial.png")
```

Découvrez ci-dessous par étape les différentes lignes de commandes permettant d'afficher cette carte complète,
étape par étape :

1️⃣ Afficher le nuage de points de 200 stations vélibs prises au hasard

```{python}
#| output: hide

fig, ax = plt.subplots(figsize=(10, 10))
stations.sample(200).to_crs(3857).plot(ax = ax, color = 'red', alpha = 0.4, zorder=2)
```

2️⃣ Ajouter à cette couche, en-dessous, les contours des communes

```{python}
#| output: false
#| echo: true

fig, ax = plt.subplots(figsize=(10, 10))
stations.sample(200).to_crs(3857).plot(ax = ax, color = 'red', alpha = 0.4, zorder=2)
shp_communes.to_crs(3857).plot(ax = ax, zorder=1, edgecolor = "black", facecolor="none",
                                                           color = None)
```

```{python}
#| echo: false
ax.get_figure()
```



3️⃣ Ajouter un fond de carte de type *open street map* grâce au package
`contextily`


```{python}
#| output: false
#| echo: true

fig,ax = plt.subplots(figsize=(10, 10))
stations.sample(200).to_crs(3857).plot(ax = ax, color = 'red', alpha = 0.4, zorder=2)
shp_communes.to_crs(3857).plot(ax = ax, zorder=1, edgecolor = "black", facecolor="none",
                                                           color = None)
ctx.add_basemap(ax, source = ctx.providers.OpenStreetMap.Mapnik)
```

```{python}
#| echo: false
ax.get_figure()
```


4️⃣
Il ne reste plus qu'à retirer l'axe des coordonnées, qui n'est pas très 
esthétique.

```{python}
#| output: false
#| echo: true

fig,ax = plt.subplots(figsize=(10, 10))
stations.sample(200).to_crs(3857).plot(ax = ax, color = 'red', alpha = 0.4, zorder=2)
shp_communes.to_crs(3857).plot(ax = ax, zorder=1, edgecolor = "black", facecolor="none",
                                                           color = None)
ctx.add_basemap(ax, source = ctx.providers.OpenStreetMap.Mapnik)
ax.set_axis_off()
ax
```

```{python}
#| echo: false
ax.get_figure()
```

*In fine*, on obtient la carte désirée. 


## Opérations sur les attributs

Toutes les opérations possibles sur un objet `Pandas` le sont également
sur un objet `GeoPandas`. Pour manipuler les données, et non la géométrie,
on parlera d'opérations sur les attributs. 

Par exemple, si on désire 
connaître quelques statistiques sur la taille des stations, l'approche
est identique à si on avait un objet `Pandas` classique :

```{python}
stations.describe()
```

Pour classer les départements de la petite couronne, du plus grand au plus petit,
procédons en deux étapes:

1. Récupérons le contour des communes
grâce à `cartiflette`.
Notons qu'on pourrait récupérer directement les contours départementaux mais
pour l'exercice, nous allons le créer nous-mêmes comme agrégation
des contours communaux
(voir plus bas ainsi que [ce notebook `Observable`](https://observablehq.com/@linogaliana/cartiflette-demo) pour la méthode plus
légère qui utilise pleinement les fonctionnalités de `cartiflette`). 

2. Calculons la surface totale de ce territoire (méthode `area` sur un objet `GeoPandas.GeoDataFrame` ramenée en km², attention néamoins au système de projection comme cela est expliqué plus bas)


```{python}
shp_communes['surface'] = shp_communes.area.div(10**6)
```

Les plus grands départements s'obtiennent par une agrégation des
surfaces communales :

```{python}
shp_communes.groupby('INSEE_DEP').sum(numeric_only = True).sort_values('surface', ascending = False)
```

Si on veut directement les plus
grandes communes de la petite couronne parisienne :

```{python}
shp_communes.sort_values('surface', ascending = False).head(10)
```

Lors des étapes d'agrégation, `groupby` ne conserve pas les géométries. Autrement
dit, si on effectue, par exemple, une somme en fonction d'une variable de groupe avec
le combo `groupby(...).sum(...)` , on perd
la dimension géographique. 

Il est néanmoins possible d'aggréger à la fois les géométries et les 
attribus avec la méthode `dissolve`: 

```{python}
fig,ax = plt.subplots(figsize=(10, 10))
shp_communes.dissolve(by='INSEE_DEP', aggfunc='sum').plot(ax = ax, column = "surface")
ax.set_axis_off()
ax
```

Pour produire l'équivalent de cette carte à un niveau France entière, il est néanmoins plus simple de directement
récupérer les fonds officiels des départements plutôt que d'agréger les
contours des communes:

```{python}
#| output: false
dep = carti_download(
    values = ["France"],
    crs = 4326,
    borders = "DEPARTEMENT",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
dep = dep.loc[dep["INSEE_DEP"].str.len() == 2]

dep["area"] = dep.to_crs(2154).area
```

Avant de calculer les surfaces des départements, pour éviter les déformations liées au
système `Mercator`, nous faisons une reprojection des données à la volée. Plus de détails
par la suite. 

```{python}
dep.sort_values('area', ascending = False).head(3)
```

```{python}
ax = dep.plot(column = "area")
ax.set_axis_off()
```


## Opérations sur les géométries


Outre la représentation graphique simplifiée,
sur laquelle nous reviendrons ultérieurement, l'intérêt principal d'utiliser
`GeoPandas` est l'existence de méthodes efficaces pour
manipuler la dimension spatiale. Un certain nombre proviennent du 
package
[`Shapely`](https://shapely.readthedocs.io/en/latest/manual.html#general-attributes-and-methods). 


::: {.cell .markdown}
```{=html}
<div class="alert alert-danger" role="alert">
<i class="fa-solid fa-triangle-exclamation"></i> Warning</h3>
```

Les données sont en système de coordonnées WGS 84 ou pseudo-Mercator (epsg: `4326`) et ne sont pas projetées.
C'est un format approprié lorsqu'il s'agit d'utiliser un fonds
de carte `OpenStreetMap`, `Stamen`, `Google Maps`, etc.

Mais ce n'est pas un
format sur lequel on désire faire des calculs car les distances sont faussées sans utiliser de projection. D'ailleurs, `geopandas` refusera certaines opérations
sur des données dont le crs est `4326`. On reprojette ainsi les données 
dans la projection officielle pour la métropole, le Lambert 93
(epsg: `2154`).

```{=html}
</div>
```
:::

Comme indiqué ci-dessus, nous reprojetons les données
dans le système Lambert 93 qui ne fausse pas les
calculs de distance et d'aires.

```{python}
communes = shp_communes.to_crs(2154)
stations = stations.to_crs(2154)
```

Par exemple, on peut recalculer la taille d'une commune ou d'arrondissement
avec la méthode `area` (et diviser par $10^6$ pour avoir des $km^2$ au lieu
des $m^2$):

```{python}
communes['superficie'] = communes.area.div(10**6)
communes.head(3)
```

Une méthode qu'on utilise régulièrement est `centroid` qui, comme son nom l'indique,
recherche le centroïde de chaque polygone et transforme ainsi des données
surfaciques en données ponctuelles. Par exemple, pour
représenter approximativement les centres des villages de la
Haute-Garonne (31), après avoir téléchargé le fonds de carte adapté,
fera

```{python}
communes_31 = carti_download(
      values = ["31"],
      crs = 4326,
      borders="COMMUNE",
      vectorfile_format="geojson",
      filter_by="DEPARTEMENT",
      source="EXPRESS-COG-CARTO-TERRITOIRE",
      year=2022)

# on reprojete en 3857 pour le fond de carte
communes_31 = communes_31.to_crs(3857)

# on calcule le centroide
dep_31 = communes_31.copy()
communes_31['geometry'] = communes_31['geometry'].centroid

ax = communes_31.plot(figsize = (10,10), color = 'red', alpha = 0.4, zorder=2)
dep_31.to_crs(3857).plot(ax = ax, zorder=1, edgecolor = "black", facecolor="none",
                                                           color = None)
#ctx.add_basemap(ax, source = ctx.providers.Stamen.Toner)
ax.set_axis_off()
ax
```


# Gérer le système de projection

Précédemment, nous avons appliqué une méthode `to_crs` pour reprojeter
les données dans un système de projection différent de celui du fichier
d'origine :

```{python}
communes = communes.to_crs(2154)
stations = stations.to_crs(2154)
```


Concernant la gestion des projections avec `GeoPandas`,
la [documentation officielle](https://geopandas.org/projections.html) est très bien
faite. Elle fournit notamment l'avertissement suivant qu'il est
bon d'avoir en tête :

> Be aware that most of the time you don’t have to set a projection. Data loaded from a reputable source (using the geopandas.read_file() command) should always include projection information. You can see an objects current CRS through the GeoSeries.crs attribute.
> 
> From time to time, however, you may get data that does not include a projection. In this situation, you have to set the CRS so geopandas knows how to interpret the coordinates.

![*Image empruntée à XKCD <https://xkcd.com/2256/> qu'on peut également trouver sur <https://blog.chrislansdown.com/2020/01/17/a-great-map-projection-joke/>*](https://imgs.xkcd.com/comics/bad_map_projection_south_america.png)


Pour déterminer le système de projection d'une base de données, on peut vérifier l'attribut `crs` :

```{python}
communes.crs
```

Les deux principales méthodes pour définir le système de projection utilisé sont :

* **`df.set_crs`** : cette commande sert à préciser quel est le système de projection utilisé, c'est-à-dire comment les coordonnées *(x,y)* sont reliées à la surface terrestre. **Cette commande ne doit pas être utilisée pour transformer le système de coordonnées, seulement pour le définir**. 
* **`df.to_crs`** : **cette commande sert à projeter les points d'une géométrie dans une autre, c'est-à-dire à recalculer les coordonnées selon un autre système de projection.** 

Dans le cas particulier de production de carte avec un fond `OpenStreetMaps` ou une carte dynamique `leaflet`, il est nécessaire de dé-projeter les données (par exemple à partir du Lambert-93) pour atterrir dans le système non-projeté WGS 84 (code EPSG 4326). Ce site [dédié aux projections géographiques](https://epsg.io/) peut être utile pour retrouver le système de projection d'un fichier où il n'est pas indiqué. 

La définition du système de projection se fait de la manière suivante (:warning: avant de le faire, se souvenir de l'avertissement !) :

~~~python
communes = communes.set_crs(2154)
~~~

Alors que la reprojection (projection Albers : `5070`) s'obtient de la manière suivante :

```{python}
shp_region = carti_download(
    values = ["France"],
    crs = 4326,
    borders = "REGION",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
shp_region = shp_region.loc[shp_region['INSEE_REG']>10]
fig,ax = plt.subplots(figsize=(10, 10))
shp_region.to_crs(5070).plot(ax = ax)
ax
```


```{python}
#| echo: false
ax.set_axis_off()
ax
plt.tight_layout(pad=0, h_pad = 0)
plt.show()
#plt.savefig('reproj1.png', bbox_inches='tight')
```

On le voit, cela modifie totalement la représentation de l'objet dans l'espace.
Clairement, cette projection n'est pas adaptée aux longitudes et latitudes françaises.
C'est normal, il s'agit d'une projection adaptée au continent 
nord-américain (et encore, pas dans son ensemble !).

```{python}
world = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))

fig,ax = plt.subplots(figsize=(10, 10))
world[world.continent == "North America"].to_crs(5070).plot(alpha = 0.2, edgecolor = "k", ax = ax)
ax
```


```{python}
#| echo: false

plt.tight_layout(pad=0, h_pad = 0)
plt.show()
#plt.savefig('reproj2.png', bbox_inches='tight')
```



# Joindre des données

## Joindre des données sur des attributs

Ce type de jointure se fait entre un objet géographique et un
deuxième objet, géographique ou non. A l'exception de la question 
des géométries, il n'y a pas de différence par rapport à `Pandas`. 

La seule différence avec `Pandas` est dans la dimension géographique.
Si on désire conserver la dimension géographique, il faut faire 
attention à faire :

~~~~python
geopandas_object.merge(pandas_object)
~~~~

Si on utilise deux objets géographiques mais ne désire conserver qu'une seule
dimension géographique[^2], on fera

~~~~python
geopandas_object1.merge(geopandas_object2)
~~~~

Seule la géométrie de l'objet de gauche
sera conservée, même si on fait un *right join*. 


[^2]: Il est techniquement possible d'avoir un `DataFrame` comportant plusieurs
géographies. Par exemple une géométrie polygone et une géométrie point
(le centroid). C'est néanmoins souvent compliqué à gérer et donc peu
recommandable.



## Prolongation possible : joindre des données sur dimension géographique

Le chapitre suivant permettra de mettre en oeuvre des 
jointures géographiques.


::: {.cell .markdown}
```{=html}
<div class="alert alert-warning" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-lightbulb"></i> Hint</h3>
```

Les jointures spatiales peuvent être très gourmandes en ressources (car il peut être nécessaire de croiser toutes les géométries de `x` avec toutes les géométries de `y`). Voici deux conseils qui peuvent vous aider :

- Il est préférable de tester les jointures géographiques sur un petit échantillon de données, pour estimer le temps et les ressources nécessaires à la réalisation de la jointure.
- Il est parfois possible d'écrire une fonction qui réduit la taille du problème. Exemple: vous voulez déterminer dans quelle commune se situe un logement dont vous connaissez les coordonnées et le département; vous pouvez écrire une fonction qui réalise pour chaque département une jointure spatiale entre les logements situés dans ce département et les communes de ce département, puis empiler les 101 tables de sorties.

```{=html}
</div>
```
:::

