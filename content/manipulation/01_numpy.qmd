---
title: "Numpy, la brique de base de la data science"
tags:
  - numpy
  - Tutoriel
  - Manipulation
categories:
  - Tutoriel
  - Manipulation
description: |
  `Numpy` constitue la brique de base de l'écosystème de la _data science_ en
  `Python`. Toutes les librairies de manipulation de données, de modélisation
  et de visualisation reposent, de manière plus ou moins directe, sur `Numpy`.
  Il est donc indispensable de revoir quelques notions sur ce package avant
  d'aller plus loin.
image: scatter_numpy.png
echo: false
---


::: {.content-visible when-format="html"}
{{< include "../../build/_switch_lang.qmd" >}}

Pour essayer les exemples présents dans ce tutoriel : 

{{< include "../../build/_printBadges.qmd" >}}
:::


::: {.content-visible when-format="ipynb"}
{{warninglang}}
:::

# Introduction

Ce chapitre constitue une introduction à _Numpy_ pour
s'assurer que les bases du calcul vectoriel avec `Python`
soient maîtrisées. La première partie du chapitre
présente des petits exercices pour pratiquer
quelques fonctions basiques de `Numpy`. La fin du chapitre présente
des exercices pratiques d'utilisation de `Numpy` plus approfondis.

Il est recommandé de régulièrement se référer à
la [_cheatsheet numpy_](https://www.datacamp.com/community/blog/python-numpy-cheat-sheet) et à la
[doc officielle](https://numpy.org/doc/stable/) en cas de doute
sur une fonction. 

Dans ce chapitre, on ne dérogera pas à la convention qui s'est imposée
d'importer `Numpy` de la
manière suivante :

```{python}
#| label: import-np
#| echo: true
import numpy as np
```

Nous allons également fixer la racine du générateur aléatoire de nombres
afin d'avoir des résultats reproductibles :

```{python}
#| echo: true
np.random.seed(12345)
```


::: {.note}

Les auteurs
de `numpy` [préconisent désormais](https://numpy.org/doc/stable/reference/random/index.html)
de privilégier l'utilisation de
générateurs via la fonction `default_rng()` plutôt que la simple utilisation de `numpy.random`.

Afin d'être en phase avec les codes qu'on peut trouver partout sur internet, nous 
conservons encore `np.random.seed` mais cela peut être amené à évoluer.

:::


# Le concept d'_array_

Dans le monde de la science des données, comme cela sera évoqué
plus en profondeur dans les prochains chapitres, 
l'objet central est le tableau à deux dimensions de données.
La première correspond aux lignes et la seconde aux colonnes. 
Si on ne se préoccupe que d'une dimension, on se rapporte 
à une variable (une colonne) de notre tableau de données. 
Il est donc naturel de faire le lien entre les
tableaux de données et l'objet mathématique
que sont les matrices et les vecteurs. 

`NumPy` (`Numerical Python`) est la brique de base
pour traiter des listes numériques ou des chaines
de textes comme des matrices.
`NumPy` intervient pour proposer
ce type d'objets, et
les opérations standardisées associées qui n'existent
pas dans le langage `Python` de base. 

L'objet central de `NumPy` est
l'**`array`** qui est un tableau de données multidimensionnel.
L'array `Numpy` peut être unidimensionnel et s'apparenter à un
vecteur (`1d-array`),
bidimensionnel et ainsi s'apparenter à une matrice (`2d-array`) ou,
de manière plus générale, 
prendre la forme d'un objet
multidimensionnel (`Nd-array`), sorte de tableau emboîté. 

Les tableaux simples (uni ou bi-dimensionnels) sont faciles à se représenter
et représentent la majorité des besoins liés à `Numpy`. 
Nous découvrirons lors du chapitre suivant, sur `Pandas`, qu'en pratique
on manipule rarement directement `Numpy` qui est une librairie
bas niveau. 
Un _DataFrame_ `Pandas` sera construit à partir d'une collection
d'array uni-dimensionnels (les variables de la table), ce qui permettra d'effectuer des opérations cohérentes
(et optimisées) avec le type de la variable.
Avoir quelques notions `Numpy` est utile pour comprendre
la logique de manipulation vectorielle
rendant les traitements sur des données plus lisibles,
plus efficaces et plus fiables.

Par rapport à une liste,

* un *array* ne peut contenir qu'un type de données (`integer`, `string`, etc.),
contrairement à une liste.
* les opérations implémentées par `Numpy` seront plus efficaces et demanderont moins
de mémoire

Les données géographiques constitueront une construction un peu plus complexe qu'un `DataFrame` traditionnel. 
La dimension géographique prend la forme d'un tableau plus profond, au moins bidimensionnel
(coordonnées d'un point). Néanmoins, les librairies de manipulation
de données géographiques permettront de ne pas se préoccuper de
cette complexité accrue.


## Créer un array

On peut créer un _array_ de plusieurs manières. Pour créer un _array_ à partir d'une liste,
il suffit d'utiliser la méthode `array`:

```{python}
#| echo: true
np.array([1,2,5])
```

Il est possible d'ajouter un argument `dtype` pour contraindre le type du *array* :

```{python}
#| echo: true
np.array([["a","z","e"],["r","t"],["y"]], dtype="object")
```


Il existe aussi des méthodes pratiques pour créer des array:

* séquences logiques : `np.arange` (suite) ou `np.linspace` (interpolation linéaire entre deux bornes)
* séquences ordonnées : _array_ rempli de zéros, de 1 ou d'un nombre désiré : `np.zeros`, `np.ones` ou `np.full`
* séquences aléatoires : fonctions de génération de nombres aléatoires : `np.rand.uniform`, `np.rand.normal`, etc. 
* tableau sous forme de matrice identité : `np.eye`

Ceci donne ainsi, pour les séquences logiques:

```{python}
#| echo: true
np.arange(0,10)
```

```{python}
#| echo: true
np.arange(0,10,3)
```

```{python}
#| echo: true
np.linspace(0, 1, 5)
```

Pour un _array_ initialisé à 0:

```{python}
#| echo: true
np.zeros(10, dtype=int)
```

ou initialisé à 1:

```{python}
#| echo: true
np.ones((3, 5), dtype=float)
```

ou encore initialisé à 3.14:

```{python}
#| echo: true
np.full((3, 5), 3.14)
```

Enfin, pour créer la matrice $I_3$:

```{python}
#| echo: true
np.eye(3)
```

{{< include "01_numpy_exercises/_exo1_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo1_solution.qmd" >}}


# Indexation et _slicing_

## Logique dans le cas d'un array unidimensionnel

La structure la plus simple est l'_array_ unidimensionnel:

```{python}
#| echo: true
x = np.arange(10)
print(x)
```

L'indexation est dans ce cas similaire à celle d'une liste: 

* le premier élément est 0
* le énième élément est accessible à la position $n-1$

La logique d'accès aux éléments est ainsi la suivante :

```python
x[start:stop:step]
```

Avec un *array* unidimensionnel, l'opération de *slicing* (garder une coupe du *array*) est très simple. 
Par exemple, pour garder les *K* premiers éléments d'un *array*, on fera:

```python
x[:(K-1)]
```

En l'occurrence, on sélectionne le K$^{eme}$ élément en utilisant

```python
x[K-1]
```

Pour sélectionner uniquement un élément, on fera ainsi:

```{python}
#| echo: true
x = np.arange(10)
x[2]
```

Les syntaxes qui permettent de sélectionner des indices particuliers d'une liste fonctionnent également
avec les _arrays_.

{{< include "01_numpy_exercises/_exo2_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo2_solution.qmd" >}}


```{python}
#| output: false

# Correction
x[[0,3,5]]
x[::2]
x[1:]
x[:5]
# x2[0,:] # La première ligne
```

## Sur la performance

Un élément déterminant dans la performance de `Numpy` par rapport aux listes,
lorsqu'il est question de 
*slicing* est qu'un array ne renvoie pas une
copie de l'élément en question (copie qui coûte de la mémoire et du temps)
mais simplement une vue de celui-ci.

Lorsqu'il est nécessaire d'effectuer une copie,
par exemple pour ne pas altérer l'_array_ sous-jacent, on peut 
utiliser la méthode `copy`:

```python
x_sub_copy = x[:2, :2].copy()
```



## Filtres logiques


Il est également possible, et plus pratique, de sélectionner des données à partir de conditions logiques
(opération qu'on appelle un __*boolean mask*__).
Cette fonctionalité servira principalement à 
effectuer des opérations de filtre sur les données.

Pour des opérations de comparaison simples, les comparateurs logiques peuvent être suffisants. 
Ces comparaisons fonctionnent aussi sur les tableaux multidimensionnels grâce au
*broadcasting* sur lequel nous reviendrons :

```{python}
#| echo: true
x = np.arange(10)
x2 = np.array([[-1,1,-2],[-3,2,0]])
print(x)
print(x2)
```

```{python}
#| echo: true
x==2
x2<0
```

Pour sélectionner les observations relatives à la condition logique,
il suffit d'utiliser la logique de *slicing* de `numpy` qui fonctionne avec les conditions logiques

{{< include "01_numpy_exercises/_exo3_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo3_solution.qmd" >}}


Lorsque c'est possible, il est recommandé d'utiliser les fonctions logiques de `numpy` (optimisées et 
qui gèrent bien la dimension).
Parmi elles, on peut retrouver:

* `count_nonzero` ;
* `isnan` ;
* `any` ou `all`, notamment avec l'argument `axis` ;
* `np.array_equal` pour vérifier, élément par élément, l'égalité.


Soit

```{python}
#| echo: true
x = np.random.normal(0, size=(3, 4))
```

un *array* multidimensionnel et

```{python}
#| echo: true
y = np.array([np.nan, 0, 1])
```

un *array* unidimensionnel présentant une valeur manquante. 

{{< include "01_numpy_exercises/_exo4_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo4_solution.qmd" >}}


# Manipuler un _array_


## Fonctions de manipulation

`Numpy` propose des méthodes ou des fonctions standardisées pour
modifier un array, voici un tableau en présentant quelques-unes:

| Opération | Implémentation |
|-----------|----------------|
| Aplatir un array | `x.flatten()` (méthode) |
| Transposer un array | `x.T` (méthode) ou `np.transpose(x)` (fonction) |
| Ajouter des éléments à la fin | `np.append(x, [1,2])` |
| Ajouter des éléments à un endroit donné (aux positions 1 et 2) | `np.insert(x, [1,2], 3)` |
| Supprimer des éléments (aux positions 0 et 3) | `np.delete(x, [0,3])` |

Pour combiner des array, on peut utiliser, selon les cas, 
les fonctions `np.concatenate`, `np.vstack` ou la méthode `.r_` (concaténation *rowwise*). 
`np.hstack` ou la méthode `.column_stack` ou `.c_` (concaténation *column-wise*)

```{python}
#| echo: true
x = np.random.normal(size = 10)
```

Pour ordonner un array, on utilise `np.sort`

```{python}
#| echo: true
x = np.array([7, 2, 3, 1, 6, 5, 4])

np.sort(x)
```

Si on désire faire un ré-ordonnement partiel pour trouver les _k_ valeurs les plus petites d'un `array` sans les ordonner, on utilise `partition`:

```{python}
#| echo: true
np.partition(x, 3)
```

## Statistiques sur un _array_

Pour les statistiques descriptives classiques,
`Numpy` propose un certain nombre de fonctions déjà implémentées,
qui peuvent être combinées avec l'argument `axis`

```{python}
#| echo: true
x = np.random.normal(0, size=(3, 4))
```


{{< include "01_numpy_exercises/_exo5_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo5_solution.qmd" >}}



# _Broadcasting_

Le *broadcasting* désigne un ensemble de règles permettant
d'appliquer des opérations sur des tableaux de dimensions différentes. En pratique, 
cela consiste généralement à appliquer une seule opération à l'ensemble des membres d'un tableau `numpy`. 

La différence peut être comprise à partir de l'exemple suivant. Le *broadcasting* permet
de transformer le scalaire `5` en *array* de dimension 3:

```{python}
#| echo: true
a = np.array([0, 1, 2])
b = np.array([5, 5, 5])

a + b
a + 5
```

Le *broadcasting* peut être très pratique pour effectuer de manière efficace des opérations sur des données à
la structure complexe. Pour plus de détails, se rendre
[ici](https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html) ou [ici](https://stackoverflow.com/questions/47435526/what-is-the-meaning-of-axis-1-in-keras-argmax).

## Une application: programmer ses propres k-nearest neighbors

```{python}
#| echo: false
lang = "fr"
```


{{< include "01_numpy_exercises/_exo6_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo6_solution.qmd" >}}


Ai-je inventé cet exercice corsé ? Pas du tout, il vient de l'ouvrage [_Python Data Science Handbook_](https://jakevdp.github.io/PythonDataScienceHandbook/02.08-sorting.html#Example:-k-Nearest-Neighbors). Mais, si je vous l'avais indiqué immédiatement, auriez-vous cherché à répondre aux questions ?

Par ailleurs, il ne serait pas une bonne idée de généraliser cet algorithme à de grosses données. La complexité de notre approche est $O(N^2)$. L'algorithme implémenté par `Scikit-Learn` est
en $O[NlogN]$.

De plus, le calcul de distances matricielles en utilisant la puissance des cartes graphiques serait plus rapide. A cet égard, la librairie [faiss](https://github.com/facebookresearch/faiss) ou les _frameworks_ spécialisés dans le calcul de distance entre des vecteurs à haute dimension comme [ChromaDB](https://www.trychroma.com/) 
offrent des performances beaucoup plus satisfaisantes que celles que permettraient `Numpy` sur ce problème précis.

# Exercices supplémentaires

{{< include "01_numpy_exercises/_exo7_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo7_solution.qmd" >}}


Le site 1 est assez central car il est référencé 2 fois. Le site
5 est lui également central puisqu'il est référencé par le site 1.

```{python}
v
```

