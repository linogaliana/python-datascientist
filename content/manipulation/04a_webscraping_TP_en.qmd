---
title: "Web scraping avec Python"
draft: false
weight: 60
slug: webscraping
tags:
  - Webscraping
  - BeautifulSoup
  - Exercice
  - Manipulation
categories:
  - Exercice
  - Manipulation
type: book
description: |
    `Python` makes it easy to retrieve a web page to extract and restructure data. Web scraping, which Canadians refer to as "web harvesting," is an increasingly popular way to gather large amounts of information in real-time. This chapter introduces the two main paradigms through `BeautifulSoup` and `Selenium`, and the main challenges of web scraping.
image: bulbasaur.jpg
echo: false
---

::: {.content-visible when-format="html"}
{{< include "../../build/_switch_lang.qmd" >}}

If you want to try the examples in this tutorial:

{{< include "../../build/_printBadges.qmd" >}}
:::


::: {.content-visible when-format="ipynb"}
{{warninglang}}
:::

[_Web scraping_](https://en.wikipedia.org/wiki/Web_scraping) refers to techniques for extracting content from websites. It is a very useful practice for anyone wanting to work with information available online that may not necessarily exist in an Excel table format.

This tutorial shows you how to create and run bots to quickly retrieve information useful for your current or future projects. It starts with a few concrete use cases. This chapter is heavily inspired and adapted from [Xavier Dupré's](http://www.xavierdupre.fr/app/ensae_teaching_cs/helpsphinx/notebooks/TD2A_Eco_Web_Scraping.html) chapter, the former professor of this course.

# Issues

A number of issues related to _web scraping_ will only be superficially discussed in this chapter.

## The legal grey area of _web scraping_

Firstly, regarding the legality of information retrieval through _scraping_, there is a gray area. Just because information is available on the internet, either directly or with some research, does not mean it can be retrieved and reused.

The excellent [course by Antoine Palazzolo](https://inseefrlab.github.io/formation-webscraping/) discusses several media and judicial cases on this question. In the French context, the CNIL published new guidelines in 2020 on *web scraping*, clarifying that no data can be reused without the knowledge of the person to whom these data belong. In other words, in principle, data collected by _web scraping_ are subject to the GDPR, meaning they require the consent of the individuals from whom the data is reused.

It is therefore recommended to __be cautious with the data retrieved__ by _web scraping_ to avoid legal issues.

## Stability and reliability of received information

While data retrieval through _web scraping_ is practical, it does not necessarily correspond to a usage envisioned or desired by a data provider. Data is expensive to collect and make available, and some sites may not want it to be extracted freely and easily. Especially when the data can provide a competitor with useful information from a commercial standpoint (e.g., competitor's product prices).

Therefore, actors often implement strategies to block or limit the amount of data scraped. The most common method is detecting and blocking requests made by robots rather than humans. For specialized actors, this detection is very easy as many indicators can identify whether a website visit comes from a human user behind a browser or a robot. A few examples of such indicators are: navigation speed between pages, speed of data extraction, the browser fingerprint used, ability to answer random questions (captcha), etc. The best practices discussed later aim to ensure that a robot behaves civilly by adopting behavior close to that of a human without pretending to be a human.

Moreover, caution should be exercised regarding information received through _web scraping_. Since data is at the heart of the economic model for some actors, some do not hesitate to send false data to robots rather than blocking them. It's fair game! Another trap technique is called the _honey pot_. These are pages that a human would never visit - for example, because they do not appear in the graphical interface - but on which a robot, in automatic content search, will get stuck.

Without going as far as the strategy of blocking _web scraping_, other reasons can explain why data retrieval may have worked in the past but no longer works. The most common is a change in the structure of a website. _Web scraping_ indeed has the disadvantage of fetching information from a highly hierarchical structure. A change in this structure can be enough to render a robot incapable of retrieving content. Moreover, to remain attractive, websites frequently change, which can easily make a robot inoperative.

In general, one of the main messages of this chapter to remember is that __web scraping is a last resort solution for occasional data retrievals without a guarantee of future operation__. It is preferable to __favor APIs when they are available__. These are more like a contract (formal or not) between a data provider and a user where needs (the data) as well as access conditions (number of requests, volume, authentication...) are defined, whereas _web scraping_ is closer to behavior in the _Far West_.

## Best practices

The ability to retrieve data through a robot does not mean one can afford to be uncivilized. Indeed, when uncontrolled, _web scraping_ can be like a classic cyber attack aimed at taking down a website: a denial of service attack. The [course by Antoine Palazzolo](https://inseefrlab.github.io/formation-webscraping/) reviews some good practices that have emerged in the scraping community. It is recommended to read this resource to learn more about this topic. Several conventions are mentioned, including:

- Go to the `robots.txt` file from the root of the site to check the instructions provided by the website developers to guide the behavior of robots;
- Space out each request by several seconds, as a human would, to avoid overloading the website and causing a denial of service;
- Make requests during off-peak hours if it is not an internationally visited website. For example, for a French site, running the robot during the night in mainland France is a good practice. To run a robot from `Python` at a pre-scheduled time, there are `cronjobs`.

# A detour to the web: how does a website work?

Even though this practical work does not aim to teach web development, you need some basics on how a website works to understand how information is structured on a page.

A website is a collection of pages coded in *HTML* that describe both the content and the form of a *Web* page.

To see this, open any web page and right-click on it.

- In `Chrome` <i class="fab fa-chrome"></i>: Then click on _"View page source"_ (<kbd>CTRL</kbd>+<kbd>U</kbd>);
- In `Firefox` <i class="fab fa-firefox"></i>: _"Page source"_ (<kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>K</kbd>);
- In `Edge` <i class="fab fa-edge"></i>: _"View page source"_ (<kbd>CTRL</kbd>+<kbd>U</kbd>);
- In `Safari` <i class="fab fa-safari"></i>: see how to do it [here](https://www.wikihow.com/View-Source-Code).

If you know which element interests you, you can also open the browser inspector (right-click on the element + "Inspect"), to display the tags surrounding your element more ergonomically, somewhat like a zoom.

## Tags

On a web page, you will always find elements such as `<head>`, `<title>`, etc. These are the codes that allow you to structure the content of an *HTML* page and are called **tags**. Examples of tags include `<p>`, `<h1>`, `<h2>`, `<h3>`, `<strong>`, and `<em>`.
The symbol ``< >`` is a tag: it indicates the beginning of a section. The symbol `</ >` indicates the end of this section. Most tags come in pairs, with an *opening tag* and a *closing tag* (for example, `<p>` and `</p>`).

For example, the main tags defining the structure of a table are as follows:

| Tag         | Description                        |
|-------------|------------------------------------|
| `<table>`   | Table                              |
| `<caption>` | Table title                        |
| `<tr>`      | Table row                          |
| `<th>`      | Header cell                        |
| `<td>`      | Cell                               |
| `<thead>`   | Table header section               |
| `<tbody>`   | Table body section                 |
| `<tfoot>`   | Table footer section               |

**Application: a table in HTML**

The `HTML` code for the following table:

```{html}
<table>
<caption> The title of my table </caption>

   <tr>
      <th>First name</th>
      <th>Last name</th>
      <th>Profession</th>
   </tr>
   <tr>
      <td>Mike</td>
      <td>Stuntman</td>
      <td>Stunt performer</td>
   </tr>
   <tr>
      <td>Mister</td>
      <td>Pink</td>
      <td>Gangster</td>
   </tr>
</table>
```

Will display in the browser as:

::: {.cell .markdown}
```{=html}
<table>
<caption> The title of my table </caption>

   <tr>
      <th>First name</th>
      <th>Last name</th>
      <th>Profession</th>
   </tr>
   <tr>
      <td>Mike</td>
      <td>Stuntman</td>
      <td>Stunt performer</td>
   </tr>
   <tr>
      <td>Mister</td>
      <td>Pink</td>
      <td>Gangster</td>
   </tr>
</table>
```
:::

### Parent and child

In the context of HTML language, the terms parent and child refer to nested elements. For example, in the following construction:

```html
<div> 
    <p>
       bla, bla
    </p>
</div>
```

On the web page, this will appear as follows:

::: {.cell .markdown}
```{=html}
<div> 
    <p>
       bla,bla
    </p>
</div>
```
:::

We will say that the `<div>` element is the parent of the `<p>` element while the `<p>` element is the child of the `<div>` element.



> *But why learn this for "scraping"?*

Because to properly retrieve information from a website, you need to understand its structure and thus its HTML code. The `Python` functions used for scraping are primarily designed to allow you to navigate between tags. With `Python`, you will essentially reproduce your manual search behavior to automate it.

# Scraping with `Python`: the `BeautifulSoup` package

## Available packages

In the first part of this chapter, we will primarily use the [`BeautifulSoup4`](https://www.crummy.com/software/BeautifulSoup/bs4/doc/) package, in conjunction with [`urllib`](https://docs.python.org/3/library/urllib.html#module-urllib) or `requests`. These latter packages allow you to retrieve the raw text of a page, which will then be inspected via [`BeautifulSoup4`](https://www.crummy.com/software/BeautifulSoup/bs4/doc/).

`BeautifulSoup` will be enough when you want to work on static HTML pages. As soon as the information you are looking for is generated via the execution of [JavaScript](https://en.wikipedia.org/wiki/JavaScript) scripts, you will need to use tools like [Selenium](https://selenium-python.readthedocs.io/).

Similarly, if you do not know the URL, you will need to use a framework like [Scrapy](https://scrapy.org/), which easily moves from one page to another. This technique is called _"web crawling"_. `Scrapy` is more complex to handle than `BeautifulSoup`: if you want more details, go to the [Scrapy tutorial](https://doc.scrapy.org/en/latest/intro/tutorial.html).

Web scraping is a field where reproducibility is difficult to achieve. A web page may potentially change regularly, and from one web page to another, the structure can be very different, making some codes difficult to export. Therefore, the best way to have a functional program is to understand the structure of a web page and separate elements that can be exported to other use cases from ad hoc requests.

```{python}
#| echo: true
!pip install -q lxml

import bs4
import lxml
import pandas
import urllib

from urllib import request
```

::: {.note}
To be able to use `Selenium`, it is necessary to make `Python` communicate with a web browser (Firefox or Chromium). The `webdriver-manager` package allows you to tell `Python` where this browser is located if it is already installed in a standard path. To install it, you can use the code in the cell below.
:::

To run `Selenium`, you need to use a package called `webdriver-manager`:

```{python}
#| echo: true
!pip install webdriver-manager
```

## Retrieving the content of an HTML page

Let's start slowly. Let's take a Wikipedia page, for example, the one for the 2019-2020 Ligue 1 football season: [2019-2020 Ligue 1](https://en.wikipedia.org/wiki/2019%E2%80%9320_Ligue_1). We will aim to retrieve the list of teams as well as the URLs of their respective Wikipedia pages.

Step 1️⃣: Connect to the Wikipedia page and get the source code.
The simplest way to do this is by using the `urllib` package or, better, `requests`.
Here, we will use the `request` function from the `urllib` package:

```{python}
#| echo: true
url_ligue_1 = "https://fr.wikipedia.org/wiki/Championnat_de_France_de_football_2019-2020"
    
request_text = request.urlopen(url_ligue_1).read()
# print(request_text[:1000])    
```

```{python}
#| echo: true
type(request_text)
```

Step 2️⃣: Use the BeautifulSoup package to efficiently search for tags within the string returned by the `request` function:

```{python}
#| echo: true
page = bs4.BeautifulSoup(request_text, "lxml")
```

If you print the `page` object created with `BeautifulSoup`, you will see that it is no longer a string but an actual HTML page with tags. You can now search for elements within these tags.

## The `find` method

For example, if you want to know the title of the page, you can use the `.find` method and ask for "title":

```{python}
#| echo: true
print(page.find("title"))
```

The `.find` method only returns the first occurrence of the element.

To verify this, you can:

- copy the source code snippet obtained when you search for a `table`,
- paste it into a notebook cell,
- and switch the cell to _"Markdown"_ mode.

The cell with the copied source code gives:

```{python}
#| echo: true
print(page.find("table"))
```

which is the source text used to generate the following table:

::: {.cell .markdown}
```{python}
#| echo: false
#| output: asis
print(page.find("table"))
```
:::

## The `findAll` method

To find all occurrences, use `.findAll()`.

```{python}
#| echo: true
print("There are", len(page.findAll("table")), "elements in the page that are <table> tags.")
```

# Guided exercise: Getting the list of Ligue 1 teams

In the first paragraph of the *"Participants"* section of the page, there is a table with the results of the year.

::: {.exercise}
## Exercise 1: Retrieve the participants of Ligue 1

To do this, we will proceed in 6 steps:

1. Find the table
2. Retrieve each row of the table
3. Clean the output by keeping only the text in a row
4. Generalize this for all rows
5. Retrieve the table headers
6. Finalize the table

:::

1️⃣ Find the table

```{python}
#| echo: true
# Identify the table in question: it's the first one with the "wikitable sortable" class
tableau_participants = page.find('table', {'class' : 'wikitable sortable'})
```

::: {.cell .markdown}
```{python}
#| echo: true
#| output: asis
print(tableau_participants)
```
:::

2️⃣ Retrieve each row of the table

First, we look for all the rows of the table with the `tr` tag:

```{python}
#| echo: true
table_body = tableau_participants.find('tbody')
rows = table_body.find_all('tr')
```

We get a list where each element is a row from the table.
To illustrate this, let's first display the first row, which corresponds to the column headers:

```{python}
#| echo: true
print(rows[0])
```

The second row corresponds to the row of the first club in the table:

```{python}
#| echo: true
print(rows[1])
```

3️⃣ Clean the output by keeping only the text in a row

We will use the `text` attribute to remove all the HTML layer obtained in step 2.

An example with the row of the first club:

- start by taking all the cells in this row with the `td` tag.
- then, loop through each cell and keep only the text of the cell with the `text` attribute.
- finally, apply the `strip()` method to ensure the text is well-formatted (without unnecessary spaces, etc.).


```{python}
#| echo: true
cols = rows[1].find_all('td')
print(cols[0])
print(cols[0].text.strip())
```

```{python}
#| echo: true
for ele in cols : 
    print(ele.text.strip())
```

4️⃣ Generalizing to all rows:

```{python}
#| echo: true
for row in rows:
    cols = row.find_all('td')
    cols = [ele.text.strip() for ele in cols]
    print(cols)
```

We successfully retrieved the information contained in the participant table of the championship. However, the first row is strange: it's an empty list...

This is because the headers are recognized by the `th` tag, not `td`.

We will put all the content into a dictionary, and then transform it into a pandas DataFrame:

```{python}
#| code-overflow: wrap
#| echo: true
dico_participants = dict()
for row in rows:
    cols = row.find_all('td')
    cols = [ele.text.strip() for ele in cols]
    if len(cols) > 0: 
        dico_participants[cols[0]] = cols[1:]
dico_participants
```

```{python}
#| echo: true
data_participants = pandas.DataFrame.from_dict(dico_participants, orient='index')
data_participants.head()
```

5️⃣ Retrieve the table headers:

```{python}
#| echo: true
for row in rows:
    cols = row.find_all('th')
    print(cols)
    if len(cols) > 0:
        cols = [ele.get_text(separator=' ').strip().title() for ele in cols]
        columns_participants = cols
```

```{python}
#| echo: true
columns_participants
```

6️⃣ Finalizing the table:

```{python}
#| echo: true
data_participants.columns = columns_participants[1:]
```

```{python}
#| echo: true
data_participants.head()
```

# Going further

## Retrieving stadium locations

Try to understand step by step what is done in the following steps (retrieving additional information by navigating through the pages of different clubs).


```{python}
#| echo: true
#| output: false

import urllib
import pandas as pd
import bs4 

division=[]
equipe=[]
stade=[]
latitude_stade=[]        
longitude_stade=[]     

url_list=["http://fr.wikipedia.org/wiki/Championnat_de_France_de_football_2019-2020", "http://fr.wikipedia.org/wiki/Championnat_de_France_de_football_de_Ligue_2_2019-2020"]

for url_ligue in url_list :
       
    print(url_ligue)
    sock = urllib.request.urlopen(url_ligue).read() 
    page=bs4.BeautifulSoup(sock)

# Rechercher les liens des équipes dans la liste disponible sur wikipedia 

    for team in page.findAll('span' , {'class' : 'toponyme'}) :  
        
        # Indiquer si c'est de la ligue 1 ou de la ligue 2
        
        if url_ligue==url_list[0] :
            division.append("L1")
        else :
            division.append("L2")

       # Trouver le nom et le lien de l'équipe
            
        if team.find('a')!=None :
            team_url=team.find('a').get('href')
            name_team=team.find('a').get('title')
            equipe.append(name_team)
            url_get_info = "http://fr.wikipedia.org"+team_url
            print(url_get_info)
 
       # aller sur la page de l'équipe
           
            search = urllib.request.urlopen(url_get_info).read()
            search_team=bs4.BeautifulSoup(search)

       # trouver le stade             
            compteur = 0
            for stadium in search_team.findAll('tr'):
                for x in stadium.findAll('th' , {'scope' : 'row'} ) :
                    if x.contents[0].string=="Stade" and compteur == 0:
                        compteur = 1
                        # trouver le lien du stade et son nom
                        url_stade=stadium.findAll('a')[1].get('href')
                        name_stadium=stadium.findAll('a')[1].get('title')
                        stade.append(name_stadium)
                        url_get_stade = "http://fr.wikipedia.org"+url_stade
                        print(url_get_stade)
                        
                        # Aller sur la page du stade et trouver ses coodronnées géographiques
                        
                        search_stade = urllib.request.urlopen(url_get_stade).read()
                        soup_stade=bs4.BeautifulSoup(search_stade) 
                        kartographer = soup_stade.find('a',{'class': "mw-kartographer-maplink"})
                        if kartographer == None :
                          latitude_stade.append(None)
                          longitude_stade.append(None) 
                        else :
                            for coordinates in kartographer :
                                print(coordinates)
                                liste =   coordinates.split(",")          
                                latitude_stade.append(str(liste[0]).replace(" ", "") + "'")
                                longitude_stade.append(str(liste[1]).replace(" ", "") + "'")
                            

dict = {'division' : division , 'equipe': equipe, 'stade': stade, 'latitude': latitude_stade, 'longitude' : longitude_stade}
data = pd.DataFrame(dict)
data = data.dropna()
```

```{python}
#| echo: true
data.head(5)
```


We will convert the coordinates from degrees to numerical coordinates to create a map.

```{python}
#| echo: true
import re

def dms2dd(degrees, minutes, seconds, direction):
    dd = float(degrees) + float(minutes)/60 + float(seconds)/(60*60)
    if direction in ('S', 'W'):
        dd *= -1
    return dd

def parse_dms(dms):
    parts = re.split('[^\d\w]+', dms)
    lat = dms2dd(parts[0], parts[1], parts[2], parts[3])
    return lat
```

```{python}
#| echo: true
data['latitude'] = data['latitude'].apply(parse_dms)
data['longitude'] = data['longitude'].apply(parse_dms)
```

At this point, everything is in place to create a nice map. We will use `folium` for this, which is presented in the [visualization](#cartotp) section.

## Map of stadiums with `folium` {#cartes-stades-ligue1}


```{python}
#| echo: true
#| output: false

import geopandas as gpd
from pathlib import Path
import folium

gdf = gpd.GeoDataFrame(
    data, geometry=gpd.points_from_xy(data.longitude, data.latitude))

Path("leaflet").mkdir(parents=True, exist_ok=True)

center = gdf[['latitude', 'longitude']].mean().values.tolist()
sw = gdf[['latitude', 'longitude']].min().values.tolist()
ne = gdf[['latitude', 'longitude']].max().values.tolist()

m = folium.Map(location = center, tiles='openstreetmap')

# I can add marker one by one on the map
for i in range(0,len(gdf)):
    folium.Marker([gdf.iloc[i]['latitude'], gdf.iloc[i]['longitude']], popup=gdf.iloc[i]['stade']).add_to(m) 

m.fit_bounds([sw, ne])
```


The resulting map should look like this:

```{python}
# Display the map
m
```

# Retrieving information about Pokémon

The next exercise to practice web scraping involves retrieving information about Pokémon from the [pokemondb.net](http://pokemondb.net/pokedex/national) website.

## Unguided version

::: {.exercise} 
## Exercise 2: Pokémon (unguided version)

For this exercise, you are asked to obtain various information about Pokémon:

1. Personal information for the __893__ Pokémon on the [pokemondb.net](http://pokemondb.net/pokedex/national) website.
The information we would like to obtain in a `DataFrame` are those contained in 4 tables:

- Pokédex data
- Training
- Breeding
- Base stats

2. We would also like you to retrieve the images of each Pokémon and save them in a folder.

* Small hint: use the `request` and [`shutil`](https://docs.python.org/3/library/shutil.html) modules.
* For this question, you will need to figure out some elements on your own, as not everything is covered in the exercise.
:::

For question 1, the goal is to obtain the source code of a table like the one below (for the Pokémon [Nincada](http://pokemondb.net/pokedex/nincada)).

::: {.cell .markdown}
<div class="grid-col span-md-6 span-lg-4">
<h2>Pokédex data</h2>
<table class="vitals-table">
<tbody>
<tr>
<th>National №</th>
<td><strong>290</strong></td>
</tr>
<tr>
<th>Type</th>
<td>
<a class="type-icon type-bug" href="/type/bug">Bug</a> <a class="type-icon type-ground" href="/type/ground">Ground</a> </td>
</tr>
<tr>
<th>Species</th>
<td>Trainee Pokémon</td>
</tr>
<tr>
<th>Height</th>
<td>0.5&nbsp;m (1′08″)</td>
</tr>
<tr>
<th>Weight</th>
<td>5.5&nbsp;kg (12.1&nbsp;lbs)</td>
</tr>
<tr>
<th>Abilities</th>
<td><span class="text-muted">1. <a href="/ability/compound-eyes" title="The Pokémon's accuracy is boosted.">Compound Eyes</a></span><br><small class="text-muted"><a href="/ability/run-away" title="Enables a sure getaway from wild Pokémon.">Run Away</a> (hidden ability)</small><br></td>
</tr>
<tr>
<th>Local №</th>
<td>042 <small class="text-muted">(Ruby/Sapphire/Emerald)</small><br>111 <small class="text-muted">(X/Y — Central Kalos)</small><br>043 <small class="text-muted">(Omega Ruby/Alpha Sapphire)</small><br>104 <small class="text-muted">(Sword/Shield)</small><br></td>
</tr>
</tbody>
</table>
</div>


<div class="grid-col span-md-12 span-lg-4">
<div class="grid-row">
<div class="grid-col span-md-6 span-lg-12">
<h2>Training</h2>
<table class="vitals-table">
<tbody>
<tr>
<th>EV yield</th>
<td class="text">
1 Defense </td>
</tr>
<tr>
<th>Catch rate</th>
<td>255 <small class="text-muted">(33.3% with PokéBall, full HP)</small></td>
</tr>
<tr>
<th>Base <a href="/glossary#def-friendship">Friendship</a></th>
<td>70 <small class="text-muted">(normal)</small></td>
</tr>
<tr>
<th>Base Exp.</th>
<td>53</td>
</tr>
<tr>
<th>Growth Rate</th>
<td>Erratic</td>
</tr>
</tbody>
</table>
</div>
<div class="grid-col span-md-6 span-lg-12">
<h2>Breeding</h2>
<table class="vitals-table">
<tbody>
<tr>
<th>Egg Groups</th>
<td>
<a href="/egg-group/bug">Bug</a> </td>
</tr>
<tr>
<th>Gender</th>
<td><span class="text-blue">50% male</span>, <span class="text-pink">50% female</span></td> </tr>
<tr>
<th><a href="/glossary#def-eggcycle">Egg cycles</a></th>
<td>15 <small class="text-muted">(3,599–3,855 steps)</small>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div class="grid-col span-md-12 span-lg-8">
<div id="dex-stats"></div>
<h2>Base stats</h2>
<div class="resp-scroll">
<table class="vitals-table">
<tbody>
<tr>
<th>HP</th>
<td class="cell-num">31</td>
<td class="cell-barchart">
<div style="width:17.22%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">172</td>
<td class="cell-num">266</td>
</tr>
<tr>
<th>Attack</th>
<td class="cell-num">45</td>
<td class="cell-barchart">
<div style="width:25.00%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">85</td>
<td class="cell-num">207</td>
</tr>
<tr>
<th>Defense</th>
<td class="cell-num">90</td>
<td class="cell-barchart">
<div style="width:50.00%;" class="barchart-bar barchart-rank-4 "></div>
</td>
<td class="cell-num">166</td>
<td class="cell-num">306</td>
</tr>
<tr>
<th>Sp. Atk</th>
<td class="cell-num">30</td>
<td class="cell-barchart">
<div style="width:16.67%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">58</td>
<td class="cell-num">174</td>
</tr>
<tr>
<th>Sp. Def

</th>
<td class="cell-num">30</td>
<td class="cell-barchart">
<div style="width:16.67%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">58</td>
<td class="cell-num">174</td>
</tr>
<tr>
<th>Speed</th>
<td class="cell-num">40</td>
<td class="cell-barchart">
<div style="width:22.22%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">76</td>
<td class="cell-num">196</td>
</tr>
</tbody>
<tfoot>
<tr>
<th>Total</th>
<td class="cell-total"><b>266</b></td>
<th class="cell-barchart"></th>
<th>Min</th>
<th>Max</th>
</tr>
</tfoot>
</table>
</div>
</div>
:::

For question 2, the goal is to obtain the Pokémon images.

## Guided version

The next sections will guide you step by step to complete the above exercise in a guided manner.

We first want to obtain the personal information of all Pokémon on [pokemondb.net](http://pokemondb.net/pokedex/national).

The information we want to get for the Pokémon is contained in 4 tables:

- Pokédex data
- Training
- Breeding
- Base stats

We then propose to retrieve and display the images.

### Step 1: Creating a DataFrame of characteristics

::: {.exercise}
## Exercise 2b: Pokémon (guided version)

To retrieve the information, the code will need to be divided into several steps:

1. Find the main page of the site and transform it into an intelligible object for your code.
The following functions will be useful:
- `urllib.request.Request`
- `urllib.request.urlopen`
- `bs4.BeautifulSoup`

2. Create a function that allows you to retrieve a Pokémon's page from its name.

3. From the `bulbasaur` page, obtain the 4 tables that interest us:
- Look for the element: `('table', { 'class' : "vitals-table"})`
- Then store its elements in a dictionary.

4. Retrieve the list of Pokémon names that will allow us to loop through later. How many Pokémon do you find?

5. Write a function that retrieves all the information on the first ten Pokémon on the list and integrates them into a `DataFrame`.

:::


```{python}
#| output: false

# 1. Find the main page of the site and transform it into an object that your code can understand.
import urllib
import bs4
import collections
import pandas as pd

# For the site we are using, the Python 3 user agent was not accepted:
# So we change it to Mozilla's user agent

req = urllib.request.Request('http://pokemondb.net/pokedex/national',
                             headers={'User-Agent': 'Mozilla/5.0'})
html = urllib.request.urlopen(req).read()
page = bs4.BeautifulSoup(html, "lxml")
#page.findAll('span', {'class': 'infocard-lg-img'})
```

```{python}
#| output: false

# 2. Create a function to retrieve a Pokémon's page by its name
#https://pokemondb.net/pokedex/bulbasaur

def get_page(pokemon_name):
    url_pokemon = 'http://pokemondb.net/pokedex/' + pokemon_name
    req = urllib.request.Request(url_pokemon, headers = {'User-Agent' : 'Mozilla/5.0'})
    html = urllib.request.urlopen(req).read()
    return bs4.BeautifulSoup(html, "lxml")

#get_page("bulbasaur")
```

```{python}
#| output: false

# 3. From Bulbasaur's page, get the 4 tables of interest and store them in a dictionary
#https://pokemondb.net/pokedex/bulbasaur

# Let's explore a bit
page_pokemon = get_page("bulbasaur")

table_index = 0 #first table: 0
print("\n table", table_index + 1, ": first two rows")
table_1 = page_pokemon.findAll('table', { 'class' : "vitals-table"})[table_index]
for elements in table_1.find('tbody').findChildren(['tr'])[0:2]:  #Display the first 2 elements of the table
    print(elements.findChild('th'))
    print(elements.findChild('td'))
print("\n\n\n")

# Automate: function to store in a dictionary
def get_pokemon_data(pokemon_name):
    page = get_page(pokemon_name)
    data = {}
    for table in page.findAll('table', { 'class' : "vitals-table"})[0:4]:
        table_body = table.find('tbody')
        for rows in table_body.findChildren(['tr']):
            if len(rows) > 1: # beware of tr elements that contain nothing
                column = rows.findChild('th').getText()
                cells = rows.findChild('td').getText()
                cells = cells.replace('\t', '').replace('\n', ' ')
                data[column] = cells
                data['name'] = pokemon_name
    return data
```

At the end of step 3, you should obtain a list of characteristics similar to this:

```{python}
get_pokemon_data("bulbasaur")
```

The structure is in a dictionary here, which is convenient.

```{python}
#| output: false

# 4. Retrieve the list of Pokémon names
pokemon_list = []
for pokemon in page.findAll('span', {'class': 'infocard-lg-img'}):
    pokemon = pokemon.find('a').get('href').replace("/pokedex/", '')
    pokemon_list.append(pokemon)
print(len(pokemon_list)) #898
pokemon_list[0:10]
```

Finally, you can integrate the information 
of the first ten Pokémon into a
`DataFrame`, which will look like this:

```{python}
#| output: false

# 5. Information about the first ten Pokémon in the list integrated into a DataFrame
items = []
for pokemon in pokemon_list[0:10]:
    item = get_pokemon_data(pokemon)
    items.append(item)
df = pd.DataFrame(items)
```

```{python}
#| echo: false
df.head()
```

### Step 2: Retrieve and display Pokémon images

We would like you to also retrieve the images of the first 5 Pokémon
and save them in a folder.

::: {.exercise}
## Exercise 2b: Pokémon (guided version)

- The URLs of Pokémon images follow the format _"https://img.pokemondb.net/artwork/{pokemon}.jpg"_. 
Use the `requests` and `shutil` modules to download and save the images locally. 
- Import these images stored in JPEG format into `Python` using the `imread` function from the `skimage.io` package

:::

```{python}
#| echo: true
!pip install scikit-image
```

```{python}
#| include: false
#| echo: false

# Step 2 solution
import shutil
import requests
import os
import matplotlib.pyplot as plt
import skimage.io as imio

nb_pokemons = 5
fig, ax = plt.subplots(1, nb_pokemons, figsize=(12,4))
for pokemon_index in range(0, nb_pokemons):
    pokemon = pokemon_list[pokemon_index]
    url = f"https://img.pokemondb.net/artwork/{pokemon}.jpg"
    response = requests.get(url, stream=True)
    with open(f'{pokemon}.jpg', 'wb') as out_file:
        shutil.copyfileobj(response.raw, out_file)
    name = f'{pokemon}.jpg'
    img = imio.imread(name)
    ax[pokemon_index].imshow(img)  
    ax[pokemon_index].get_xaxis().set_visible(False)
    ax[pokemon_index].get_yaxis().set_visible(False)
```

```{python}
#| echo: false
#plt.savefig('pokemon.png', bbox_inches='tight')
ax[0].get_figure()
```

# `Selenium`: simulating user behavior on the internet

So far, we have assumed that we always know the URL we are interested in.
Additionally, the pages we visit are __"static"__,
they do not depend on any action or search performed by the user.

Now, we will see how to interact with a website to fill out fields 
and retrieve the information we are interested in.
A website's response to a user's actions often involves 
the use of `JavaScript` in web development.
The [Selenium](https://pypi.python.org/pypi/selenium) package 
allows you to simulate, from an automated code, 
the manual behavior of a user. This enables you 
to obtain information from the site that is not present in the 
`HTML` code but appears only after the execution of 
background `JavaScript` scripts.

`Selenium` behaves like an average internet user:
it clicks on links, fills out forms, etc.

## First example: scraping a search engine

In this example, we will try to go to the
[Bing News](https://www.bing.com/news) site
and enter a given topic into the search bar.
For testing, we will search with the keyword __"Trump"__.

Installing `Selenium` requires having `Chromium`, which is a
minimalistic version of Google Chrome browser.
The version of [chromedriver](https://sites.google.com/a/chromium.org/chromedriver/)
must be `>= 2.36` and depends on the version of `Chrome` you have in your work environment.
To install this minimal version of `Chrome` on a `Linux` environment,
you can refer to the dedicated section.

::: {.important}
## Installing `Selenium`

First, you need to install the dependencies. 
On `Colab`, you can use the following commands:

```{python}
#| eval: false
#| echo: true
!sudo apt-get update
!sudo apt install -y unzip xvfb libxi6 libgconf-2-4 -y
!sudo apt install chromium-chromedriver -y
!cp /usr/lib/chromium-browser/chromedriver /usr/bin
```

<br>

Si vous êtes sur le `SSP Cloud`, vous pouvez
exécuter les commandes suivantes :

```{python}
#| echo: true
#| output: false
!wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb -O /tmp/chrome.deb
!sudo apt-get update
!sudo -E apt-get install -y /tmp/chrome.deb
!pip install chromedriver-autoinstaller selenium

import chromedriver_autoinstaller
chromedriver_autoinstaller.install()
```

<br>

You can then install `Selenium`.
For example, from a
`Notebook` cell:

```{python}
#| output: false
!pip install selenium
```

:::

After installing `Chromium`, 
it is necessary to tell `Python` where to
find it. If you are on `Linux` and have followed
the previous instructions, you can do:

```{python}
#| output: false
#| echo: true
import selenium
from webdriver_manager.chrome import ChromeDriverManager

path_to_web_driver = ChromeDriverManager().install()
```

First, you need to initialize the behavior
of `Selenium` by replicating the browser's settings.
For this, we will first initialize
our browser with some options:

```{python}
#| output: false
#| echo: true
import time

from selenium import webdriver
from selenium.webdriver.common.keys import Keys

chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument('--headless')
chrome_options.add_argument('--no-sandbox')
chrome_options.add_argument('--disable-dev-shm-usage')
#chrome_options.add_argument('--verbose') 
```

Then we launch the browser:

```{python}
#| echo: true
#| output: false
from selenium.webdriver.chrome.service import Service
service = Service(executable_path=path_to_web_driver)

browser = webdriver.Chrome(service=service,
                           options=chrome_options)
```

We go to the `Bing News` site,
and we indicate the keyword we want to search.
In this case, we are interested in news about Donald Trump.
After inspecting the page using the browser's developer tools,
we see that the search bar is an element of the code called `q` (as in _query_).
So, we ask `selenium` to find this element:

```{python}
#| echo: true
#| output: false
browser.get('https://www.bing.com/news')

search = browser.find_element("name", "q")
print(search)
print([search.text, search.tag_name, search.id])

# we send to this place the word we would have typed in the search bar
search.send_keys("Trump")

search_button = browser.find_element("xpath", "//input[@id='sb_form_go']") 
search_button.click()
```

`Selenium` allows capturing the image you would see in the browser
with `get_screenshot_as_png`. This can be useful to check that you
have performed the correct action:

```{python}
#| output: false
png = browser.get_screenshot_as_png()
```

```{python}
from IPython.display import Image
Image(png, width='500')
```

Finally, we can extract the results. Several
methods are available. The most practical method,
when available,
is to use `XPath`, which is an unambiguous path
to access an element. Indeed,
multiple elements may share the same class or 
attribute, which can cause a search 
of this type to return multiple matches. 
To determine the `XPath` of an object, the developer tools
of your web browser are useful. 
For example, in `Firefox`, once you
have found an element in the inspector, you
can right-click and choose `Copy > XPath`.

```{python}
from selenium.common.exceptions import StaleElementReferenceException
links = browser.find_elements("xpath", "//div/a[@class='title'][@href]")

results = []
for link in links:
    try:
        url = link.get_attribute('href')
    except StaleElementReferenceException as e:
        print("Issue with '{0}' and '{1}'".format(url, link))
        print("It might be due to slow javascript which produces the HTML page.")
    results.append(url)
```

Finally, to end our session, we ask
`Python` to close the browser:

```{python}
#| echo: true
#| output: false
browser.quit()
```

We obtained the following results:


```{python}
#| code-overflow: wrap
print(results)
```

Other useful `Selenium` methods:

| Method | Result |
|-------------------------------|--------------|
| `find_element(****).click()` | Once you have found an interactive element, especially a button, you can click on it to activate a new page |
| `find_element(****).send_keys("toto")` | Once you have found an element, especially a field where you authenticate, you can send a value, here _"toto"_. |


## using `Selenium` to play 2048

In this example, we use the module so that `Python`
presses the keyboard keys itself to play 2048.

Note: this piece of code does not provide a solution to 2048,
it just demonstrates what can be done with `Selenium`.

```{python}
#| eval: false
#| echo: true

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys

# open the 2048 game webpage
service = Service(executable_path=path_to_web_driver)

browser = webdriver.Chrome(service=service,
                           options=chrome_options)
browser.get('https://play2048.co//')

# What we will do: a loop that endlessly repeats the same thing: up / right / down / left

# we start by clicking on the page so that the keys are recognized 
button = browser.find_element("class name", 'grid-container')
browser.execute_script("arguments[0].click();", button)
time.sleep(0.5)

grid = browser.find_element("tag name", 'body')

# to know which moves to make at what time, we create a dictionary
direction = {0: Keys.UP, 1: Keys.RIGHT, 2: Keys.DOWN, 3: Keys.LEFT}
count = 0

while True:
    try: # check if the "Try again" button is present - otherwise, it means the game is over
        retryButton = browser.find_element("link text",'Try again')
        scoreElem = browser.find_element("class name", 'score-container')
        break
    except:
        # Do nothing.  Game is not over yet
        pass
    # continue the game - press the next key for the next move
    count += 1
    grid.send_keys(direction[count % 4]) 
    time.sleep(0.1)

print('Final score: {} in {} moves'.format(scoreElem.text, count))    
browser.quit()
```

## Additional exercise

To explore another possible application of web scraping, you can also tackle subject 5 of the 2023 edition of a non-competitive hackathon organized by Insee:

- On [`Github`](https://github.com/InseeFrLab/funathon2023_sujet5)
- On the [`SSPCloud`](https://www.sspcloud.fr/formation?search=funat&path=%5B%22Funathon%202023%22%5D)

The content of the NLP section of the course will be useful for the second part of the topic!
