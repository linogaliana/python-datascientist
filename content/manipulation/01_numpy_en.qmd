---
title: "Numpy, the foundation of data science"
tags:
  - numpy
  - Tutorial
  - Manipulation
categories:
  - Tutorial
  - Manipulation
description: |
  `Numpy` is the cornerstone of the _data science_ ecosystem in `Python`. All data manipulation, modeling, and visualization libraries rely, directly or indirectly, on `Numpy`. It is therefore essential to review some concepts of this package before moving forward.
image: scatter_numpy.png
echo: false
---

If you want to try the examples in this tutorial:

::: {.content-visible when-format="html"}
{{< include "../../build/_printBadges.qmd" >}}
:::



# Introduction

This chapter serves as an introduction to _Numpy_ to ensure that the basics of vector calculations with `Python` are mastered. The first part of the chapter presents small exercises to practice some basic functions of `Numpy`. The end of the chapter presents more in-depth practical exercises using `Numpy`.

It is recommended to regularly refer to the [_numpy cheatsheet_](https://www.datacamp.com/community/blog/python-numpy-cheat-sheet) and the [official documentation](https://numpy.org/doc/stable/) if you have any doubts about a function.

In this chapter, we will adhere to the convention of importing `Numpy` as follows:

```{python import np}
#| label: import-np
#| echo: true
import numpy as np
```

We will also set the seed of the random number generator to obtain reproducible results:

```{python}
#| echo: true
np.random.seed(12345)
```

::: {.note}

The authors of `numpy` [now recommend](https://numpy.org/doc/stable/reference/random/index.html) using generators via the `default_rng()` function rather than simply using `numpy.random`.

To stay consistent with the codes found everywhere on the internet, we still use `np.random.seed`, but this may change in the future.

:::



# Concept of _array_

In the world of data science, as will be discussed in more depth in the upcoming chapters, the central object is the two-dimensional data table. The first dimension corresponds to rows and the second to columns. If we only consider one dimension, we refer to a variable (a column) of our data table. It is therefore natural to link data tables to the mathematical objects of matrices and vectors.

`NumPy` (`Numerical Python`) is the foundational brick for processing numerical lists or strings of text as matrices. `NumPy` comes into play to offer this type of object and the associated standardized operations that do not exist in the basic `Python` language.

The central object of `NumPy` is the **`array`**, which is a multidimensional data table. A `Numpy` array can be one-dimensional and considered as a vector (`1d-array`), two-dimensional and considered as a matrix (`2d-array`), or, more generally, take the form of a multidimensional object (`Nd-array`), a sort of nested table.

Simple arrays (one or two-dimensional) are easy to represent and cover most of the use-case related to `Numpy`. We will discover in the next chapter on `Pandas` that, in practice, we usually don't directly use  `Numpy` since it is a low-level library. A `Pandas` _DataFrame_ is constructed from a collection of one-dimensional arrays (the variables of the table), which allows performing coherent (and optimized) operations with the variable type. Having some `Numpy` knowledge is useful for understanding the logic of vector manipulation, making data processing more readable, efficient, and reliable.

Compared to a list,

* an *array* can only contain one type of data (`integer`, `string`, etc.), unlike a list.
* operations implemented by `Numpy` will be more efficient and require less memory.

Geographical data will constitute a slightly more complex construction than a traditional `DataFrame`. The geographical dimension takes the form of a deeper table, at least two-dimensional (coordinates of a point). However, geographical data manipulation libraries will handle this increased complexity.

## Creating an array

We can create an array in several ways. To create an array from a list, simply use the `array` method:

```{python}
#| echo: true
np.array([1,2,5])
```

It is possible to add a `dtype` argument to constrain the array type:

```{python}
#| echo: true
np.array([["a","z","e"],["r","t"],["y"]], dtype="object")
```

There are also practical methods for creating arrays:

* Logical sequences: `np.arange` (sequence) or `np.linspace` (linear interpolation between two bounds)
* Ordered sequences: array filled with zeros, ones, or a desired number: `np.zeros`, `np.ones`, or `np.full`
* Random sequences: random number generation functions: `np.rand.uniform`, `np.rand.normal`, etc.
* Matrix in the form of an identity matrix: `np.eye`

This gives, for logical sequences:

```{python}
#| echo: true
np.arange(0,10)
```

```{python}
#| echo: true
np.arange(0,10,3)
```

```{python}
#| echo: true
np.linspace(0, 1, 5)
```

For an array initialized to 0:

```{python}
#| echo: true
np.zeros(10, dtype=int)
```

or initialized to 1:

```{python}
#| echo: true
np.ones((3, 5), dtype=float)
```

or even initialized to 3.14:

```{python}
#| echo: true
np.full((3, 5), 3.14)
```

Finally, to create the matrix $I_3$:

```{python}
#| echo: true
np.eye(3)
```

{{< include "01_numpy_exercises/_exo1_en.qmd" >}}
{{< include "01_numpy_exercises/_exo1_solution.qmd" >}}


# Indexing and slicing

## Logic illustrated with a one-dimensional array

The simplest structure is the one-dimensional array:

```{python}
#| echo: true
x = np.arange(10)
print(x)
```

Indexing in this case is similar to that of a list:

* The first element is 0
* The nth element is accessible at position $n-1$

The logic for accessing elements is as follows:

```python
x[start:stop:step]
```

With a one-dimensional array, the slicing operation (keeping a slice of the array) is very simple. For example, to keep the first *K* elements of an array, you would do:

```python
x[:(K-1)]
```

In this case, you select the K$^{th}$ element using:

```python
x[K-1]
```

To select only one element, you would do:

```{python}
#| echo: true
x = np.arange(10)
x[2]
```

The syntax for selecting particular indices from a list also works with arrays.

{{< include "01_numpy_exercises/_exo2_en.qmd" >}}
{{< include "01_numpy_exercises/_exo2_solution.qmd" >}}


## Regarding performance

A key element in the performance of `Numpy` compared to lists, when it comes to slicing, is that an array does not return a copy of the element in question (a copy that costs memory and time) but simply a view of it.

When it is necessary to make a copy, for example to avoid altering the underlying array, you can use the `copy` method:

```python
x_sub_copy = x[:2, :2].copy()
```

## Logical filters

It is also possible, and more practical, to select data based on logical conditions (an operation called a __*boolean mask*__). This functionality will mainly be used to perform data filtering operations.

For simple comparison operations, logical comparators may be sufficient. These comparisons also work on multidimensional arrays thanks to broadcasting, which we will discuss later:

```{python}
#| echo: true
x = np.arange(10)
x2 = np.array([[-1,1,-2],[-3,2,0]])
print(x)
print(x2)
```

```{python}
#| echo: true
x==2
x2<0
```

To select the observations related to the logical condition, just use the `numpy` slicing logic that works with logical conditions.

{{< include "01_numpy_exercises/_exo3_en.qmd" >}}
{{< include "01_numpy_exercises/_exo3_solution.qmd" >}}


Whenever possible, it is recommended to use `numpy`'s logical functions (optimized and well-handling dimensions). Among them are:

* `count_nonzero` ;
* `isnan` ;
* `any` or `all` especially with the `axis` argument ;
* `np.array_equal` to check element-by-element equality.

Given

```{python}
#| echo: true
x = np.random.normal(0, size=(3, 4))
```

a multidimensional array and

```{python}
#| echo: true
y = np.array([np.nan, 0, 1])
```

a one-dimensional array with a missing value.

{{< include "01_numpy_exercises/_exo4_en.qmd" >}}
{{< include "01_numpy_exercises/_exo4_solution.qmd" >}}


# Manipulating an array


## Manipulation functions

`Numpy` provides standardized methods or functions for modifying
here's a table showing some of them:


Here are some functions to modify an array:

| Operation | Implementation |
|-----------|----------------|
| Flatten an array | `x.flatten()` (method) |
| Transpose an array | `x.T` (method) or `np.transpose(x)` (function) |
| Append elements to the end | `np.append(x, [1,2])` |
| Insert elements at a given position (at positions 1 and 2) | `np.insert(x, [1,2], 3)` |
| Delete elements (at positions 0 and 3) | `np.delete(x, [0,3])` |

To combine arrays, you can use, depending on the case, the functions `np.concatenate`, `np.vstack` or the method `.r_` (row-wise concatenation). `np.hstack` or the method `.column_stack` or `.c_` (column-wise concatenation).

```{python}
#| echo: true
x = np.random.normal(size = 10)
```

To sort an array, use `np.sort`

```{python}
#| echo: true
x = np.array([7, 2, 3, 1, 6, 5, 4])

np.sort(x)
```

If you want to perform a partial reordering to find the _k_ smallest values in an `array` without sorting them, use `partition`:

```{python}
#| echo: true
np.partition(x, 3)
```

## Statistics on an array

For classical descriptive statistics, `Numpy` offers a number of already implemented functions, which can be combined with the `axis` argument.

```{python}
#| echo: true
x = np.random.normal(0, size=(3, 4))
```


{{< include "01_numpy_exercises/_exo5_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo5_solution.qmd" >}}




# Broadcasting

Broadcasting refers to a set of rules for applying operations to arrays of different dimensions. In practice, it generally consists of applying a single operation to all members of a `numpy` array.

The difference can be understood from the following example. Broadcasting allows the scalar `5` to be transformed into a 3-dimensional array:

```{python}
#| echo: true
a = np.array([0, 1, 2])
b = np.array([5, 5, 5])

a + b
a + 5
```

Broadcasting can be very practical for efficiently performing operations on data with a complex structure. For more details, visit [here](https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html) or [here](https://stackoverflow.com/questions/47435526/what-is-the-meaning-of-axis-1-in-keras-argmax).



## Application: programming your own k-nearest neighbors

```{python}
lang = "en"
```


{{< include "01_numpy_exercises/_exo6_en.qmd" >}}
{{< include "01_numpy_exercises/_exo6_solution.qmd" >}}


Did I invent this challenging exercise? Not at all, it comes from the book [_Python Data Science Handbook_](https://jakevdp.github.io/PythonDataScienceHandbook/02.08-sorting.html#Example:-k-Nearest-Neighbors). But if I had told you this immediately, would you have tried to answer the questions?

Moreover, it would not be a good idea to generalize this algorithm to large datasets. The complexity of our approach is $O(N^2)$. The algorithm implemented by `Scikit-Learn` is $O[NlogN]$.

Additionally, computing matrix distances using the power of GPU (graphics cards) would be faster. In this regard, the library [faiss](https://github.com/facebookresearch/faiss), or the dedicated frameworks for computing distance between high-dimensional vectors like [ChromaDB](https://www.trychroma.com/) offer much more satisfactory performance than `Numpy` for this specific problem.


# Additional Exercises


`Google` became famous thanks to its `PageRank` algorithm. This algorithm allows, from links between websites, to give an importance score to a website which will be used to evaluate its centrality in a network. The objective of this exercise is to use `Numpy` to implement such an algorithm from an adjacency matrix that links the sites together.

{{< include "01_numpy_exercises/_exo7_fr.qmd" >}}
{{< include "01_numpy_exercises/_exo7_solution.qmd" >}}

Site 1 is quite central because it is referenced twice. Site 5 is also central since it is referenced by site 1.

```{python}
v
```