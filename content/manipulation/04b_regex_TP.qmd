---
title: "Ma√Ætriser les expressions r√©guli√®res"
date: 2023-07-08T13:00:00Z
draft: false
weight: 70
slug: regex
tags:
  - regex
  - pandas
  - re
  - Manipulation
  - Tutoriel
categories:
  - Tutoriel
  - Manipulation
type: book
description: |
  Les expressions r√©guli√®res fournissent un cadre tr√®s pratique pour manipuler
  de mani√®re flexible des donn√©es textuelles. Elles sont tr√®s utiles
  notamment pour les t√¢ches de traitement naturel du langage (__NLP__)
  ou le nettoyage de donn√©es textuelles.
image: https://d2h1bfu6zrdxog.cloudfront.net/wp-content/uploads/2022/04/img_625491e9ce092.png
---

::: {.cell .markdown}
```{python}
#| echo: false
#| output: 'asis'
#| include: true
#| eval: true

import sys
sys.path.insert(1, '../../') #insert the utils module
from utils import print_badges

#print_badges(__file__)
print_badges("content/manipulation/04b_regex_TP.qmd")
```
:::

## Introduction

`Python` offre √©norm√©ment de fonctionalit√©s tr√®s pratiques pour la manipulation de donn√©es
textuelles. C'est l'une des raisons de son
succ√®s dans la communaut√© du traitement automatis√© du langage (NLP, voir partie d√©di√©e). 

Dans les chapitres pr√©c√©dents, nous avons parfois √©t√© amen√©s √† chercher des √©l√©ments textuels basiques. Cela √©tait possible avec la m√©thode `str.find` du package `Pandas` qui constitue une version vectoris√©e de la m√©thode `find`
de base. Nous avons d'ailleurs
pu utiliser cette derni√®re directement, notamment lorsqu'on a fait du _web scraping_. 

Cependant, cette fonction de recherche
trouve rapidement ses limites. 
Par exemple, si on d√©sire trouver √† la fois les occurrences d'un terme au singulier
et au pluriel, il sera n√©cessaire d'utiliser
au moins deux fois la m√©thode `find`.
Pour des verbes conjugu√©s, cela devient encore plus complexe, en particulier si ceux-ci changent de forme selon le sujet. 
 
Pour des expressions compliqu√©es, il est conseill√© d'utiliser les __expressions r√©guli√®res__,
ou _"regex"_. C'est une fonctionnalit√© qu'on retrouve dans beaucoup de langages. C'est une forme de grammaire qui permet de rechercher des expressions.

Une partie du contenu de cette partie
est une adaptation de la
[documentation collaborative sur `R` nomm√©e `utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_donnees_textuelles#regex) √† laquelle j'ai particip√©. Ce chapitre reprend aussi du contenu du
livre [_R for Data Science_](https://r4ds.hadley.nz/regexps.html) qui pr√©sente un chapitre 
tr√®s p√©dagogique sur les regex.

Nous allons utiliser le _package_ `re` pour illustrer nos exemples d'expressions
r√©guli√®res. Il s'agit du package de r√©f√©rence, qui est utilis√©, en arri√®re-plan,
par `Pandas` pour vectoriser les recherches textuelles. 

```{python}
import re
import pandas as pd
```


::: {.cell .markdown}
```{=html}
<div class="alert alert-warning" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-lightbulb"></i> Hint</h3>
```

**Les expressions r√©guli√®res (*regex*) sont notoirement difficiles √† ma√Ætriser.** Il existe des outils qui facilitent le travail avec les expressions r√©guli√®res.

- L'outil de r√©f√©rence pour ceci est [https://regex101.com/] qui permet de tester des `regex` en `Python`
tout en ayant une explication qui accompagne ce test

- De m√™me pour [ce site](https://ole.michelsen.dk/tools/regex/) qui comporte une cheat sheet en bas de la page. 

- Les jeux de [Regex Crossword](https://regexcrossword.com/) permettent d'apprendre les expressions r√©guli√®res en s'amusant


Il peut √™tre pratique de demander √† des IA assistantes, comme `Github Copilot` ou `ChatGPT`, une
premi√®re version d'une regex en expliquant le contenu qu'on veut extraire.
Cela peut faire √©conomiser pas mal de temps, sauf quand l'IA fait preuve d'une confiance excessive
et vous propose avec aplomb une regex totalement fausse...

```{=html}
</div>
```
:::


## Principe

**Les expressions r√©guli√®res sont un outil permettant de d√©crire un ensemble de cha√Ænes de caract√®res possibles selon une syntaxe pr√©cise, et donc de d√©finir un motif (ou `pattern`).** Les expressions r√©guli√®res servent par exemple lorsqu'on veut extraire une partie d'une cha√Æne de caract√®res, ou remplacer une partie d'une cha√Æne de caract√®res. Une expression r√©guli√®re prend la forme d'une cha√Æne de caract√®res, qui peut contenir √† la fois des √©l√©ments litt√©raux et des caract√®res sp√©ciaux qui ont un sens logique. 

Par exemple, `"ch.+n"` est une expression r√©guli√®re qui d√©crit le motif suivant : la cha√Æne litt√©rale `ch`, suivi de n'importe quelle cha√Æne d'au moins un caract√®re (`.+`), suivie de la lettre `n`. Dans la cha√Æne `"J'ai un chien."`, la sous-cha√Æne `"chien"` correspond √† ce motif. De m√™me pour `"chapeau ron"` dans `"J'ai un chapeau rond"`. En revanche, dans la cha√Æne `"La soupe est chaude."`, aucune sous-cha√Æne ne correpsond √† ce motif (car aucun `n` n'appara√Æt apr√®s le `ch`).

Pour s'en convaincre, nous pouvons d√©j√† regarder
les deux premiers cas:

```{python}
pattern = "ch.+n"
print(re.search(pattern, "J'ai un chien."))
print(re.search(pattern, "J'ai un chapeau rond."))
```

Cependant, dans le dernier cas, nous ne trouvons pas
le _pattern_ recherch√© :

```{python}
print(re.search(pattern, "La soupe est chaude."))
```

La regex pr√©c√©dente comportait deux types de caract√®res:

- les _caract√®res litt√©raux_ : lettres et nombres qui sont reconnus de mani√®re litt√©rale
- les _m√©ta-caract√®res_ : symboles qui ont un sens particulier dans les regex.

Les principaux _m√©ta-caract√®res_ sont `.`, `+`, `*`, `[`, `]`, `^` et `$` mais il
en existe beaucoup d'autres.
Parmi cet ensemble, on utilise principalement les quantifieurs (`.`, `+`, `*`...),
les classes de caract√®res (ensemble qui sont d√©limit√©s par `[` et `]`)
ou les ancres (`^`, `$`...)

Dans l'exemple pr√©c√©dent, 
nous retrouvions deux quantifieurs accol√©s `.+`. Le premier (`.`) signifie n'importe quel caract√®re[^1]. Le deuxi√®me (`+`) signifie _"r√©p√®te le pattern pr√©c√©dent"_.
Dans notre cas, la combinaison `.+` permet ainsi de r√©p√©ter n'importe quel caract√®re avant de trouver un _n_. 
Le nombre de fois est indetermin√© : cela peut ne pas √™tre pas n√©cessaire d'intercaler des caract√®res avant le _n_ 
ou cela peut √™tre n√©cessaire d'en intercepter plusieurs :

```{python}
print(re.search(pattern, "J'ai un chino"))
print(re.search(pattern, "J'ai un chiot tr√®s mignon."))
```

[^1]: N'importe quel caract√®re √† part le retour √† la ligne (`\n`). Ceci est √† garder en t√™te, j'ai d√©j√† perdu des heures √† chercher pourquoi mon `.` ne capturait pas ce que je voulais qui s'√©talait sur plusieurs lignes...

### Classes de caract√®res

Lors d‚Äôune recherche, on s‚Äôint√©resse aux caract√®res et souvent aux classes de caract√®res : on cherche un chiffre, une lettre, un caract√®re dans un ensemble pr√©cis ou un caract√®re qui n‚Äôappartient pas √† un ensemble pr√©cis. Certains ensembles sont pr√©d√©finis, d‚Äôautres doivent √™tre d√©finis √† l‚Äôaide de crochets.

Pour d√©finir un ensemble de caract√®res, il faut √©crire cet ensemble entre crochets. Par exemple, `[0123456789]` d√©signe un chiffre. Comme c‚Äôest une s√©quence de caract√®res cons√©cutifs, on peut r√©sumer cette √©criture en `[0-9]`. 

Par
exemple, si on d√©sire trouver tous les _pattern_ qui commencent par un `c` suivi 
d'un `h` puis d'une voyelle (a, e, i, o, u), on peut essayer
cette expression r√©guli√®re. 

```{python}
re.findall("[c][h][aeiou]", "chat, chien, veau, vache, ch√®vre")
```

Il serait plus pratique d'utiliser `Pandas` dans ce cas pour isoler les 
lignes qui r√©pondent √† la condition logique (en ajoutant les accents
qui ne sont pas compris sinon):

```{python}
import pandas as pd
txt = pd.Series("chat, chien, veau, vache, ch√®vre".split(", "))
txt.str.match("ch[ae√©√®iou]")
```

Cependant, l'usage ci-dessus des classes de caract√®res
n'est pas le plus fr√©quent. 
On privil√©gie celles-ci pour identifier des
pattern complexe plut√¥t qu'une suite de caract√®res litt√©raux.
Les tableaux d'aide m√©moire illustrent une partie des
classes de caract√®res les plus fr√©quentes
(`[:digit:]` ou `\d`...)

### Quantifieurs

Nous avons rencontr√© les quantifieurs avec notre premi√®re expression
r√©guli√®re. Ceux-ci contr√¥lent le nombre de fois 
qu'un _pattern_ est rencontr√©. 

Les plus fr√©quents sont: 

- `?` : 0 ou 1 match ;
- `+` : 1 ou plus de matches ;
- `*` : 0 or more matches. 

Par exemple, `colou?r` permettra de matcher √† la fois l'√©criture am√©ricaine et anglaise

```{python}
re.findall("colou?r", "Did you write color or colour?")
```

Ces quantifiers peuvent bien s√ªr √™tre associ√©s √† 
d'autres types de caract√®res, notamment les classes de caract√®res. 
Cela peut √™tre extr√®mement pratique.
Par exemple, `\d+` permettra de capturer un ou plusieurs chiffres, `\s?`
permettra d'ajouter en option un espace,
`[\w]{6,8}` un mot entre six et huit lettres qu‚Äôon √©crira...

Il est aussi possible de d√©finir le nombre de r√©p√©titions
avec `{}`:

- `{n}` matche exactement _n_ fois ;
- `{n,}` matche au moins _n_ fois ;
- `{n,m}` matche entre _n_ et _m_ fois.

Cependant, la r√©p√©tition des termes
ne s'applique par d√©faut qu'au dernier
caract√®re pr√©c√©dent le quantifier. 
On peut s'en convaincre avec l'exemple ci-dessus:

```{python}
print(re.match("toc{4}","toctoctoctoc"))
```

Pour pallier ce probl√®me, il existe les parenth√®ses.
Le principe est le m√™me qu'avec les r√®gles num√©riques:
les parenth√®ses permettent d'introduire une hi√©rarchie. 
Pour reprendre l'exemple pr√©c√©dent, on obtient
bien le r√©sultat attendu gr√¢ce aux parenth√®ses:

```{python}
print(re.match("(toc){4}","toctoctoctoc"))
print(re.match("(toc){5}","toctoctoctoc"))
print(re.match("(toc){2,4}","toctoctoctoc"))
```

::: {.cell .markdown}
```{=html}
<div class="alert alert-info" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-comment"></i> Note</h3>
```

L‚Äôalgorithme des expressions r√©guli√®res essaye toujours de faire correspondre le plus grand morceau √† l‚Äôexpression r√©guli√®re. 

Par exemple, soit une chaine de caract√®re HTML: 

```{python}
s = "<h1>Super titre HTML</h1>"
```

L'expression r√©guli√®re `re.findall("<.*>", s)` correspond, potentiellement,
√† trois morceaux : 

*  ``<h1>``
*  ``</h1>``
* ``<h1>Super titre HTML</h1>``

C'est ce dernier qui sera choisi, car le plus grand. Pour 
s√©lectionner le plus petit, 
il faudra √©crire les multiplicateurs comme ceci : `*?`, `+?`.
En voici quelques exemples:

```{python}
s = "<h1>Super titre HTML</h1>\n<p><code>Python</code> est un langage tr√®s flexible</p>"
print(re.findall("<.*>", s))
print(re.findall("<p>.*</p>", s))
print(re.findall("<p>.*?</p>", s))
print(re.compile("<.*?>").findall(s))
```

```{=html}
</div>
```
:::

### Aide-m√©moire

Le tableau ci-dessous peut servir d'aide-m√©moire
sur les regex:

|Expression r√©guli√®re|Signification |
|------------------|---------------------------------|
|`"^"`             | D√©but de la cha√Æne de caract√®res |
|`"$"`             | Fin de la cha√Æne de caract√®res |
|`"\\."`           | Un point |
|`"."`             | N'importe quel caract√®re |
|`".+"`            | N'importe quelle suite de caract√®res non vide |
|`".*"`            | N'importe quelle suite de caract√®res, √©ventuellement vi
|`"[:alnum:]"`     | Un caract√®re alphanum√©rique |
|`"[:alpha:]"`     | Une lettre |
|`"[:digit:]"`     | Un chiffre |
|`"[:lower:]"`     | Une lettre minuscule |
|`"[:punct:]"`     | Un signe de ponctuation |
|`"[:space:]"`     | un espace |
|`"[:upper:]"`     | Une lettre majuscule |
|`"[[:alnum:]]+"`  | Une suite d'au moins un caract√®re alphanum√©rique |
|`"[[:alpha:]]+"`  | Une suite d'au moins une lettre |
|`"[[:digit:]]+"`  | Une suite d'au moins un chiffre |
|`"[[:lower:]]+"`  | Une suite d'au moins une lettre minuscule |
|`"[[:punct:]]+"`  | Une suite d'au moins un signe de ponctuation |
|`"[[:space:]]+"`  | Une suite d'au moins un espace |
|`"[[:upper:]]+"`  | Une suite d'au moins une lettre majuscule |
|`"[[:alnum:]]*"`  | Une suite de caract√®res alphanum√©riques, √©ventuellement vide |
|`"[[:alpha:]]*"`  | Une suite de lettres, √©ventuellement vide |
|`"[[:digit:]]*"`  | Une suite de chiffres, √©ventuellement vide |
|`"[[:lower:]]*"`  | Une suite de lettres minuscules, √©ventuellement vide |
|`"[[:upper:]]*"`  | Une suite de lettres majuscules, √©ventuellement vide |
|`"[[:punct:]]*"`  | Une suite de signes de ponctuation, √©ventuellement vide
|`"[^[:alpha:]]+"` | Une suite d'au moins un caract√®re autre qu'une lettre |
|`"[^[:digit:]]+"` | Une suite d'au moins un caract√®re autre qu'un chiffre |
|`"\|"`             | L'une des expressions `x` ou `y` est pr√©sente          |
|`[abyz]`         | Un seul des caract√®res sp√©cifi√©s  |
|`[abyz]+`        | Un ou plusieurs des caract√®res sp√©cifi√©s (√©ventuellement r√©p√©t√©s) |   
|`[^abyz]`        | Aucun des caract√®res sp√©cifi√©s n'est pr√©sent  |


Certaines classes de caract√®res b√©n√©ficient d'une syntaxe plus l√©g√®re car
elles sont tr√®s fr√©quentes. Parmi-celles:

|Expression r√©guli√®re|Signification |
|------------------|---------------------------------|
| `\d`             | N'importe quel chiffre  |
| `\D`             | N'importe quel caract√®re qui n'est pas un caract√®re |
| `\s`             | N'importe quel espace (espace, tabulation, retour √† la ligne) |
| `\S`             | N'importe quel caract√®re qui n'est pas un espace |
| `\w`             | N'importe quel type de mot (lettres et nombres)
| `\W`             | N'importe quel ensemble qui n'est pas un mot (lettres et nombres)


Dans l'exercice suivant, vous allez pouvoir mettre en pratique
les exemples pr√©c√©dents sur une `regex` un peu plus compl√®te.
Cet exercice ne n√©cessite pas la connaissance des subtilit√©s 
du _package_ `re`, vous n'aurez besoin que de `re.findall`.

Cet exercice utilisera la chaine de caract√®re suivante :

```{python}
s = """date 0 : 14/9/2000
date 1 : 20/04/1971     date 2 : 14/09/1913     date 3 : 2/3/1978
date 4 : 1/7/1986     date 5 : 7/3/47     date 6 : 15/10/1914
date 7 : 08/03/1941     date 8 : 8/1/1980     date 9 : 30/6/1976"""
s
```


::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 1</h3>
```

1. On va d'abord s'occuper d'extraire le jour de naissance. 
    + Le premier chiffre du jour est 0, 1, 2 ou 3. Traduire cela sous la forme d'une s√©quence `[X-X]`
    + Le deuxi√®me chiffre du jour est lui entre 0 et 9. Traduire cela sous la s√©quence ad√©quate
    + Remarquez que le premier jour est facultatif. Intercaler entre les deux classes de caract√®re ad√©quate 
     le quantifieur qui convient
    + Ajouter le slash √† la suite du motif
    + Tester avec `re.findall`. Vous devriez obtenir beaucoup plus d'√©chos que n√©cessaire.
      C'est normal, √† ce stade la 
      regex n'est pas encore finalis√©e
2. Suivre la m√™me logique pour les mois en notant que les mois du calendrier gr√©gorien ne d√©passent
  jamais la premi√®re dizaine. Tester avec `re.findall`
3. De m√™me pour les ann√©es de naissance en notant que jusqu'√† preuve du contraire, pour des personnes vivantes
aujourd'hui, les mill√©naires concern√©s sont restreints. Tester avec `re.findall`
4. Cette regex n'est pas naturelle, on pourrait tr√®s bien se satisfaire de classes de
caract√®res g√©n√©riques `\d` m√™me si elles pourraient, en pratique, nous s√©lectionner des
dates de naissance non possibles (`43/78/4528` par exemple). Cela permettrait
d'all√©ger la regex afin de la rendre plus intelligible. Ne pas oublier l'utilit√© des quantifieurs.
5. Comment adapter la regex pour qu'elle soit toujours valide pour nos cas mais permette aussi de
capturer les dates de type `YYYY/MM/DD` ? Tester sur `1998/07/12`
```{=html}
</div>
```
:::

A l'issue de la question 1, vous devriez avoir ce r√©sultat :

```{python}
#| echo: false
re.findall("[0-3]?[0-9]/", s)
```

A l'issue de la question 2, vous devriez avoir ce r√©sultat, qui
commence √† prendre forme:

```{python}
#| echo: false
re.findall("[0-3]?[0-9]/[0-1]?[0-9]", s)
```

A l'issue de la question 3, on parvient bien
√† extraire les dates :

```{python}
#| echo: false
# Question 3
re.findall("[0-3]?[0-9]/[0-1]?[0-9]/[0-2]?[0-9]?[0-9][0-9]", s)
```

```{python}
#| echo: false
#| output: false
# Question 4
re.findall("\d{1,2}/\d{1,2}/\d{2,4}", s)
```

Si tout va bien, √† la question 5, votre regex devrait 
fonctionner: 
```{python}
#| echo: false
# Question 5
re.findall("\d{1,4}/\d{1,2}/\d{1,4}", s + "\n 1998/07/12")
```


## Principales fonctions de `re`

Voici un tableau r√©capitulatif des principales
fonctions du package `re` suivi d'exemples.

Nous avons principalement
utilis√© jusqu'√† pr√©sent `re.findall` qui est
l'une des fonctions les plus pratiques du _package_.
`re.sub` et `re.search` sont √©galement bien pratiques.
Les autres sont moins vitales mais peuvent dans des
cas pr√©cis √™tre utiles. 

| Fonction         | Objectif        |
|------------------|-----------------|
| `re.match(<regex>, s)` | Trouver et renvoyer le __premier__ _match_ de l'expression r√©guli√®re `<regex>` __√† partir du d√©but__ du _string_ `s` |
| `re.search(<regex>, s)` | Trouver et renvoyer le __premier__ _match_ de l'expression r√©guli√®re `<regex>` __quelle que soit sa position__ dans le _string_ `s` | 
| `re.finditer(<regex>, s)` | Trouver et renvoyer un it√©rateur stockant tous les _matches_ de l'expression r√©guli√®re `<regex>` __quelle que soit leur(s) position(s)__ dans le _string_ `s`. En g√©n√©ral, on effectue ensuite une boucle sur cet it√©rateur | 
| `re.findall(<regex>, s)` | Trouver et renvoyer **tous les _matches_** de l'expression r√©guli√®re `<regex>` __quelle que soit leur(s) position(s)__ dans le _string_ `s` sous forme de __liste__ | 
| `re.sub(<regex>, new_text, s)` | Trouver et __remplacer tous__ les _matches_ de l'expression r√©guli√®re `<regex>` __quelle que soit leur(s) position(s)__ dans le _string_ `s` |

Pour illustrer ces fonctions, voici quelques exemples:

::: {.cell .markdown}
```{=html}
<details><summary>Exemple de <code>re.match</code> üëá</summary>
```

`re.match` ne peut servir qu'√† capturer un _pattern_ en d√©but
de _string_. Son utilit√© est donc limit√©e. 
Capturons n√©anmoins `toto` :

```{python}
re.match("(to){2}", "toto √† la plage")
```

```{=html}
</details>
```
:::


::: {.cell .markdown}
```{=html}
<details><summary>Exemple de <code>re.search</code> üëá</summary>
```

`re.search` est plus puissant que `re.match`, on peut
capturer des termes quelle que soit leur position
dans un _string_. Par exemple, pour capturer _age_ :

```{python}
re.search("age", "toto a l'age d'aller √† la plage")
```

Et pour capturer exclusivement _"age"_ en fin 
de _string_ :

```{python}
re.search("age$", "toto a l'age d'aller √† la plage")
```


```{=html}
</details>
```
:::


::: {.cell .markdown}
```{=html}
<details><summary>Exemple de <code>re.finditer</code> üëá</summary>
```

`re.finditer` est, √† mon avis,
moins pratique que `re.findall`. Son utilit√©
principale par rapport √† `re.findall` 
est de capturer la position dans un champ textuel:

```{python}
s = "toto a l'age d'aller √† la plage"
for match in re.finditer("age", s):
    start = match.start()
    end = match.end()
    print(f'String match "{s[start:end]}" at {start}:{end}')
```


```{=html}
</details>
```
:::


::: {.cell .markdown}
```{=html}
<details><summary>Exemple de <code>re.sub</code> üëá</summary>
```

`re.sub` permet de capturer et remplacer des expressions. 
Par exemple, rempla√ßons _"age"_ par _"√¢ge"_. Mais attention,
il ne faut pas le faire lorsque le motif est pr√©sent dans _"plage"_.
On va donc mettre une condition n√©gative: capturer _"age"_ seulement
s'il n'est pas en fin de _string_ (ce qui se traduit en _regex_ par `?!$`)

```{python}
re.sub("age(?!$)", "√¢ge", "toto a l'age d'aller √† la plage")
```


```{=html}
</details>
```
:::


::: {.cell .markdown}
```{=html}
<div class="alert alert-warning" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-lightbulb"></i> Quand utiliser <code>re.compile</code> et les raw strings ?</h3>
```

`re.compile` peut √™tre int√©ressant lorsque
vous utilisez une expression r√©guli√®re plusieurs fois dans votre code.
Cela permet de compiler l'expression r√©guli√®re en un objet reconnu par `re`,
ce qui peut √™tre plus efficace en termes de performance lorsque l'expression r√©guli√®re
est utilis√©e √† plusieurs reprises ou sur des donn√©es volumineuses.

Les cha√Ænes brutes (_raw string_) sont des cha√Ænes de caract√®res sp√©ciales en `Python`,
qui commencent par `r`. Par exemple `r"toto √† la plage"`. 
Elles peuvent √™tre int√©ressantes
pour √©viter que les caract√®res d'√©chappement ne soient interpr√©t√©s par `Python`
Par exemple, si vous voulez chercher une cha√Æne qui contient une barre oblique inverse `\` dans une cha√Æne, vous devez utiliser une cha√Æne brute pour √©viter que la barre oblique inverse ne soit interpr√©t√©e comme un caract√®re d'√©chappement (`\t`, `\n`, etc.).
Le testeur [https://regex101.com/](https://regex101.com/) suppose d'ailleurs que
vous utilisez des _raw string_, cela peut donc √™tre utile de s'habituer √† les utiliser.

```{=html}
</div>
```
:::

## G√©n√©ralisation avec `Pandas`

Les m√©thodes de `Pandas` sont des extensions de celles de `re`
qui √©vitent de faire une boucle pour regarder,
ligne √† ligne, une regex. En pratique, lorsqu'on traite des
`DataFrames`, on utilise plut√¥t l'API Pandas que `re`. Les
codes de la forme `df.apply(lambda x: re.<fonction>(<regex>,x), axis = 1)`
sont √† bannir car tr√®s peu efficaces. 

Les noms changent parfois l√©g√®rement par rapport √† leur 
√©quivalent `re`.

| M√©thode | Description |
|------------------|---------------|
| `str.count()`    | Compter le nombre d'occurrences du _pattern_ dans chaque ligne |
| `str.replace()`  | Remplacer le _pattern_ par une autre valeur. Version vectoris√©e de `re.sub()` |
| `str.contains()` | Tester si le _pattern_ appara√Æt, ligne √† ligne. Version vectoris√©e de `re.search()` |
| `str.extract()`  | Extraire les groupes qui r√©pondent √† un  _pattern_ et les renvoyer dans une colonne |
| `str.findall()`  | Trouver et renvoyer toutes les occurrences d'un _pattern_. Si une ligne comporte plusieurs √©chos, une liste est renvoy√©e. Version vectoris√©e de `re.findall()` |

A ces fonctions, s'ajoutent les m√©thodes `str.split()` et `str.rsplit()` qui sont bien pratiques.


::: {.cell .markdown}
```{=html}
<details><summary>Exemple de <code>str.count</code> üëá</summary>
```

On peut compter le nombre de fois qu'un _pattern_ appara√Æt avec
`str.count`

```{python}
df = pd.DataFrame({"a": ["toto", "titi"]})
df['a'].str.count("to")
```

```{=html}
</details>
```
:::

::: {.cell .markdown}
```{=html}
<details><summary>Exemple de <code>str.replace</code> üëá</summary>
```

Rempla√ßons le motif _"ti"_ en fin de phrase

```{python}
df = pd.DataFrame({"a": ["toto", "titi"]})
df['a'].str.replace("ti$", " punch")
```

```{=html}
</details>
```
:::


::: {.cell .markdown}
```{=html}
<details><summary>Exemple de <code>str.contains</code> üëá</summary>
```

V√©rifions les cas o√π notre ligne termine par _"ti"_ :

```{python}
df = pd.DataFrame({"a": ["toto", "titi"]})
df['a'].str.contains("ti$")
```

```{=html}
</details>
```
:::

::: {.cell .markdown}
```{=html}
<details><summary>Exemple de <code>str.findall</code> üëá</summary>
```

```{python}
df = pd.DataFrame({"a": ["toto", "titi"]})
df['a'].str.findall("to")
```

```{=html}
</details>
```
:::

::: {.cell .markdown}
```{=html}
<div class="alert alert-danger" role="alert">
<i class="fa-solid fa-triangle-exclamation"></i> Warning</h3>
```

A l'heure actuelle, il n'est pas n√©cessaire d'ajouter l'argument `regex = True` mais cela 
devrait √™tre le cas dans une future version de `Pandas`.
Cela peut valoir le coup de s'habituer √† l'ajouter. 

```{=html}
</div>
```
:::



## Pour en savoir plus

- [documentation collaborative sur `R` nomm√©e `utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_donnees_textuelles#regex)
- [_R for Data Science_](https://r4ds.hadley.nz/regexps.html)
- [_Regular Expression HOWTO_ dans la documentation officielle de `Python`](https://docs.python.org/3/howto/regex.html)
- L'outil de r√©f√©rence [https://regex101.com/] pour tester des expressions r√©guli√®res
- [Ce site](https://ole.michelsen.dk/tools/regex/) qui comporte une cheat sheet en bas de la page. 
- Les jeux de [Regex Crossword](https://regexcrossword.com/) permettent d'apprendre les expressions r√©guli√®res en s'amusant


## Exercices suppl√©mentaires

### Extraction d'adresses email

Il s'agit d'un usage classique des _regex_

```{python}
text_emails = 'Hello from toto@gmail.com to titi.grominet@yahoo.com about the meeting @2PM'
```

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice : extraction d'adresses email</h3>
```

Utiliser la structure d'une adresse mail `[XXXX]@[XXXX]` pour r√©cup√©rer 
ce contenu

```{=html}
</div>
```
:::


```{python}
#| echo: false

# \S` d√©signe tout caract√®re diff√©rent d'un espace 
# `+` pr√©sence de l'ensemble de caract√®res qui pr√©c√®de entre 1 fois et l'infini
liste_emails = re.findall('\S+@\S+', text_emails)     
print(liste_emails)
```

### Extraire des ann√©es depuis un `DataFrame` `Pandas`

L'objectif g√©n√©ral de l'exercice est de nettoyer des colonnes d'un DataFrame en utilisant des expressions r√©guli√®res.

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice</h3>
```

La base en question contient des livres de la British Library et quelques informations les concernant. Le jeu de donn√©es est disponible ici : https://raw.githubusercontent.com/realpython/python-data-cleaning/master/Datasets/BL-Flickr-Images-Book.csv

La colonne "Date de Publication" n'est pas toujours une ann√©e, il y a parfois d'autres informations. Le but de l'exercice est d'avoir **une date de publication du livre propre** et de regarder la **distribution des ann√©es de publications**. 

Pour ce faire, vous pouvez :

* Soit choisir de r√©aliser l'exercice sans aide. Votre **lecture de l'√©nonc√© s'arr√™te donc ici**. Vous devez alors faire attention √† bien regarder vous-m√™me la base de donn√©es et la transformer avec attention. 

* Soit suivre les diff√©rentes √©tapes qui suivent pas √† pas.

```{=html}
<details><summary>Version guid√©e üëá</summary>
```

1. Lire les donn√©es depuis l'url `https://raw.githubusercontent.com/realpython/python-data-cleaning/master/Datasets/BL-Flickr-Images-Book.csv`. Attention au s√©parateur
2. Ne garder que les colonnes `['Identifier', 'Place of Publication', 'Date of Publication', 'Publisher', 'Title', 'Author']`
3. Observer la colonne _'Date of Publication'_ et remarquer le probl√®me sur certaines lignes (par exemple la ligne 13)
4. Commencez par regarder le nombre d'informations manquantes. On ne pourra pas avoir mieux apr√®s la regex, et normalement on ne devrait pas avoir moins...
5. D√©terminer la forme de la regex pour une date de publication. A priori, il y a 4 chiffres qui forment une ann√©e.
Utiliser la m√©thode `str.extract()` avec l'argument `expand = False` (pour ne conserver que la premi√®re date concordant avec notre _pattern_)?
6. On a 2 `NaN` qui n'√©taient pas pr√©sents au d√©but de l'exercice. Quels sont-ils et pourquoi ? 
7. Quelle est la r√©partition des dates de publications dans le jeu de donn√©es ? Vous pouvez par exemple afficher un histogramme gr√¢ce √† la m√©thode `plot` avec l'argument `kind ="hist"`.

```{=html}
</summary>
```


```{=html}
</div>
```
:::


```{python}
#| echo: false

# Question 1
data_books = pd.read_csv('https://raw.githubusercontent.com/realpython/python-data-cleaning/master/Datasets/BL-Flickr-Images-Book.csv',sep=',')
```

```{python}
#| echo: false

# Question 2
data_books=data_books[['Identifier', 'Place of Publication',
       'Date of Publication', 'Publisher', 'Title', 'Author']]
```

Voici par exemple le probl√®me qu'on demande de d√©tecter √† la question 3 :

```{python}
#| echo: false

# Question 3
data_books[['Date of Publication',"Title"]].iloc[13:20]
```

```{python}
#| echo: false

# Question 4
data_books['Date of Publication'].isna().sum()
```

Gr√¢ce √† notre regex (question 5), on obtient ainsi un `DataFrame` plus conforme √† nos attentes

```{python}
#| echo: false

# Question 5
expression = "([0-2][0-9][0-9][0-9])"
data_books['year'] = data_books['Date of Publication'].str.extract(expression, expand=False)

data_books.loc[~(data_books['Date of Publication'] == data_books['year']), ['Date of Publication', 'year']]
```

Quant aux nouveaux `NaN`,
il s'agit de lignes qui ne contenaient pas de cha√Ænes de caract√®res qui ressemblaient √† des ann√©es :

```{python}
#| echo: false
data_books.loc[~data_books['Date of Publication'].isna() & data_books['year'].isna(), ['Date of Publication', 'year']]
```

Enfin, on obtient l'histogramme suivant des dates de publications:

```{python}
#| echo: false
pd.to_numeric(data_books['year'], downcast='integer').plot(kind ="hist")
```





